{"id":"s-6s6c","uuid":"39269e44-ae39-4ea2-88a2-662fb3328ee1","title":"Sprint 1: Agent Execution Foundation - Unified Interface Layer","file_path":"specs/sprint_1_agent_execution_foundation_unified_interf.md","content":"# Sprint 1: Agent Execution Foundation - Unified Interface Layer\n\n## Overview\n\nBuild the foundational interfaces and types for a unified agent execution system that abstracts away protocol differences between CLI agents (Codex, Claude Code, Cursor, Gemini, etc.). This is the TypeScript equivalent of vibe-kanban's `StandardCodingAgentExecutor` trait system.\n\n**Key Design Principle**: This sprint **maximizes reusability** of existing infrastructure. The execution engine already has robust process management, task execution, resilience, and workflow layers. We're adding a **thin agent abstraction layer** on top, not replacing what works.\n\n## Goals\n\n1. ✅ Create a unified `IAgentExecutor` interface that all agents implement\n1. ✅ Design normalized output types for consistent UI rendering\n1. ✅ Implement an approval service interface for interactive tool approvals\n1. ✅ Build a base executor class with common functionality\n1. ✅ Create an agent profile/registry system for configuration management\n1. ✅ **Integrate seamlessly with existing process, engine, and resilience layers**\n\n## Success Criteria\n\n- All interfaces compile with TypeScript strict mode\n- Interface design supports all target agents (Cursor, Codex, Claude, Gemini)\n- Clear separation between agent-agnostic and agent-specific logic\n- Comprehensive JSDoc documentation on all public APIs\n- Example usage patterns documented\n- No breaking changes to existing `IAgentAdapter` interface\n- **Reuses existing** `ManagedProcess`**,** `ProcessConfig`**,** `IProcessManager` **types**\n- **Minimal changes to existing layers (process/engine/resilience/workflow)**\n\n---\n\n## Integration with Existing Infrastructure\n\n### What We're Reusing (95% of existing code)\n\nSprint 1 **builds on top of** existing infrastructure, not replacing it:\n\n#### Layer 1: Process Management (100% reusable)\n\n- ✅ `process/types.ts`: `ManagedProcess`, `ProcessConfig`, `ExecutionMode` - Used as-is\n- ✅ `process/manager.ts`: `IProcessManager` interface - Used directly by `BaseAgentExecutor`\n- ✅ `process/simple-manager.ts`: `SimpleProcessManager` - Default process manager\n- ✅ `process/pty-manager.ts`: `PtyProcessManager` - For interactive agents\n- ✅ `process/factory.ts`: `createProcessManager()` - Factory for creating managers\n\n**How we use it**:\n\n```typescript\nclass BaseAgentExecutor {\n  // Reuse existing IProcessManager to spawn/manage processes\n  protected async spawnProcess(config: ProcessConfig): Promise<ManagedProcess> {\n    const manager = createProcessManager(config);\n    return manager.acquireProcess(config);\n  }\n}\n```\n\n#### Layer 2: Execution Engine (95% reusable)\n\n- ✅ `engine/types.ts`: `ExecutionTask`, `TaskResult`, `TaskStatus` - Minor extension needed\n- ✅ `engine/simple-engine.ts`: `SimpleExecutionEngine` - Task queue and concurrency\n- ⚠️ `ExecutionTask` **extension**: Add optional `agentProfile?: AgentProfileId` field\n\n**Changes needed**:\n\n```typescript\n// engine/types.ts - ADD THIS FIELD\nexport interface ExecutionTask {\n  id: string;\n  type: \"issue\" | \"spec\" | \"custom\";\n  prompt: string;\n  workDir: string;\n  agentProfile?: AgentProfileId;  // NEW: Which agent to use (optional)\n  config: { timeout?: number; env?: Record<string, string> };\n  dependencies?: string[];\n}\n```\n\n**How we use it**:\n\n```typescript\n// SimpleExecutionEngine can use AgentProfileRegistry to route tasks\nclass SimpleExecutionEngine {\n  async submitTask(task: ExecutionTask): Promise<string> {\n    // If task.agentProfile specified, use that executor\n    const executor = task.agentProfile \n      ? this.agentRegistry.getExecutor(task.agentProfile)\n      : this.defaultExecutor;\n    \n    // Rest stays the same...\n  }\n}\n```\n\n#### Layer 3: Resilience (100% reusable)\n\n- ✅ `resilience/executor.ts`: `IResilientExecutor`, `ResilientExecutor` - No changes needed\n- ✅ `resilience/retry.ts`: Retry strategies - Works with any executor\n- ✅ `resilience/circuit-breaker.ts`: Circuit breaker - Agent-agnostic\n\n**How we use it**:\n\n```typescript\n// ResilientExecutor wraps ANY executor (including new agent executors)\nconst baseExecutor = new ClaudeCodeExecutor(config);\nconst resilientExecutor = new ResilientExecutor(baseExecutor, {\n  maxAttempts: 3,\n  backoffStrategy: 'exponential',\n});\n```\n\n#### Layer 4: Workflow (100% reusable)\n\n- ✅ `workflow/orchestrator.ts`: `IWorkflowOrchestrator` - No changes needed\n- ✅ `workflow/linear-orchestrator.ts`: `LinearOrchestrator` - Works with agent executors\n- ✅ `workflow/types.ts`: `WorkflowDefinition`, `WorkflowStep` - No changes needed\n\n**How we use it**:\n\n```typescript\n// Workflows can specify which agent to use per step\nconst workflow: WorkflowDefinition = {\n  id: 'feature-workflow',\n  steps: [\n    { \n      id: 'plan', \n      taskType: 'spec',\n      prompt: 'Plan the feature',\n      agentProfile: { executor: 'claude-code', variant: 'plan' }  // Use planning agent\n    },\n    { \n      id: 'implement', \n      taskType: 'issue',\n      prompt: 'Implement the feature',\n      agentProfile: { executor: 'cursor', variant: 'default' }  // Use Cursor\n    },\n  ],\n};\n```\n\n### What We're Adding (5% new code)\n\nOnly the **agent abstraction layer** is new:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│  NEW: Agent Abstraction Layer (~2700 lines)            │\n│  ┌───────────────────────────────────────────────────┐ │\n│  │ IAgentExecutor, BaseAgentExecutor                 │ │\n│  │ NormalizedOutput, AgentProfiles                   │ │\n│  └───────────────────────────────────────────────────┘ │\n└──────────────────┬──────────────────────────────────────┘\n                   │ uses\n┌──────────────────▼──────────────────────────────────────┐\n│  EXISTING: Process/Engine/Resilience/Workflow           │\n│  (95% unchanged, ~25,000 lines)                         │\n│  ┌───────────────────────────────────────────────────┐ │\n│  │ ✅ IProcessManager, ManagedProcess                │ │\n│  │ ✅ SimpleExecutionEngine, ResilientExecutor       │ │\n│  │ ✅ LinearOrchestrator                             │ │\n│  └───────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Reusability Breakdown\n\n| Component | Lines | Reusability | Changes |\n| --- | --- | --- | --- |\n| `process/*` | ~800 | 100% | None |\n| `engine/*` | ~600 | 95% | Add 1 field to `ExecutionTask` |\n| `resilience/*` | ~400 | 100% | None |\n| `workflow/*` | ~500 | 100% | None |\n| **Total Existing** | **~2,300** | **~95%** | **Minimal** |\n| **New (Sprint 1)** | **~700** | **N/A** | **All new** |\n\n### Integration Points\n\n#### 1\\. BaseAgentExecutor ↔ IProcessManager\n\n```typescript\nabstract class BaseAgentExecutor implements IAgentExecutor {\n  // INTEGRATION POINT: Use existing process manager\n  protected async spawnWithManager(config: ProcessConfig): Promise<ManagedProcess> {\n    const manager = createProcessManager(config);  // Existing factory\n    return manager.acquireProcess(config);\n  }\n  \n  // INTEGRATION POINT: Convert ChildProcess to ManagedProcess\n  protected wrapChildProcess(child: ChildProcess): ManagedProcess {\n    // Uses existing ManagedProcess type from process/types.ts\n    return {\n      id: generateId(),\n      pid: child.pid!,\n      status: 'running',\n      process: child,\n      streams: {\n        stdout: child.stdout!,\n        stderr: child.stderr!,\n        stdin: child.stdin!,\n      },\n      metrics: { totalDuration: 0, tasksCompleted: 0, successRate: 1 },\n    };\n  }\n}\n```\n\n#### 2\\. ExecutionTask ↔ AgentProfile\n\n```typescript\n// engine/types.ts - MINIMAL CHANGE\nexport interface ExecutionTask {\n  // ... existing fields ...\n  agentProfile?: AgentProfileId;  // NEW: Optional agent selection\n}\n\n// Usage in engine\nclass SimpleExecutionEngine {\n  constructor(\n    private processManager: IProcessManager,\n    private agentRegistry?: AgentProfileRegistry,  // NEW: Optional registry\n  ) {}\n  \n  async submitTask(task: ExecutionTask): Promise<string> {\n    // INTEGRATION POINT: Use registry if available, fallback to default\n    const executor = task.agentProfile && this.agentRegistry\n      ? this.agentRegistry.getExecutor(task.agentProfile)\n      : this.defaultExecutor;\n    \n    // Rest of implementation unchanged...\n  }\n}\n```\n\n#### 3\\. Workflow ↔ Agent Executors\n\n```typescript\n// No changes to WorkflowDefinition or WorkflowStep types needed!\n// Just use existing infrastructure:\n\nconst orchestrator = new LinearOrchestrator(resilientExecutor);\n\n// Workflow steps can optionally specify agentProfile\nconst workflow: WorkflowDefinition = {\n  id: 'build-feature',\n  steps: [\n    {\n      id: 'step1',\n      taskType: 'spec',\n      prompt: 'Plan the feature',\n      // Uses ExecutionTask.agentProfile field (added in Sprint 1)\n      config: { \n        env: { AGENT_PROFILE: JSON.stringify({ executor: 'claude-code', variant: 'plan' }) }\n      },\n    },\n  ],\n};\n```\n\n### Backward Compatibility\n\n**100% backward compatible** - existing code continues to work:\n\n```typescript\n// OLD CODE (still works)\nconst adapter = new ClaudeCodeAdapter();\nconst processConfig = adapter.buildProcessConfig({ workDir: '/tmp' });\nconst manager = createProcessManager(processConfig);\n\n// NEW CODE (coexists)\nconst executor = registry.getExecutor({ executor: 'claude-code' });\nconst spawned = await executor.executeTask(task);\n```\n\n---\n\n## Architecture Diagram\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                 IAgentExecutor Interface                │\n│  (Unified execution contract for all CLI agents)        │\n│                                                         │\n│  + executeTask(task): Promise<SpawnedChild>            │\n│  + resumeTask(task, sessionId): Promise<SpawnedChild>  │\n│  + normalizeOutput(stream): AsyncIterable<Entry>       │\n│  + getCapabilities(): AgentCapabilities                │\n│  + checkAvailability(): Promise<boolean>               │\n└──────────────┬──────────────────────────────────────────┘\n               │\n               │ implements\n               ▼\n┌──────────────────────────────────────────────────────────┐\n│           BaseAgentExecutor (abstract)                   │\n│  (Common functionality shared by all executors)          │\n│                                                          │\n│  # approvalService?: IApprovalService                    │\n│  # requestApproval(request): Promise<Decision>          │\n│  # spawnWithManager(config): Promise<ManagedProcess> ◄──┐│\n│  # wrapChildProcess(child): ManagedProcess           ◄──┤│\n└──────────────┬───────────────────────────────────────────┘│\n               │                                            │\n               │ extends                                    │\n               ▼                                            │\n┌────────────────────────────────────────────┐             │\n│   Concrete Executors (Sprint 2+)           │             │\n│                                            │             │\n│   • CursorExecutor                         │             │\n│   • CodexExecExecutor                      │             │\n│   • GeminiExecutor                         │             │\n│   • ClaudeCodeExecutor                     │             │\n│   • CodexAppServerExecutor                 │             │\n└────────────────────────────────────────────┘             │\n                                                           │\n                                                           │\n┌──────────────────────────────────────────────────────────┤\n│  EXISTING INFRASTRUCTURE (reused)                        │\n│                                                          │\n│  ┌────────────────────────────────────────────────────┐ │\n│  │ process/types.ts                                   │ │\n│  │  • ManagedProcess, ProcessConfig ─────────────────┐│ │\n│  │  • ExecutionMode, ProcessStatus                   ││ │\n│  └────────────────────────────────────────────────────┘│ │\n│                                                          │\n│  ┌────────────────────────────────────────────────────┐ │\n│  │ process/manager.ts                                 │ │\n│  │  • IProcessManager ───────────────────────────────┐│ │\n│  │  • acquireProcess(), releaseProcess()             ││ │\n│  └────────────────────────────────────────────────────┘│ │\n└──────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Requirements\n\n### R1: IAgentExecutor Interface\n\n**Priority**: P0 (Critical)\n\nThe core interface that all agent executors must implement.\n\n**Interface Contract**:\n\n```typescript\ninterface IAgentExecutor {\n  // Execution methods\n  executeTask(task: ExecutionTask): Promise<SpawnedChild>\n  resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>\n  \n  // Output processing\n  normalizeOutput(\n    outputStream: AsyncIterable<OutputChunk>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry>\n  \n  // Capabilities\n  getCapabilities(): AgentCapabilities\n  checkAvailability(): Promise<boolean>\n  \n  // Optional features\n  setApprovalService?(service: IApprovalService): void\n}\n```\n\n**Why this design?**\n\n- `executeTask()` - New session execution (equivalent to vibe-kanban's `spawn()`)\n- `resumeTask()` - Session continuation (equivalent to `spawn_follow_up()`)\n- `normalizeOutput()` - Convert agent-specific output to unified format (equivalent to `normalize_logs()`)\n- `getCapabilities()` - Declare what features this agent supports\n- `checkAvailability()` - Check if agent CLI is installed/configured\n\n**Design Decisions**:\n\n1. **Async iterables for output** - Supports streaming, memory efficient\n1. **Separate execute vs resume** - Clear API, different args needed\n1. **Capabilities-based** - Agents declare what they support (no feature detection)\n1. **Optional approval service** - Not all agents need interactive approvals\n\n**Non-Goals**:\n\n- ❌ Process lifecycle management (that's `IProcessManager`'s job)\n- ❌ Task queueing (that's `IExecutionEngine`'s job)\n- ❌ Retry logic (that's `IResilientExecutor`'s job)\n\n---\n\n### R2: Normalized Output Types\n\n**Priority**: P0 (Critical)\n\nUnified output format that all agents convert to. This enables consistent UI rendering regardless of which agent produced the output.\n\n**Type Structure**:\n\n```typescript\ninterface NormalizedEntry {\n  index: number                    // Sequential entry number\n  timestamp?: Date                 // When entry was created\n  type: NormalizedEntryType        // Discriminated union of entry types\n  content: string                  // Main content (markdown-formatted)\n  metadata?: Record<string, unknown>  // Optional agent-specific data\n}\n\ntype NormalizedEntryType =\n  | { kind: 'system_message' }\n  | { kind: 'user_message' }\n  | { kind: 'assistant_message' }\n  | { kind: 'thinking'; reasoning?: string }\n  | { kind: 'tool_use'; tool: ToolUseEntry }\n  | { kind: 'error'; error: ErrorEntry }\n\ninterface ToolUseEntry {\n  toolName: string               // e.g., \"Bash\", \"Edit\", \"mcp:filesystem:read\"\n  action: ActionType             // What the tool is doing\n  status: 'created' | 'running' | 'success' | 'failed'\n  result?: ToolResult            // Result after completion\n}\n\ntype ActionType =\n  | { kind: 'file_read'; path: string }\n  | { kind: 'file_write'; path: string }\n  | { kind: 'file_edit'; path: string; changes: FileChange[] }\n  | { kind: 'command_run'; command: string; result?: CommandResult }\n  | { kind: 'search'; query: string }\n  | { kind: 'tool'; toolName: string; args?: unknown; result?: unknown }\n```\n\n**Why discriminated unions?**\n\n- Type-safe handling in consuming code\n- IDE autocomplete support\n- Pattern matching with exhaustiveness checking\n\n**Mapping Examples**:\n\n| Agent Output | Normalized Type |\n| --- | --- |\n| Claude: `{\"type\":\"assistant\",\"message\":...}` | `{kind:'assistant_message'}` |\n| Cursor: `{\"type\":\"tool_call\",\"tool_call\":{\"shellToolCall\":...}}` | `{kind:'tool_use', tool:{...}}` |\n| Codex: `{\"method\":\"codex/event/task_complete\"}` | `{kind:'system_message'}` |\n| Gemini ACP: `SessionUpdate::AgentMessageChunk` | `{kind:'assistant_message'}` |\n\n**File Changes Representation**:\n\n```typescript\ninterface FileChange {\n  type: 'edit' | 'delete'\n  unifiedDiff?: string  // Unified diff format for displaying changes\n}\n```\n\n**Design Decisions**:\n\n1. **String content** - Forces rendering at UI layer (separation of concerns)\n1. **Discriminated unions** - Type safety over loose objects\n1. **Unified diff format** - Standard for code changes\n1. **Metadata escape hatch** - Agent-specific data can be preserved\n\n---\n\n### R3: Agent Capabilities System\n\n**Priority**: P0 (Critical)\n\nDeclare what features each agent supports. Used for feature detection and UI adaptation.\n\n**Interface**:\n\n```typescript\ninterface AgentCapabilities {\n  supportsSessionResume: boolean    // Can resume previous sessions?\n  requiresSetup: boolean            // Needs setup (login, install) before use?\n  supportsApprovals: boolean        // Has interactive approval system?\n  supportsMcp: boolean              // Supports MCP servers?\n  protocol: ProtocolType            // What protocol does this use?\n}\n\ntype ProtocolType = \n  | 'acp'           // Agent Client Protocol (Gemini, Qwen)\n  | 'jsonrpc'       // JSON-RPC 2.0 (Codex app-server)\n  | 'stream-json'   // Stream JSON + control (Claude Code)\n  | 'jsonl'         // Simple JSONL (Cursor)\n  | 'custom'        // Custom protocol\n```\n\n**Usage Example**:\n\n```typescript\nconst executor = registry.getExecutor({ executor: 'cursor' });\nconst caps = executor.getCapabilities();\n\nif (caps.supportsSessionResume) {\n  // Show \"Continue from previous\" button\n}\n\nif (caps.requiresSetup) {\n  // Check availability before showing in UI\n  const available = await executor.checkAvailability();\n  if (!available) {\n    // Show setup instructions\n  }\n}\n```\n\n**Capability Matrix** (for reference):\n\n| Agent | Resume | Setup? | Approvals | MCP | Protocol |\n| --- | --- | --- | --- | --- | --- |\n| Cursor | ✅ | ✅ login | ❌ (--force) | ✅ | jsonl |\n| Codex Exec | ❌ | ❌ | ❌ | ✅ | custom |\n| Codex App | ✅ | ❌ | ✅ | ✅ | jsonrpc |\n| Claude | ✅ | ❌ | ✅ | ✅ | stream-json |\n| Gemini | ✅ | ✅ login | ✅ | ✅ | acp |\n\n---\n\n### R4: Approval Service Interface\n\n**Priority**: P1 (High)\n\nHandle interactive tool approval requests from agents (e.g., \"Allow bash command?\", \"Approve file edit?\").\n\n**Interface**:\n\n```typescript\ninterface IApprovalService {\n  requestApproval(request: ApprovalRequest): Promise<ApprovalDecision>\n}\n\ninterface ApprovalRequest {\n  requestId: string      // Unique ID (for tracking)\n  toolName: string       // e.g., \"Bash\", \"Edit\", \"mcp:server:tool\"\n  toolInput: unknown     // Tool arguments (agent-specific format)\n  context?: string       // Why this tool is needed (for UI display)\n}\n\ntype ApprovalDecision =\n  | { status: 'approved' }\n  | { status: 'denied'; reason?: string }\n  | { status: 'timeout' }\n```\n\n**Design Decisions**:\n\n1. **Simple async interface** - Implementations can show UI, use auto-rules, etc.\n1. **Unknown tool input** - Each agent has different formats (preserve as-is)\n1. **Optional context** - Some agents provide reasoning, others don't\n1. **Timeout status** - Distinguishes \"user didn't respond\" from \"user denied\"\n\n**Usage Patterns**:\n\n**Pattern 1: Auto-approve** (for CI/CD):\n\n```typescript\nclass AutoApprovalService implements IApprovalService {\n  async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    return { status: 'approved' };\n  }\n}\n```\n\n**Pattern 2: Rule-based** (approve reads, deny writes):\n\n```typescript\nclass RuleBasedApprovalService implements IApprovalService {\n  async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    if (request.toolName === 'Read') return { status: 'approved' };\n    if (request.toolName === 'Bash') return { status: 'denied', reason: 'No shell access' };\n    return { status: 'denied', reason: 'Unknown tool' };\n  }\n}\n```\n\n**Pattern 3: Interactive** (show UI):\n\n```typescript\nclass InteractiveApprovalService implements IApprovalService {\n  async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    const userChoice = await showApprovalDialog(request);\n    return userChoice ? { status: 'approved' } : { status: 'denied' };\n  }\n}\n```\n\n**Integration with Executors**:\n\n```typescript\n// Executor uses approval service if provided\nclass ClaudeCodeExecutor extends BaseAgentExecutor {\n  async handleControlRequest(request: ControlRequest) {\n    if (request.type === 'can_use_tool') {\n      const decision = await this.requestApproval({\n        requestId: request.requestId,\n        toolName: request.toolName,\n        toolInput: request.input,\n      });\n      \n      return decision.status === 'approved' \n        ? { result: 'allow' }\n        : { result: 'deny', message: decision.reason };\n    }\n  }\n}\n```\n\n---\n\n### R5: BaseAgentExecutor Abstract Class\n\n**Priority**: P1 (High)\n\nProvide shared functionality that all concrete executors can inherit. **This class integrates heavily with existing infrastructure.**\n\n**Class Structure**:\n\n```typescript\nabstract class BaseAgentExecutor implements IAgentExecutor {\n  protected approvalService?: IApprovalService;\n  \n  // Abstract methods (must be implemented by subclasses)\n  abstract executeTask(task: ExecutionTask): Promise<SpawnedChild>\n  abstract resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>\n  abstract normalizeOutput(\n    outputStream: AsyncIterable<OutputChunk>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry>\n  abstract getCapabilities(): AgentCapabilities\n  \n  // Concrete methods (shared implementation)\n  setApprovalService(service: IApprovalService): void {\n    this.approvalService = service;\n  }\n  \n  async checkAvailability(): Promise<boolean> {\n    // Default: check if executable exists in PATH\n    // Subclasses can override for custom logic\n    return true;\n  }\n  \n  // Protected helpers\n  protected async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    if (!this.approvalService) {\n      // No service = auto-approve\n      return { status: 'approved' };\n    }\n    return this.approvalService.requestApproval(request);\n  }\n  \n  // INTEGRATION POINT: Reuse existing IProcessManager\n  protected async spawnWithManager(config: ProcessConfig): Promise<ManagedProcess> {\n    const manager = createProcessManager(config);  // From process/factory.ts\n    return manager.acquireProcess(config);\n  }\n  \n  // INTEGRATION POINT: Convert ChildProcess → ManagedProcess\n  protected wrapChildProcess(child: ChildProcess): ManagedProcess {\n    // Uses ManagedProcess type from process/types.ts\n    return {\n      id: generateId(),  // From process/utils.ts\n      pid: child.pid!,\n      status: 'running',\n      process: child,\n      streams: {\n        stdout: child.stdout as Readable,\n        stderr: child.stderr as Readable,\n        stdin: child.stdin as Writable,\n      },\n      metrics: {\n        totalDuration: 0,\n        tasksCompleted: 0,\n        successRate: 1,\n      },\n    };\n  }\n  \n  // INTEGRATION POINT: Create OutputChunk stream from ManagedProcess\n  protected async *createOutputChunks(\n    process: ManagedProcess\n  ): AsyncIterable<OutputChunk> {\n    // Convert ManagedProcess.streams to OutputChunk stream\n    const { stdout, stderr } = process.streams!;\n    \n    // Multiplex stdout and stderr into single stream\n    for await (const chunk of stdout) {\n      yield {\n        type: 'stdout' as const,\n        data: Buffer.from(chunk),\n        timestamp: new Date(),\n      };\n    }\n    \n    for await (const chunk of stderr) {\n      yield {\n        type: 'stderr' as const,\n        data: Buffer.from(chunk),\n        timestamp: new Date(),\n      };\n    }\n  }\n}\n```\n\n**Shared Functionality**:\n\n1. **Approval handling** - Default to auto-approve if no service\n1. **Process wrapping** - Convert Node.js ChildProcess to ManagedProcess (reuses existing type)\n1. **Stream utilities** - Common output stream processing\n1. **Availability check** - Default implementation (check PATH)\n\n**Integration Points**:\n\n- Uses `createProcessManager()` from `process/factory.ts`\n- Uses `ManagedProcess` type from `process/types.ts`\n- Uses `generateId()` from `process/utils.ts`\n- Returns `OutputChunk` stream that can be consumed by `normalizeOutput()`\n\n**Subclass Template**:\n\n```typescript\nclass CursorExecutor extends BaseAgentExecutor {\n  constructor(private config: CursorConfig) {\n    super();\n  }\n  \n  async executeTask(task: ExecutionTask): Promise<SpawnedChild> {\n    // 1. Build ProcessConfig (uses existing type from process/types.ts)\n    const processConfig: ProcessConfig = {\n      executablePath: 'cursor-agent',\n      args: ['-p', '--output-format=stream-json', '--force'],\n      workDir: task.workDir,\n      mode: 'structured',  // Use structured mode (pipes)\n    };\n    \n    // 2. Spawn using existing process manager\n    const process = await this.spawnWithManager(processConfig);\n    \n    // 3. Send prompt to stdin\n    process.streams!.stdin.write(task.prompt + '\\n');\n    process.streams!.stdin.end();\n    \n    // 4. Return wrapped process\n    return { process };\n  }\n  \n  async *normalizeOutput(stream, workDir) {\n    // Parse Cursor JSONL format → NormalizedEntry\n    for await (const chunk of stream) {\n      const line = chunk.data.toString();\n      const entry = this.parseCursorJson(line);\n      if (entry) yield entry;\n    }\n  }\n  \n  getCapabilities(): AgentCapabilities {\n    return {\n      supportsSessionResume: true,\n      requiresSetup: true,\n      supportsApprovals: false,\n      supportsMcp: true,\n      protocol: 'jsonl',\n    };\n  }\n}\n```\n\n---\n\n### R6: Agent Profile System\n\n**Priority**: P1 (High)\n\nConfiguration management system inspired by vibe-kanban's profile system. Allows multiple variants of the same agent (e.g., \"claude:default\", \"claude:plan\", \"gemini:flash\").\n\n**Type Structure**:\n\n```typescript\ninterface AgentProfileId {\n  executor: string     // Agent type: 'claude-code', 'cursor', 'gemini'\n  variant?: string     // Optional variant: 'default', 'plan', 'flash'\n}\n\ninterface AgentProfile<TConfig = unknown> {\n  config: TConfig              // Agent-specific configuration\n  displayName: string          // Human-readable name\n  description?: string         // Description for UI\n}\n\ninterface ProfileRegistry {\n  executors: Record<string, Record<string, AgentProfile>>\n  // e.g., { \"cursor\": { \"default\": {...}, \"force\": {...} } }\n}\n```\n\n**Registry Class**:\n\n```typescript\nclass AgentProfileRegistry {\n  private profiles: ProfileRegistry = { executors: {} };\n  private factories = new Map<string, ExecutorFactory>();\n  \n  registerExecutor(name: string, factory: ExecutorFactory): void\n  registerProfile(executor: string, variant: string, profile: AgentProfile): void\n  getExecutor(profileId: AgentProfileId): IAgentExecutor | null\n  loadProfiles(registry: ProfileRegistry): void\n  getAllProfiles(): ProfileRegistry\n}\n\ntype ExecutorFactory = (config: unknown) => IAgentExecutor;\n```\n\n**Example Profiles JSON**:\n\n```json\n{\n  \"executors\": {\n    \"cursor\": {\n      \"default\": {\n        \"config\": { \"force\": true, \"model\": \"auto\" },\n        \"displayName\": \"Cursor (Auto-approve)\",\n        \"description\": \"Cursor with auto-approval enabled\"\n      },\n      \"interactive\": {\n        \"config\": { \"force\": false, \"model\": \"sonnet-4.5\" },\n        \"displayName\": \"Cursor (Interactive)\",\n        \"description\": \"Cursor with manual approvals, Sonnet 4.5\"\n      }\n    },\n    \"claude-code\": {\n      \"default\": {\n        \"config\": { \"print\": true, \"outputFormat\": \"stream-json\" },\n        \"displayName\": \"Claude Code\",\n        \"description\": \"Standard Claude Code configuration\"\n      },\n      \"plan\": {\n        \"config\": { \"print\": true, \"outputFormat\": \"stream-json\", \"planMode\": true },\n        \"displayName\": \"Claude Code (Plan Mode)\",\n        \"description\": \"Claude with plan mode enabled\"\n      }\n    }\n  }\n}\n```\n\n**Usage Pattern**:\n\n```typescript\n// 1. Set up registry\nconst registry = new AgentProfileRegistry();\n\n// 2. Register executor factories\nregistry.registerExecutor('cursor', (config) => new CursorExecutor(config as CursorConfig));\nregistry.registerExecutor('claude-code', (config) => new ClaudeCodeExecutor(config as ClaudeConfig));\n\n// 3. Load profiles from JSON\nconst profiles = loadProfilesFromFile('profiles.json');\nregistry.loadProfiles(profiles);\n\n// 4. Get executor by profile\nconst executor = registry.getExecutor({ \n  executor: 'cursor', \n  variant: 'interactive' \n});\n\n// 5. Execute task\nconst result = await executor.executeTask(task);\n```\n\n**Design Decisions**:\n\n1. **Factory pattern** - Decouple profile loading from executor instantiation\n1. **Type-safe configs** - Each executor gets strongly-typed config\n1. **Variant system** - Multiple configurations per agent\n1. **JSON-based** - Easy to edit, version control, share\n\n---\n\n### R7: Output Stream Types\n\n**Priority**: P0 (Critical)\n\nDefine the input/output types for the normalization pipeline.\n\n**Types**:\n\n```typescript\ninterface OutputChunk {\n  type: 'stdout' | 'stderr'\n  data: Buffer\n  timestamp: Date\n}\n\ninterface SpawnedChild {\n  process: ManagedProcess  // INTEGRATION POINT: Uses existing type from process/types.ts\n  exitSignal?: Promise<void>  // Optional completion signal (for ACP, etc.)\n}\n```\n\n**Why these types?**\n\n**OutputChunk**:\n\n- `type` - Distinguish stdout vs stderr\n- `data` - Raw bytes (agents may output non-UTF8)\n- `timestamp` - For log correlation and debugging\n\n**SpawnedChild**:\n\n- `process` - The managed process (from IProcessManager) - **reuses existing type**\n- `exitSignal` - Optional promise that resolves when agent is done\n  - Useful for protocols like ACP that emit completion events\n  - Allows engine to detect completion without waiting for process exit\n\n**Usage**:\n\n```typescript\n// Executor produces OutputChunks\nasync *createOutputStream(process: ManagedProcess): AsyncIterable<OutputChunk> {\n  const stdout = process.streams!.stdout;  // Uses ManagedProcess from process/types.ts\n  for await (const chunk of stdout) {\n    yield {\n      type: 'stdout',\n      data: chunk,\n      timestamp: new Date(),\n    };\n  }\n}\n\n// Normalizer consumes OutputChunks → produces NormalizedEntries\nasync *normalizeOutput(\n  stream: AsyncIterable<OutputChunk>,\n  workDir: string\n): AsyncIterable<NormalizedEntry> {\n  for await (const chunk of stream) {\n    const line = chunk.data.toString();\n    const entry = parseAgentOutput(line);\n    if (entry) yield entry;\n  }\n}\n```\n\n---\n\n## File Structure\n\nSprint 1 will create the following files:\n\n```\nsrc/agents/\n├── types/\n│   ├── agent-executor.ts        # IAgentExecutor, SpawnedChild, AgentCapabilities\n│   ├── normalized-output.ts     # NormalizedEntry and related types\n│   ├── approval-service.ts      # IApprovalService, ApprovalRequest/Decision\n│   └── index.ts                 # Re-export all types\n│\n├── base/\n│   ├── base-executor.ts         # BaseAgentExecutor abstract class\n│   │                            # INTEGRATION: Uses process/types, process/factory\n│   └── index.ts                 # Re-export\n│\n├── profiles/\n│   ├── types.ts                 # AgentProfileId, AgentProfile, ProfileRegistry\n│   ├── registry.ts              # AgentProfileRegistry class\n│   └── index.ts                 # Re-export\n│\n└── index.ts                     # Main entry point\n```\n\n**Files to modify (minimal changes)**:\n\n```\nsrc/engine/\n└── types.ts                     # ADD: agentProfile?: AgentProfileId to ExecutionTask\n```\n\n**No changes needed** to:\n\n- ✅ `src/process/*` - All files unchanged\n- ✅ `src/resilience/*` - All files unchanged\n- ✅ `src/workflow/*` - All files unchanged\n- ✅ `src/agents/types/agent-adapter.ts` - Keep for backward compatibility\n- ✅ `src/agents/claude/*`, `src/agents/codex/*` - Keep existing work\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n**File**: `tests/unit/agents/types/agent-executor.test.ts`\n\n- Type exports are correct\n- Discriminated unions work as expected\n\n**File**: `tests/unit/agents/base/base-executor.test.ts`\n\n```typescript\ndescribe('BaseAgentExecutor', () => {\n  it('should auto-approve when no approval service set', async () => {\n    const executor = new TestExecutor();\n    const decision = await executor['requestApproval']({\n      requestId: 'test-1',\n      toolName: 'Bash',\n      toolInput: { command: 'ls' },\n    });\n    expect(decision.status).toBe('approved');\n  });\n  \n  it('should delegate to approval service when set', async () => {\n    const service = {\n      requestApproval: vi.fn().mockResolvedValue({ status: 'denied' }),\n    };\n    const executor = new TestExecutor();\n    executor.setApprovalService(service);\n    \n    const decision = await executor['requestApproval']({\n      requestId: 'test-1',\n      toolName: 'Bash',\n      toolInput: { command: 'rm -rf /' },\n    });\n    \n    expect(service.requestApproval).toHaveBeenCalled();\n    expect(decision.status).toBe('denied');\n  });\n  \n  // INTEGRATION TEST: Verify BaseAgentExecutor uses existing infrastructure\n  it('should wrap ChildProcess to ManagedProcess using existing types', () => {\n    const executor = new TestExecutor();\n    const child = spawn('echo', ['test']);\n    \n    const managed = executor['wrapChildProcess'](child);\n    \n    // Verify it matches ManagedProcess interface from process/types.ts\n    expect(managed).toHaveProperty('id');\n    expect(managed).toHaveProperty('pid', child.pid);\n    expect(managed).toHaveProperty('status', 'running');\n    expect(managed).toHaveProperty('process', child);\n    expect(managed.streams).toHaveProperty('stdout');\n    expect(managed.streams).toHaveProperty('stderr');\n    expect(managed.streams).toHaveProperty('stdin');\n  });\n});\n```\n\n**File**: `tests/unit/agents/profiles/registry.test.ts`\n\n```typescript\ndescribe('AgentProfileRegistry', () => {\n  it('should register and retrieve executors', () => {\n    const registry = new AgentProfileRegistry();\n    const factory = vi.fn((config) => new MockExecutor(config));\n    \n    registry.registerExecutor('test', factory);\n    registry.registerProfile('test', 'default', {\n      config: { foo: 'bar' },\n      displayName: 'Test',\n    });\n    \n    const executor = registry.getExecutor({ executor: 'test' });\n    expect(executor).toBeDefined();\n    expect(factory).toHaveBeenCalledWith({ foo: 'bar' });\n  });\n  \n  it('should fall back to default variant if variant not specified', () => {\n    const registry = new AgentProfileRegistry();\n    registry.registerExecutor('test', (c) => new MockExecutor(c));\n    registry.registerProfile('test', 'default', { config: {}, displayName: 'Default' });\n    \n    const executor = registry.getExecutor({ executor: 'test' });\n    expect(executor).toBeDefined();\n  });\n});\n```\n\n### Integration Tests\n\nCreate `tests/integration/agents/base-executor-integration.test.ts`:\n\n- Test that `BaseAgentExecutor` works with real `IProcessManager`\n- Verify output stream creation using `ManagedProcess` streams\n- Test approval service integration\n- **Verify integration with existing process layer**:\n  ```typescript\n  it('should use existing IProcessManager to spawn processes', async () => {\n    const processManager = new SimpleProcessManager();\n    const executor = new TestExecutor({ processManager });\n    \n    const spawned = await executor.executeTask({\n      id: 'test',\n      type: 'custom',\n      prompt: 'test prompt',\n      workDir: '/tmp',\n      config: {},\n    });\n    \n    // Verify spawned.process is a valid ManagedProcess\n    expect(spawned.process).toMatchObject({\n      id: expect.any(String),\n      pid: expect.any(Number),\n      status: 'running',\n    });\n  });\n  ```\n\n---\n\n## Documentation Requirements\n\n### JSDoc Standards\n\nAll public APIs must have JSDoc comments with:\n\n- Summary (one sentence)\n- Description (detailed explanation)\n- `@param` for each parameter\n- `@returns` for return values\n- `@example` showing usage\n- `@throws` for documented errors\n\n**Example**:\n\n```typescript\n/**\n * Execute a task with this agent.\n * \n * Spawns a new process, sends the prompt, and returns a managed process\n * handle. Output can be consumed via the normalizeOutput() method.\n * \n * This method uses the existing IProcessManager infrastructure to spawn\n * and manage the child process lifecycle.\n * \n * @param task - Task configuration including prompt and working directory\n * @returns Spawned process (ManagedProcess from process/types.ts) with optional exit signal\n * @throws {ExecutorError} If agent is not available or spawn fails\n * \n * @example\n * ```typescript\n * const executor = new CursorExecutor({ workDir: '/tmp', force: true });\n * const spawned = await executor.executeTask({\n *   id: 'task-1',\n *   type: 'coding',\n *   prompt: 'Add a login feature',\n *   workDir: '/tmp',\n * });\n * \n * // spawned.process is a ManagedProcess (existing type)\n * console.log('Process PID:', spawned.process.pid);\n * ```\n */\nabstract executeTask(task: ExecutionTask): Promise<SpawnedChild>\n```\n\n### README Updates\n\nAdd section to `README.md`:\n\n```markdown\n## Agent Executors\n\nThe execution engine provides a unified interface for different CLI agents.\n\n### Supported Agents\n\n- **Cursor** - Simple JSONL protocol with auto-approval\n- **Codex** - OpenAI Codex CLI (exec mode and app-server mode)\n- **Claude Code** - Anthropic Claude Code with stream-json output\n- **Gemini** - Google Gemini CLI with ACP protocol\n\n### Using Executors\n\n\\`\\`\\`typescript\nimport { AgentProfileRegistry } from 'agent-execution-engine/agents';\nimport { CursorExecutor } from 'agent-execution-engine/agents/cursor';\n\n// Set up registry\nconst registry = new AgentProfileRegistry();\nregistry.registerExecutor('cursor', (config) => new CursorExecutor(config));\n\n// Load profiles\nconst profiles = { ... };\nregistry.loadProfiles(profiles);\n\n// Get executor\nconst executor = registry.getExecutor({ executor: 'cursor', variant: 'default' });\n\n// Execute task (uses existing ExecutionTask type from engine/types.ts)\nconst spawned = await executor.executeTask(task);\n\\`\\`\\`\n\n### Integration with Existing Layers\n\nThe agent executor layer integrates seamlessly with existing infrastructure:\n\n- **Process Management**: Uses `IProcessManager` and `ManagedProcess` from `process/*`\n- **Task Execution**: Extends `ExecutionTask` type from `engine/*`\n- **Resilience**: Works with `ResilientExecutor` from `resilience/*`\n- **Workflows**: Compatible with `LinearOrchestrator` from `workflow/*`\n\n\\`\\`\\`typescript\n// Full stack integration\nconst processManager = createProcessManager({ ... });\nconst engine = new SimpleExecutionEngine(processManager);\nconst resilientExecutor = new ResilientExecutor(engine, { maxAttempts: 3 });\nconst orchestrator = new LinearOrchestrator(resilientExecutor);\n\n// Use agent profiles in workflows\nconst workflow = {\n  steps: [{\n    id: 'step1',\n    prompt: 'Build feature',\n    agentProfile: { executor: 'claude-code', variant: 'plan' }\n  }]\n};\n\\`\\`\\`\n```\n\n---\n\n## Non-Functional Requirements\n\n### NFR1: Performance\n\n- Output normalization must support streaming (no buffering entire output)\n- Profile lookups should be O(1) (use Map/object)\n- No unnecessary object allocations in hot paths\n- **Reuse existing process management** (don't spawn multiple managers)\n\n### NFR2: Memory\n\n- Async iterables for output (constant memory regardless of output size)\n- Profile registry should not duplicate config objects\n- **Leverage existing ManagedProcess pooling** (don't create duplicate process wrappers)\n\n### NFR3: Type Safety\n\n- All public APIs must be fully typed (no `any`)\n- Discriminated unions for variant types\n- Generic type parameters where appropriate\n- **Strict compatibility with existing types** (`ManagedProcess`, `ProcessConfig`, etc.)\n\n### NFR4: Backward Compatibility\n\n- Existing `IAgentAdapter` interface must remain unchanged\n- Existing Claude/Codex adapters should continue to work\n- No breaking changes to process/engine/resilience layers\n- **Zero changes to existing layer interfaces**\n\n---\n\n## Migration Path\n\n### Phase 1: Add New Interfaces (Sprint 1)\n\n- Add new files alongside existing code\n- Minimal modification to existing files (only `engine/types.ts` - add 1 field)\n- 100% backward compatible\n\n### Phase 2: Implement Adapters (Sprint 2-4)\n\n- Create new executor implementations\n- Keep old adapters working\n- Gradual migration\n\n### Phase 3: Integrate (Sprint 5)\n\n- Update `SimpleExecutionEngine` to optionally use `IAgentExecutor`\n- Deprecate old `IAgentAdapter` usage\n- Maintain backward compatibility via adapter pattern\n\n---\n\n## Open Questions\n\n1. **Q: Should we support both** `IAgentAdapter` **and** `IAgentExecutor` **long-term?**\n\n- A: Yes, for backward compatibility. `IAgentAdapter` is simpler for basic use cases.\n\n1. **Q: How do we handle agent-specific output formats in metadata?**\n\n- A: Preserve raw output in `metadata` field, consumers can parse if needed.\n\n1. **Q: Should approval service be injectable per-task or per-executor?**\n\n- A: Per-executor (set once), simplifies API and matches vibe-kanban pattern.\n\n1. **Q: Do we need a factory interface or just use functions?**\n\n- A: Functions are simpler, no need for interface (YAGNI).\n\n1. **Q: Should BaseAgentExecutor create its own process manager or reuse existing one?**\n\n- A: Reuse existing via factory pattern (`createProcessManager()`), avoids duplication.\n\n---\n\n## Dependencies\n\n### Internal\n\n- `process/types` - `ManagedProcess`, `ProcessConfig` ✅ (100% reused)\n- `process/manager` - `IProcessManager` ✅ (used directly)\n- `process/factory` - `createProcessManager()` ✅ (used for spawning)\n- `process/utils` - `generateId()` ✅ (used for process IDs)\n- `engine/types` - `ExecutionTask`, `TaskResult` ⚠️ (extend with 1 field)\n\n### External\n\n- None (Sprint 1 is purely type definitions and base classes)\n\n---\n\n## Deliverables\n\nSprint 1 complete when:\n\n- ✅ All interfaces defined and documented\n- ✅ `BaseAgentExecutor` implemented with tests\n- ✅ `AgentProfileRegistry` implemented with tests\n- ✅ 100% test coverage on new code\n- ✅ JSDoc on all public APIs\n- ✅ README updated with agent executor section\n- ✅ No TypeScript errors in strict mode\n- ✅ All existing tests still pass (no regressions)\n- ✅ **Integration tests verify compatibility with existing** `IProcessManager`\n- ✅ **Minimal changes to existing files** (only 1 field addition to `ExecutionTask`)\n\n---\n\n## Timeline\n\n**Week 1**:\n\n- Day 1-2: Define all interfaces and types\n- Day 3-4: Implement `BaseAgentExecutor` and tests (focus on integration with existing process layer)\n- Day 5: Implement `AgentProfileRegistry` and tests\n\n**Week 2**:\n\n- Day 1-2: Documentation and examples (emphasize integration points)\n- Day 3-4: Code review and refinements\n- Day 5: Final testing and merge to main\n\n---\n\n## References\n\n- \\[\\[vibe-kanban\\]\\] - Reference implementation (Rust)\n  - `executors/src/executors/mod.rs` - `StandardCodingAgentExecutor` trait\n  - `executors/src/profile.rs` - Profile system\n  - `executors/src/executors/cursor.rs` - Example concrete executor\n- **Existing codebase** - Integration points:\n  - `src/process/types.ts` - `ManagedProcess`, `ProcessConfig` types\n  - `src/process/manager.ts` - `IProcessManager` interface\n  - `src/process/factory.ts` - `createProcessManager()` factory\n  - `src/engine/types.ts` - `ExecutionTask` type (to be extended)","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-20 08:14:37","updated_at":"2025-11-20 08:52:46","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["architecture","foundation","interfaces","sprint-1"]}
{"id":"s-925w","uuid":"059c1eb6-1819-4008-9fa4-9a2bb4a07345","title":"Claude Code Executor - Stream-JSON + Control Protocol Implementation","file_path":"specs/claude_code_executor_stream_json_control_protocol_.md","content":"# Claude Code Executor - Stream-JSON + Control Protocol Implementation\n\n## Overview\n\nImplement a Claude Code executor that wraps the `claude` CLI using the unified `IAgentExecutor` interface. Claude Code uses a **stream-json output format** with a **lightweight bidirectional control protocol** for interactive approvals.\n\n## Goals\n\n1. ✅ Implement `ClaudeCodeExecutor` extending `BaseAgentExecutor`\n2. ✅ Support both initial execution and session resumption\n3. ✅ Parse stream-json output format into `NormalizedEntry`\n4. ✅ Handle bidirectional control protocol for tool approvals\n5. ✅ Support hook-based approval flow (PreToolUse hook + can_use_tool)\n6. ✅ Stream assistant messages with proper coalescing\n\n## Context\n\n### Reference Implementation\n\nBased on vibe-kanban's Claude Code executor:\n- **File**: `crates/executors/src/executors/claude.rs` (280 lines)\n- **Protocol Peer**: `crates/executors/src/executors/claude/protocol.rs` (200 lines)\n- **Client**: `crates/executors/src/executors/claude/client.rs` (206 lines)\n\n### Protocol Overview\n\nClaude Code uses two communication layers:\n\n**Layer 1: Stream-JSON** (stdout)\n- Newline-delimited JSON messages\n- Message types: `system`, `user`, `assistant`, `tool_use`, `result`\n- Each message has `type` field for discrimination\n\n**Layer 2: Control Protocol** (stdin ↔ stdout)\n- Bidirectional JSON messages for approvals\n- Message types: `control_request`, `control_response`\n- Handles `can_use_tool` and `hook_callback` requests\n\n```\n┌─────────────────────────────────────────────────────┐\n│  ClaudeCodeExecutor                                 │\n│                                                     │\n│  1. Spawns: claude -p --output-format=stream-json  │\n│     --input-format=stream-json                     │\n│     --permission-prompt-tool=stdio                 │\n│                                                     │\n│  2. ProtocolPeer manages stdin/stdout              │\n│     ├─ Reads stream-json from stdout              │\n│     ├─ Parses control_request messages            │\n│     ├─ Sends control_response to stdin            │\n│     └─ Forwards regular messages to normalizer    │\n│                                                     │\n│  3. ClaudeAgentClient handles logic                │\n│     ├─ on_can_use_tool() - approval decisions     │\n│     ├─ on_hook_callback() - captures tool_use_id  │\n│     └─ on_non_control() - forwards to output      │\n└─────────────────────────────────────────────────────┘\n                     │\n                     ▼\n      ┌──────────────────────────────────────┐\n      │  Claude Code CLI Process              │\n      │                                       │\n      │  • Writes stream-json to stdout      │\n      │  • Reads JSON from stdin             │\n      │  • Sends control_request when        │\n      │    approval needed                   │\n      │  • Waits for control_response        │\n      └──────────────────────────────────────┘\n```\n\n---\n\n## Requirements\n\n### R1: ClaudeCodeExecutor Class\n\n**Priority**: P0 (Critical)\n\nMain executor class implementing `IAgentExecutor`.\n\n**Interface**:\n```typescript\nexport interface ClaudeCodeConfig {\n  workDir: string\n  executablePath?: string      // Path to 'claude' binary (default: 'claude')\n  print?: boolean              // -p flag (required for stream-json)\n  outputFormat?: 'stream-json' | 'json'  // Default: 'stream-json'\n  inputFormat?: 'stream-json'  // Default: 'stream-json'\n  verbose?: boolean            // --verbose flag\n  dangerouslySkipPermissions?: boolean  // Skip all approvals (for testing)\n}\n\nexport class ClaudeCodeExecutor extends BaseAgentExecutor {\n  constructor(config: ClaudeCodeConfig)\n  \n  async executeTask(task: ExecutionTask): Promise<SpawnedChild>\n  async resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>\n  async *normalizeOutput(stream: AsyncIterable<OutputChunk>, workDir: string): AsyncIterable<NormalizedEntry>\n  getCapabilities(): AgentCapabilities\n}\n```\n\n**Implementation Details**:\n\n**executeTask()**:\n```typescript\nasync executeTask(task: ExecutionTask): Promise<SpawnedChild> {\n  // 1. Build command args\n  const args = [\n    '-p',  // Print mode (required for stream-json)\n    '--output-format', this.config.outputFormat ?? 'stream-json',\n    '--input-format', this.config.inputFormat ?? 'stream-json',\n    '--permission-prompt-tool', 'stdio',  // Use stdin/stdout for approvals\n  ];\n  \n  if (this.config.verbose) {\n    args.push('--verbose');\n  }\n  \n  if (this.config.dangerouslySkipPermissions) {\n    args.push('--dangerously-skip-permissions');\n  }\n  \n  // 2. Spawn process\n  const child = spawn(this.config.executablePath ?? 'claude', args, {\n    cwd: task.workDir,\n    stdio: ['pipe', 'pipe', 'pipe'],\n  });\n  \n  // 3. Set up protocol peer\n  const stdin = child.stdin!;\n  const stdout = child.stdout!;\n  const stderr = child.stderr!;\n  \n  const client = new ClaudeAgentClient(this.approvalService);\n  const peer = new ProtocolPeer(stdin, stdout, client);\n  \n  // 4. Initialize protocol\n  await peer.initialize(this.buildHooks());\n  \n  // 5. Send user message\n  await peer.sendUserMessage(task.prompt);\n  \n  // 6. Return wrapped process\n  return {\n    process: this.wrapChildProcess(child),\n  };\n}\n```\n\n**resumeTask()**:\n```typescript\nasync resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild> {\n  // Same as executeTask but add --resume-session flag\n  // Claude Code automatically loads session from ~/.claude/sessions/{sessionId}\n  const args = [\n    '-p',\n    '--output-format', 'stream-json',\n    '--resume-session', sessionId,\n    // ... rest of args\n  ];\n  \n  // ... spawn and return\n}\n```\n\n**getCapabilities()**:\n```typescript\ngetCapabilities(): AgentCapabilities {\n  return {\n    supportsSessionResume: true,\n    requiresSetup: false,  // No login required\n    supportsApprovals: true,\n    supportsMcp: true,\n    protocol: 'stream-json',\n  };\n}\n```\n\n---\n\n### R2: Stream-JSON Message Types\n\n**Priority**: P0 (Critical)\n\nType definitions for Claude Code's stream-json output format.\n\n**Message Envelope**:\n```typescript\nexport type ClaudeStreamMessage = \n  | SystemMessage\n  | UserMessage\n  | AssistantMessage\n  | ToolUseMessage\n  | ResultMessage\n  | ControlRequestMessage\n  | ControlResponseMessage;\n\n// Base fields present on all messages\ninterface BaseMessage {\n  type: string\n  sessionId?: string\n}\n```\n\n**System Messages**:\n```typescript\ninterface SystemMessage extends BaseMessage {\n  type: 'system'\n  subtype?: 'init' | 'session_start'\n  sessionId: string\n  model?: string\n  mcpServers?: Array<{ name: string; status: string }>\n}\n```\n\n**User Messages**:\n```typescript\ninterface UserMessage extends BaseMessage {\n  type: 'user'\n  message: {\n    role: 'user'\n    content: Array<ContentBlock>\n  }\n  sessionId?: string\n}\n```\n\n**Assistant Messages**:\n```typescript\ninterface AssistantMessage extends BaseMessage {\n  type: 'assistant'\n  message: {\n    role: 'assistant'\n    content: Array<ContentBlock>\n  }\n  sessionId?: string\n}\n\ntype ContentBlock = TextBlock | ToolUseBlock;\n\ninterface TextBlock {\n  type: 'text'\n  text: string\n}\n\ninterface ToolUseBlock {\n  type: 'tool_use'\n  id: string          // tool_use_id (for matching with hook callbacks)\n  name: string        // Tool name: 'Bash', 'Edit', 'Read', etc.\n  input: unknown      // Tool-specific input\n}\n```\n\n**Tool Use Messages**:\n```typescript\ninterface ToolUseMessage extends BaseMessage {\n  type: 'tool_use'\n  subtype?: 'started' | 'completed'\n  toolUseId?: string\n  toolName?: string\n  toolInput?: unknown\n  toolResult?: unknown\n  sessionId?: string\n}\n```\n\n**Result Messages**:\n```typescript\ninterface ResultMessage extends BaseMessage {\n  type: 'result'\n  isError: boolean\n  durationMs?: number\n  result?: unknown\n  sessionId?: string\n}\n```\n\n---\n\n### R3: Control Protocol Types\n\n**Priority**: P0 (Critical)\n\nType definitions for the bidirectional control protocol.\n\n**Control Request** (from CLI → SDK):\n```typescript\ninterface ControlRequestMessage extends BaseMessage {\n  type: 'control_request'\n  requestId: string\n  request: ControlRequest\n}\n\ntype ControlRequest = \n  | CanUseToolRequest\n  | HookCallbackRequest;\n\ninterface CanUseToolRequest {\n  type: 'can_use_tool'\n  toolName: string\n  input: unknown\n  permissionSuggestions?: PermissionUpdate[]\n}\n\ninterface HookCallbackRequest {\n  type: 'hook_callback'\n  callbackId: string\n  input: unknown\n  toolUseId?: string   // Present for PreToolUse hook\n}\n\ninterface PermissionUpdate {\n  updateType: 'set_mode' | 'add_permission' | 'remove_permission'\n  mode?: PermissionMode\n  destination: 'session' | 'global'\n}\n\ntype PermissionMode = 'ask' | 'bypass_permissions';\n```\n\n**Control Response** (from SDK → CLI):\n```typescript\ninterface ControlResponseMessage {\n  type: 'control_response'\n  response: ControlResponse\n}\n\ntype ControlResponse = \n  | SuccessResponse\n  | ErrorResponse;\n\ninterface SuccessResponse {\n  type: 'success'\n  requestId: string\n  response?: unknown  // Hook output or permission decision\n}\n\ninterface ErrorResponse {\n  type: 'error'\n  requestId: string\n  error?: string\n}\n```\n\n**Permission Decisions**:\n```typescript\ntype PermissionResult = AllowResult | DenyResult;\n\ninterface AllowResult {\n  result: 'allow'\n  updatedInput?: unknown\n  updatedPermissions?: PermissionUpdate[]\n}\n\ninterface DenyResult {\n  result: 'deny'\n  message?: string\n  interrupt?: boolean  // Should agent stop execution?\n}\n```\n\n---\n\n### R4: ProtocolPeer Class\n\n**Priority**: P0 (Critical)\n\nManages bidirectional communication over stdin/stdout.\n\n**Class Structure**:\n```typescript\nexport class ProtocolPeer {\n  private stdin: Writable\n  private stdoutReader: AsyncIterable<string>\n  private client: ClaudeAgentClient\n  \n  constructor(\n    stdin: Writable,\n    stdout: Readable,\n    client: ClaudeAgentClient\n  )\n  \n  // Lifecycle\n  async initialize(hooks?: HookConfig): Promise<void>\n  async setPermissionMode(mode: PermissionMode): Promise<void>\n  \n  // Sending messages\n  async sendUserMessage(content: string): Promise<void>\n  async sendControlResponse(requestId: string, response: ControlResponse): Promise<void>\n  \n  // Reading loop (internal)\n  private async readLoop(): Promise<void>\n  private async handleControlRequest(requestId: string, request: ControlRequest): Promise<void>\n}\n```\n\n**Implementation Details**:\n\n**Constructor + Read Loop**:\n```typescript\nconstructor(stdin: Writable, stdout: Readable, client: ClaudeAgentClient) {\n  this.stdin = stdin;\n  this.stdoutReader = this.createLineReader(stdout);\n  this.client = client;\n  \n  // Start background read loop\n  this.startReadLoop();\n}\n\nprivate async readLoop(): Promise<void> {\n  for await (const line of this.stdoutReader) {\n    if (!line.trim()) continue;\n    \n    try {\n      const message = JSON.parse(line) as ClaudeStreamMessage;\n      \n      if (message.type === 'control_request') {\n        await this.handleControlRequest(message.requestId, message.request);\n      } else if (message.type === 'result') {\n        // Task complete - forward to client and exit loop\n        await this.client.onNonControl(line);\n        break;\n      } else {\n        // Regular message - forward to client\n        await this.client.onNonControl(line);\n      }\n    } catch (e) {\n      // Non-JSON line - forward as-is\n      await this.client.onNonControl(line);\n    }\n  }\n}\n```\n\n**Control Request Handling**:\n```typescript\nprivate async handleControlRequest(requestId: string, request: ControlRequest): Promise<void> {\n  try {\n    let response: unknown;\n    \n    if (request.type === 'can_use_tool') {\n      response = await this.client.onCanUseTool(\n        request.toolName,\n        request.input,\n        request.permissionSuggestions\n      );\n    } else if (request.type === 'hook_callback') {\n      response = await this.client.onHookCallback(\n        request.callbackId,\n        request.input,\n        request.toolUseId\n      );\n    }\n    \n    await this.sendControlResponse(requestId, {\n      type: 'success',\n      requestId,\n      response,\n    });\n  } catch (error) {\n    await this.sendControlResponse(requestId, {\n      type: 'error',\n      requestId,\n      error: error.message,\n    });\n  }\n}\n```\n\n**Sending Messages**:\n```typescript\nasync sendUserMessage(content: string): Promise<void> {\n  const message = {\n    type: 'user',\n    message: {\n      role: 'user',\n      content,\n    },\n  };\n  await this.sendJson(message);\n}\n\nasync sendControlResponse(requestId: string, response: ControlResponse): Promise<void> {\n  const message: ControlResponseMessage = {\n    type: 'control_response',\n    response,\n  };\n  await this.sendJson(message);\n}\n\nprivate async sendJson(message: unknown): Promise<void> {\n  const json = JSON.stringify(message);\n  this.stdin.write(json + '\\n');\n}\n```\n\n**Initialize with Hooks**:\n```typescript\nasync initialize(hooks?: HookConfig): Promise<void> {\n  const message = {\n    type: 'sdk_control_request',\n    request: {\n      type: 'initialize',\n      hooks: hooks ?? {\n        preToolUse: {\n          enabled: true,\n        },\n      },\n    },\n  };\n  await this.sendJson(message);\n}\n```\n\n---\n\n### R5: ClaudeAgentClient Class\n\n**Priority**: P0 (Critical)\n\nBusiness logic for handling approval requests and hook callbacks.\n\n**Class Structure**:\n```typescript\nexport class ClaudeAgentClient {\n  private approvalService?: IApprovalService\n  private latestUnhandledToolUseId: string | null = null\n  \n  constructor(approvalService?: IApprovalService)\n  \n  // Approval flow\n  async onCanUseTool(\n    toolName: string,\n    input: unknown,\n    permissionSuggestions?: PermissionUpdate[]\n  ): Promise<PermissionResult>\n  \n  // Hook callbacks\n  async onHookCallback(\n    callbackId: string,\n    input: unknown,\n    toolUseId?: string\n  ): Promise<HookOutput>\n  \n  // Output forwarding\n  async onNonControl(line: string): Promise<void>\n}\n```\n\n**Implementation Details**:\n\n**Hook Callback Flow**:\n```typescript\nasync onHookCallback(\n  callbackId: string,\n  input: unknown,\n  toolUseId?: string\n): Promise<HookOutput> {\n  // Store tool_use_id for later approval matching\n  if (toolUseId) {\n    this.latestUnhandledToolUseId = toolUseId;\n  }\n  \n  // Return 'ask' to trigger can_use_tool request\n  // (Hook callbacks have 60s timeout, can't wait for user)\n  return {\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'ask',\n      permissionDecisionReason: 'Forwarding to can_use_tool service',\n    },\n  };\n}\n```\n\n**Approval Flow**:\n```typescript\nasync onCanUseTool(\n  toolName: string,\n  input: unknown,\n  permissionSuggestions?: PermissionUpdate[]\n): Promise<PermissionResult> {\n  // Auto-approve if no service\n  if (!this.approvalService) {\n    return {\n      result: 'allow',\n      updatedInput: input,\n    };\n  }\n  \n  // Get tool_use_id from previous hook callback\n  const toolUseId = this.latestUnhandledToolUseId;\n  this.latestUnhandledToolUseId = null;  // Clear for next tool\n  \n  // Request approval\n  const decision = await this.approvalService.requestApproval({\n    requestId: toolUseId ?? crypto.randomUUID(),\n    toolName,\n    toolInput: input,\n  });\n  \n  // Convert to PermissionResult\n  if (decision.status === 'approved') {\n    // Special case: ExitPlanMode switches to bypass mode\n    if (toolName === 'ExitPlanMode') {\n      return {\n        result: 'allow',\n        updatedInput: input,\n        updatedPermissions: [{\n          updateType: 'set_mode',\n          mode: 'bypass_permissions',\n          destination: 'session',\n        }],\n      };\n    }\n    \n    return {\n      result: 'allow',\n      updatedInput: input,\n    };\n  }\n  \n  return {\n    result: 'deny',\n    message: decision.reason ?? 'Denied by user',\n    interrupt: false,\n  };\n}\n```\n\n---\n\n### R6: Output Normalization\n\n**Priority**: P0 (Critical)\n\nParse Claude stream-json into `NormalizedEntry` format.\n\n**Normalizer Implementation**:\n```typescript\nasync *normalizeOutput(\n  stream: AsyncIterable<OutputChunk>,\n  workDir: string\n): AsyncIterable<NormalizedEntry> {\n  let index = 0;\n  \n  // Streaming state\n  let sessionIdReported = false;\n  let currentAssistantBuffer = '';\n  let currentAssistantIndex: number | null = null;\n  \n  const toolUseMap = new Map<string, number>();  // tool_use_id -> entry index\n  \n  for await (const chunk of stream) {\n    if (chunk.type !== 'stdout') continue;\n    \n    const lines = chunk.data.toString().split('\\n');\n    \n    for (const line of lines) {\n      if (!line.trim()) continue;\n      \n      try {\n        const message = JSON.parse(line) as ClaudeStreamMessage;\n        \n        // Extract session ID (once)\n        if (!sessionIdReported && message.sessionId) {\n          // TODO: Store session ID somewhere\n          sessionIdReported = true;\n        }\n        \n        // Handle message types\n        if (message.type === 'system') {\n          yield this.normalizeSystemMessage(message, index++);\n        } else if (message.type === 'assistant') {\n          // Coalesce streaming assistant messages\n          const textContent = message.message.content\n            .filter((c): c is TextBlock => c.type === 'text')\n            .map(c => c.text)\n            .join('');\n          \n          if (textContent) {\n            currentAssistantBuffer += textContent;\n            \n            const entry: NormalizedEntry = {\n              index: currentAssistantIndex ?? index,\n              type: { kind: 'assistant_message' },\n              content: currentAssistantBuffer,\n              timestamp: chunk.timestamp,\n            };\n            \n            if (currentAssistantIndex === null) {\n              currentAssistantIndex = index++;\n              yield entry;\n            } else {\n              // Update existing entry\n              yield { ...entry, index: currentAssistantIndex };\n            }\n          }\n          \n          // Handle tool uses in content\n          const toolUses = message.message.content\n            .filter((c): c is ToolUseBlock => c.type === 'tool_use');\n          \n          for (const toolUse of toolUses) {\n            const entry = this.normalizeToolUse(toolUse, index, workDir);\n            toolUseMap.set(toolUse.id, index);\n            yield entry;\n            index++;\n          }\n          \n          // Reset assistant buffer on non-streaming\n          if (!textContent) {\n            currentAssistantBuffer = '';\n            currentAssistantIndex = null;\n          }\n        } else if (message.type === 'tool_use' && message.subtype === 'completed') {\n          // Update tool use entry with result\n          const entryIndex = toolUseMap.get(message.toolUseId ?? '');\n          if (entryIndex !== undefined) {\n            yield this.normalizeToolResult(message, entryIndex, workDir);\n          }\n        } else if (message.type === 'result') {\n          // Task completion\n          if (message.isError) {\n            yield {\n              index: index++,\n              type: {\n                kind: 'error',\n                error: {\n                  errorType: 'execution_failed',\n                  message: JSON.stringify(message.result),\n                },\n              },\n              content: 'Task failed',\n              timestamp: chunk.timestamp,\n            };\n          }\n        }\n      } catch (e) {\n        // Non-JSON line - emit as system message\n        yield {\n          index: index++,\n          type: { kind: 'system_message' },\n          content: line,\n          timestamp: chunk.timestamp,\n        };\n      }\n    }\n  }\n}\n```\n\n**Tool Use Normalization**:\n```typescript\nprivate normalizeToolUse(\n  toolUse: ToolUseBlock,\n  index: number,\n  workDir: string\n): NormalizedEntry {\n  const action = this.parseToolAction(toolUse.name, toolUse.input, workDir);\n  \n  return {\n    index,\n    type: {\n      kind: 'tool_use',\n      tool: {\n        toolName: toolUse.name,\n        action,\n        status: 'created',\n      },\n    },\n    content: this.formatToolContent(toolUse.name, toolUse.input),\n    timestamp: new Date(),\n  };\n}\n\nprivate parseToolAction(\n  toolName: string,\n  input: unknown,\n  workDir: string\n): ActionType {\n  // Parse different tool types\n  if (toolName === 'Bash') {\n    const cmd = (input as any)?.command ?? '';\n    return {\n      kind: 'command_run',\n      command: cmd,\n    };\n  } else if (toolName === 'Edit') {\n    const path = this.makeRelative((input as any)?.path ?? '', workDir);\n    return {\n      kind: 'file_edit',\n      path,\n      changes: [],  // Will be filled in on completion\n    };\n  } else if (toolName === 'Read') {\n    const path = this.makeRelative((input as any)?.path ?? '', workDir);\n    return {\n      kind: 'file_read',\n      path,\n    };\n  } else if (toolName === 'Write') {\n    const path = this.makeRelative((input as any)?.path ?? '', workDir);\n    return {\n      kind: 'file_write',\n      path,\n    };\n  }\n  \n  // Generic tool\n  return {\n    kind: 'tool',\n    toolName,\n    args: input,\n  };\n}\n```\n\n---\n\n## File Structure\n\n```\nsrc/agents/claude/\n├── types/\n│   ├── messages.ts           # ClaudeStreamMessage types\n│   ├── control.ts            # Control protocol types\n│   └── index.ts              # Re-exports\n│\n├── protocol/\n│   ├── protocol-peer.ts      # ProtocolPeer class\n│   ├── client.ts             # ClaudeAgentClient class\n│   └── index.ts              # Re-exports\n│\n├── executor.ts               # ClaudeCodeExecutor class\n├── normalizer.ts             # Output normalization logic\n├── config-builder.ts         # Legacy adapter (keep for back-compat)\n└── index.ts                  # Main exports\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n**File**: `tests/unit/agents/claude/protocol-peer.test.ts`\n```typescript\ndescribe('ProtocolPeer', () => {\n  it('should parse control requests from stdout', async () => {\n    const mockStdout = createMockReadable([\n      '{\"type\":\"control_request\",\"requestId\":\"req-1\",\"request\":{\"type\":\"can_use_tool\",\"toolName\":\"Bash\",\"input\":{\"command\":\"ls\"}}}\\n'\n    ]);\n    \n    const client = {\n      onCanUseTool: vi.fn().mockResolvedValue({ result: 'allow' }),\n      onNonControl: vi.fn(),\n    };\n    \n    const peer = new ProtocolPeer(mockStdin, mockStdout, client as any);\n    \n    await waitFor(() => expect(client.onCanUseTool).toHaveBeenCalled());\n    expect(client.onCanUseTool).toHaveBeenCalledWith('Bash', { command: 'ls' }, undefined);\n  });\n  \n  it('should send control responses to stdin', async () => {\n    const mockStdin = createMockWritable();\n    const peer = new ProtocolPeer(mockStdin, mockStdout, mockClient);\n    \n    await peer.sendControlResponse('req-1', {\n      type: 'success',\n      requestId: 'req-1',\n      response: { result: 'allow' },\n    });\n    \n    expect(mockStdin.writtenData).toContain('{\"type\":\"control_response\"');\n  });\n});\n```\n\n**File**: `tests/unit/agents/claude/client.test.ts`\n```typescript\ndescribe('ClaudeAgentClient', () => {\n  it('should store tool_use_id from hook callback', async () => {\n    const client = new ClaudeAgentClient();\n    \n    await client.onHookCallback('cb-1', {}, 'tool-123');\n    \n    // Next can_use_tool should use this ID\n    const approvalService = {\n      requestApproval: vi.fn().mockResolvedValue({ status: 'approved' }),\n    };\n    client['approvalService'] = approvalService;\n    \n    await client.onCanUseTool('Bash', { command: 'ls' });\n    \n    expect(approvalService.requestApproval).toHaveBeenCalledWith({\n      requestId: 'tool-123',\n      toolName: 'Bash',\n      toolInput: { command: 'ls' },\n    });\n  });\n  \n  it('should switch to bypass mode on ExitPlanMode approval', async () => {\n    const approvalService = {\n      requestApproval: vi.fn().mockResolvedValue({ status: 'approved' }),\n    };\n    const client = new ClaudeAgentClient(approvalService);\n    \n    const result = await client.onCanUseTool('ExitPlanMode', {});\n    \n    expect(result).toMatchObject({\n      result: 'allow',\n      updatedPermissions: [{\n        updateType: 'set_mode',\n        mode: 'bypass_permissions',\n        destination: 'session',\n      }],\n    });\n  });\n});\n```\n\n**File**: `tests/unit/agents/claude/normalizer.test.ts`\n```typescript\ndescribe('ClaudeCodeExecutor.normalizeOutput', () => {\n  it('should parse system init message', async () => {\n    const executor = new ClaudeCodeExecutor({ workDir: '/tmp' });\n    const stream = mockOutputChunks([\n      '{\"type\":\"system\",\"subtype\":\"init\",\"sessionId\":\"sess-123\",\"model\":\"claude-sonnet-4\"}\\n'\n    ]);\n    \n    const normalized = [];\n    for await (const entry of executor.normalizeOutput(stream, '/tmp')) {\n      normalized.push(entry);\n    }\n    \n    expect(normalized).toHaveLength(1);\n    expect(normalized[0].type.kind).toBe('system_message');\n    expect(normalized[0].content).toContain('claude-sonnet-4');\n  });\n  \n  it('should coalesce streaming assistant messages', async () => {\n    const executor = new ClaudeCodeExecutor({ workDir: '/tmp' });\n    const stream = mockOutputChunks([\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Hello\"}]}}\\n',\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\" world\"}]}}\\n',\n    ]);\n    \n    const normalized = [];\n    for await (const entry of executor.normalizeOutput(stream, '/tmp')) {\n      normalized.push(entry);\n    }\n    \n    // Should produce 2 entries (initial + update) with same index\n    expect(normalized).toHaveLength(2);\n    expect(normalized[0].content).toBe('Hello');\n    expect(normalized[1].content).toBe('Hello world');\n    expect(normalized[0].index).toBe(normalized[1].index);\n  });\n  \n  it('should parse tool use with Bash command', async () => {\n    const executor = new ClaudeCodeExecutor({ workDir: '/tmp' });\n    const stream = mockOutputChunks([\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"id\":\"tool-1\",\"name\":\"Bash\",\"input\":{\"command\":\"ls -la\"}}]}}\\n'\n    ]);\n    \n    const normalized = [];\n    for await (const entry of executor.normalizeOutput(stream, '/tmp')) {\n      normalized.push(entry);\n    }\n    \n    expect(normalized).toHaveLength(1);\n    expect(normalized[0].type).toMatchObject({\n      kind: 'tool_use',\n      tool: {\n        toolName: 'Bash',\n        action: { kind: 'command_run', command: 'ls -la' },\n        status: 'created',\n      },\n    });\n  });\n});\n```\n\n### Integration Tests\n\n**File**: `tests/integration/agents/claude/executor-integration.test.ts`\n```typescript\ndescribe('ClaudeCodeExecutor (integration)', () => {\n  it('should execute task and parse output', async () => {\n    const executor = new ClaudeCodeExecutor({\n      workDir: '/tmp/test',\n      dangerouslySkipPermissions: true,  // Skip approvals for test\n    });\n    \n    const task: ExecutionTask = {\n      id: 'test-1',\n      type: 'coding',\n      prompt: 'List files in current directory',\n      workDir: '/tmp/test',\n    };\n    \n    const spawned = await executor.executeTask(task);\n    \n    // Collect output\n    const entries: NormalizedEntry[] = [];\n    const outputStream = createOutputChunks(spawned.process);\n    \n    for await (const entry of executor.normalizeOutput(outputStream, '/tmp/test')) {\n      entries.push(entry);\n    }\n    \n    // Should have system init, assistant message, tool use, result\n    expect(entries.length).toBeGreaterThan(0);\n    expect(entries.some(e => e.type.kind === 'system_message')).toBe(true);\n    expect(entries.some(e => e.type.kind === 'assistant_message')).toBe(true);\n  });\n});\n```\n\n---\n\n## Dependencies\n\n### Internal\n- [[s-6s6c]] - Sprint 1 foundation (IAgentExecutor, BaseAgentExecutor)\n- `process/types` - ManagedProcess\n- `engine/types` - ExecutionTask\n\n### External\n- None (uses only Node.js built-ins)\n\n---\n\n## Non-Functional Requirements\n\n### NFR1: Performance\n- Stream processing (no buffering entire output)\n- Async iterator for memory efficiency\n- Coalesce streaming messages to reduce UI updates\n\n### NFR2: Robustness\n- Handle non-JSON lines gracefully\n- Continue on parse errors\n- Proper error propagation\n\n### NFR3: Type Safety\n- All message types fully typed\n- Discriminated unions for pattern matching\n- No `any` types in public API\n\n---\n\n## Implementation Phases\n\n### Phase 1: Core Types (Day 1-2)\n- [ ] Define all message types\n- [ ] Define control protocol types\n- [ ] Write type tests\n\n### Phase 2: Protocol Layer (Day 3-4)\n- [ ] Implement ProtocolPeer\n- [ ] Implement ClaudeAgentClient\n- [ ] Unit tests for protocol\n\n### Phase 3: Executor (Day 5-6)\n- [ ] Implement ClaudeCodeExecutor\n- [ ] Implement executeTask/resumeTask\n- [ ] Integration with BaseAgentExecutor\n\n### Phase 4: Normalization (Day 7-8)\n- [ ] Implement normalizeOutput\n- [ ] Tool use parsing\n- [ ] Message coalescing\n\n### Phase 5: Testing & Polish (Day 9-10)\n- [ ] Complete unit test coverage\n- [ ] Integration tests\n- [ ] Documentation\n- [ ] Edge case handling\n\n---\n\n## Open Questions\n\n1. **Q: Should we support both stream-json and regular json output?**\n   - A: Start with stream-json only. Regular json is deprecated in Claude Code.\n\n2. **Q: How to handle session storage?**\n   - A: Claude Code stores sessions in `~/.claude/sessions/`. We just pass session ID, CLI handles the rest.\n\n3. **Q: What about MCP server configuration?**\n   - A: Claude Code reads from `~/.claude/claude_desktop_config.json`. Executor doesn't manage this.\n\n4. **Q: Should we implement plan mode as a separate executor or config option?**\n   - A: Config option. Plan mode is just a flag: `--enable-plan-mode`\n\n---\n\n## Success Criteria\n\nSprint complete when:\n- ✅ ClaudeCodeExecutor implements full IAgentExecutor interface\n- ✅ Can execute tasks and parse output\n- ✅ Approval flow works (hook → can_use_tool)\n- ✅ Session resumption works\n- ✅ 100% test coverage on protocol layer\n- ✅ Integration test passes with real Claude CLI\n- ✅ Documentation with examples\n\n---\n\n## References\n\n- vibe-kanban Claude implementation: `crates/executors/src/executors/claude.rs`\n- Claude Code docs: https://docs.claude.com/en/api/agent-sdk\n- Control protocol spec: https://docs.claude.com/en/api/agent-sdk/permissions\n","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-20 08:40:33","updated_at":"2025-11-20 08:40:33","parent_id":null,"parent_uuid":null,"relationships":[{"from":"s-925w","from_type":"spec","to":"s-6s6c","to_type":"spec","type":"depends-on"}],"tags":["claude-code","control-protocol","implementation","sprint-2","stream-json"]}
{"id":"s-31mr","uuid":"3a9b58f6-cfbd-44e7-9199-2a7a5880827c","title":"Codex Executor - JSONRPC App Server Protocol Implementation","file_path":"specs/codex_executor_jsonrpc_app_server_protocol_impleme.md","content":"# Codex Executor - JSONRPC App Server Protocol Implementation\n\n## Overview\n\nImplement a Codex CLI executor that uses the `@openai/codex app-server` mode with JSONRPC 2.0 protocol for bidirectional communication. This executor supports session resumption, interactive approvals, and comprehensive output normalization.\n\n**Reference Implementation**: vibe-kanban's Codex executor (Rust)\n- `executors/src/executors/codex.rs` - Main executor\n- `executors/src/executors/codex/client.rs` - AppServerClient (JSONRPC client)\n- `executors/src/executors/codex/jsonrpc.rs` - JsonRpcPeer (JSONRPC protocol)\n- `executors/src/executors/codex/normalize_logs.rs` - Output normalization\n\n## Goals\n\n1. ✅ Implement `CodexExecutor` extending `BaseAgentExecutor`\n2. ✅ Build JSONRPC 2.0 client for bidirectional communication\n3. ✅ Handle Codex app-server lifecycle (initialize, new/resume conversation, send messages)\n4. ✅ Implement approval handling for bash commands and file edits\n5. ✅ Normalize Codex event stream to unified `NormalizedEntry` format\n6. ✅ Support session resumption via rollout files\n\n## Success Criteria\n\n- [ ] Spawns Codex app-server process successfully\n- [ ] Establishes JSONRPC 2.0 bidirectional communication\n- [ ] Handles all Codex events (agent messages, tool calls, approvals, errors)\n- [ ] Normalizes output to `NormalizedEntry` format\n- [ ] Supports session resumption\n- [ ] Integrates with `IApprovalService` for interactive approvals\n- [ ] All tests pass (unit + integration)\n- [ ] JSDoc documentation on all public APIs\n\n---\n\n## Architecture\n\n### Component Diagram\n\n```\n┌─────────────────────────────────────────────────────────┐\n│             CodexExecutor (IAgentExecutor)              │\n│                                                         │\n│  + executeTask()     - Spawn new conversation          │\n│  + resumeTask()      - Resume from rollout file        │\n│  + normalizeOutput() - Parse events to NormalizedEntry │\n└──────────────────┬──────────────────────────────────────┘\n                   │\n                   │ uses\n                   ▼\n┌─────────────────────────────────────────────────────────┐\n│              JsonRpcPeer (JSONRPC Protocol)             │\n│                                                         │\n│  + send(message)          - Send notification/request  │\n│  + request(id, message)   - Send request, await reply  │\n│  + onRequest(handler)     - Handle server requests     │\n│  + onResponse(handler)    - Handle responses           │\n│  + onNotification(handler)- Handle notifications       │\n└──────────────────┬──────────────────────────────────────┘\n                   │\n                   │ uses\n                   ▼\n┌─────────────────────────────────────────────────────────┐\n│         AppServerClient (Codex Client Logic)            │\n│                                                         │\n│  + initialize()                  - Send initialize      │\n│  + newConversation(params)       - Start new session   │\n│  + resumeConversation(path)      - Resume session      │\n│  + sendUserMessage(id, msg)      - Send prompt         │\n│  + handleApprovalRequest(req)    - Process approvals   │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Protocol Flow\n\n**1. New Conversation Flow**:\n```\nCodexExecutor.executeTask()\n  ↓\nSpawn: npx @openai/codex app-server\n  ↓\nAppServerClient.initialize()\n  → Request: {\"method\":\"initialize\",\"id\":1}\n  ← Response: {\"id\":1,\"result\":{...}}\n  → Notification: {\"method\":\"initialized\"}\n  ↓\nAppServerClient.newConversation(params)\n  → Request: {\"method\":\"newConversation\",\"id\":2,\"params\":{...}}\n  ← Response: {\"id\":2,\"result\":{\"conversationId\":\"...\", \"rolloutPath\":\"...\"}}\n  ↓\nAppServerClient.addConversationListener(conversationId)\n  → Request: {\"method\":\"addConversationListener\",\"id\":3}\n  ← Response: {\"id\":3,\"result\":{...}}\n  ↓\nAppServerClient.sendUserMessage(conversationId, prompt)\n  → Request: {\"method\":\"sendUserMessage\",\"id\":4,\"params\":{\"items\":[{\"text\":\"...\"}]}}\n  ← Response: {\"id\":4,\"result\":{...}}\n  ← Notifications: codex/event/* (agent messages, tool calls, etc.)\n```\n\n**2. Resume Conversation Flow**:\n```\nCodexExecutor.resumeTask(sessionId)\n  ↓\nSessionHandler.forkRolloutFile(sessionId)\n  ↓\nAppServerClient.resumeConversation(rolloutPath, overrides)\n  → Request: {\"method\":\"resumeConversation\",\"id\":2,\"params\":{\"path\":\"...\",\"overrides\":{...}}}\n  ← Response: {\"id\":2,\"result\":{\"conversationId\":\"...\"}}\n  ↓\n(Continue with addConversationListener + sendUserMessage)\n```\n\n**3. Approval Flow**:\n```\n← ServerRequest: {\"method\":\"execCommandApproval\",\"id\":\"server-1\",\"params\":{\"callId\":\"...\",\"command\":[\"ls\"]}}\n  ↓\nAppServerClient.handleApprovalRequest()\n  ↓\nIApprovalService.requestApproval(tool:\"bash\", input:{...})\n  ↓\n→ Response: {\"id\":\"server-1\",\"result\":{\"decision\":\"Approved\"}}\n  OR\n→ Response: {\"id\":\"server-1\",\"result\":{\"decision\":\"Denied\"}}\n```\n\n---\n\n## Requirements\n\n### R1: CodexExecutor Class\n\n**Priority**: P0 (Critical)\n\nImplement the main executor class extending `BaseAgentExecutor`.\n\n**Interface**:\n```typescript\nexport interface CodexConfig {\n  sandbox?: 'auto' | 'read-only' | 'workspace-write' | 'danger-full-access';\n  askForApproval?: 'unless-trusted' | 'on-failure' | 'on-request' | 'never';\n  oss?: boolean;\n  model?: string;\n  modelReasoningEffort?: 'low' | 'medium' | 'high';\n  modelReasoningSummary?: 'auto' | 'concise' | 'detailed' | 'none';\n  modelReasoningSummaryFormat?: 'none' | 'experimental';\n  profile?: string;\n  baseInstructions?: string;\n  includePlanTool?: boolean;\n  includeApplyPatchTool?: boolean;\n}\n\nexport class CodexExecutor extends BaseAgentExecutor {\n  constructor(private config: CodexConfig);\n  \n  async executeTask(task: ExecutionTask): Promise<SpawnedChild>;\n  async resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>;\n  async *normalizeOutput(\n    stream: AsyncIterable<OutputChunk>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry>;\n  getCapabilities(): AgentCapabilities;\n  async checkAvailability(): Promise<boolean>;\n}\n```\n\n**Implementation Details**:\n\n**Spawn Process**:\n```typescript\nprivate async spawnCodexProcess(\n  workDir: string,\n  prompt: string,\n  sessionId?: string\n): Promise<SpawnedChild> {\n  // 1. Build command: npx -y @openai/codex@0.58.0 app-server [--oss]\n  const args = ['@openai/codex@0.58.0', 'app-server'];\n  if (this.config.oss) args.push('--oss');\n  \n  // 2. Spawn process with stdio pipes\n  const child = spawn('npx', ['-y', ...args], {\n    cwd: workDir,\n    stdio: ['pipe', 'pipe', 'pipe'],\n    env: {\n      ...process.env,\n      NODE_NO_WARNINGS: '1',\n      NO_COLOR: '1',\n    },\n  });\n  \n  // 3. Create JSONRPC client and establish connection\n  const rpcPeer = new JsonRpcPeer(child.stdin!, child.stdout!, exitSignal);\n  const client = new AppServerClient(rpcPeer, this.approvalService);\n  \n  // 4. Initialize app server\n  await client.initialize();\n  \n  // 5. Start or resume conversation\n  if (sessionId) {\n    const rolloutPath = await SessionHandler.forkRolloutFile(sessionId);\n    await client.resumeConversation(rolloutPath, this.buildConversationParams(workDir));\n  } else {\n    await client.newConversation(this.buildConversationParams(workDir));\n  }\n  \n  // 6. Send user message\n  await client.sendUserMessage(prompt);\n  \n  // 7. Wrap and return\n  return {\n    process: this.wrapChildProcess(child),\n    exitSignal: exitSignal.promise,\n  };\n}\n```\n\n**Build Conversation Params**:\n```typescript\nprivate buildConversationParams(cwd: string): NewConversationParams {\n  return {\n    cwd,\n    sandbox: this.mapSandboxMode(this.config.sandbox),\n    approvalPolicy: this.mapApprovalPolicy(this.config.askForApproval),\n    model: this.config.model,\n    profile: this.config.profile,\n    baseInstructions: this.config.baseInstructions,\n    includePlanTool: this.config.includePlanTool,\n    includeApplyPatchTool: this.config.includeApplyPatchTool,\n    config: this.buildConfigOverrides(),\n  };\n}\n\nprivate buildConfigOverrides(): Record<string, unknown> | undefined {\n  const overrides: Record<string, unknown> = {};\n  \n  if (this.config.modelReasoningEffort) {\n    overrides.model_reasoning_effort = this.config.modelReasoningEffort;\n  }\n  \n  if (this.config.modelReasoningSummary) {\n    overrides.model_reasoning_summary = this.config.modelReasoningSummary;\n  }\n  \n  if (this.config.modelReasoningSummaryFormat && \n      this.config.modelReasoningSummaryFormat !== 'none') {\n    overrides.model_reasoning_summary_format = this.config.modelReasoningSummaryFormat;\n  }\n  \n  return Object.keys(overrides).length > 0 ? overrides : undefined;\n}\n```\n\n**Capabilities**:\n```typescript\ngetCapabilities(): AgentCapabilities {\n  return {\n    supportsSessionResume: true,\n    requiresSetup: false,\n    supportsApprovals: true,\n    supportsMcp: true,\n    protocol: 'jsonrpc',\n  };\n}\n```\n\n---\n\n### R2: JsonRpcPeer - JSONRPC 2.0 Protocol Handler\n\n**Priority**: P0 (Critical)\n\nImplement bidirectional JSONRPC 2.0 communication over stdin/stdout.\n\n**Interface**:\n```typescript\ntype RequestId = string | number;\n\ninterface JSONRPCRequest {\n  jsonrpc: '2.0';\n  method: string;\n  params?: unknown;\n  id: RequestId;\n}\n\ninterface JSONRPCResponse {\n  jsonrpc: '2.0';\n  result?: unknown;\n  error?: { code: number; message: string; data?: unknown };\n  id: RequestId;\n}\n\ninterface JSONRPCNotification {\n  jsonrpc: '2.0';\n  method: string;\n  params?: unknown;\n}\n\nexport class JsonRpcPeer {\n  private requestIdCounter = 1;\n  private pendingRequests = new Map<RequestId, PendingRequest>();\n  \n  constructor(\n    private stdin: Writable,\n    private stdout: Readable,\n    private exitSignal: ExitSignal\n  );\n  \n  // Send methods\n  async send(message: JSONRPCNotification | JSONRPCRequest | JSONRPCResponse): Promise<void>;\n  async request<T>(method: string, params?: unknown): Promise<T>;\n  \n  // Handler registration\n  onRequest(handler: RequestHandler): void;\n  onResponse(handler: ResponseHandler): void;\n  onNotification(handler: NotificationHandler): void;\n  \n  // Lifecycle\n  nextRequestId(): RequestId;\n  close(): void;\n}\n\ninterface PendingRequest {\n  resolve: (result: unknown) => void;\n  reject: (error: Error) => void;\n  label: string;\n}\n\ntype RequestHandler = (request: JSONRPCRequest) => Promise<unknown>;\ntype ResponseHandler = (response: JSONRPCResponse) => Promise<void>;\ntype NotificationHandler = (notification: JSONRPCNotification) => Promise<boolean>; // returns: should exit?\n```\n\n**Implementation Details**:\n\n**Background Reader Loop**:\n```typescript\nprivate startReaderLoop(): void {\n  const reader = readline.createInterface({\n    input: this.stdout,\n    crlfDelay: Infinity,\n  });\n  \n  reader.on('line', async (line) => {\n    try {\n      const json = JSON.parse(line);\n      \n      if ('method' in json && 'id' in json) {\n        // Request from server\n        await this.handleRequest(json as JSONRPCRequest);\n      } else if ('result' in json || 'error' in json) {\n        // Response to our request\n        await this.handleResponse(json as JSONRPCResponse);\n      } else if ('method' in json) {\n        // Notification from server\n        const shouldExit = await this.handleNotification(json as JSONRPCNotification);\n        if (shouldExit) {\n          this.exitSignal.resolve();\n        }\n      }\n    } catch (err) {\n      // Non-JSON line, call onNonJson handler if registered\n      this.onNonJsonHandler?.(line);\n    }\n  });\n  \n  reader.on('close', () => {\n    this.exitSignal.resolve();\n  });\n}\n```\n\n**Send Request**:\n```typescript\nasync request<T>(method: string, params?: unknown, label?: string): Promise<T> {\n  const id = this.nextRequestId();\n  \n  return new Promise((resolve, reject) => {\n    this.pendingRequests.set(id, { resolve, reject, label: label || method });\n    \n    const request: JSONRPCRequest = {\n      jsonrpc: '2.0',\n      method,\n      params,\n      id,\n    };\n    \n    this.send(request);\n  });\n}\n```\n\n**Handle Response**:\n```typescript\nprivate async handleResponse(response: JSONRPCResponse): Promise<void> {\n  const pending = this.pendingRequests.get(response.id);\n  if (!pending) {\n    console.error(`Received response for unknown request ID: ${response.id}`);\n    return;\n  }\n  \n  this.pendingRequests.delete(response.id);\n  \n  if (response.error) {\n    pending.reject(new Error(`JSONRPC error: ${response.error.message}`));\n  } else {\n    pending.resolve(response.result);\n  }\n  \n  // Call response handler if registered\n  if (this.responseHandler) {\n    await this.responseHandler(response);\n  }\n}\n```\n\n---\n\n### R3: AppServerClient - Codex App Server Logic\n\n**Priority**: P0 (Critical)\n\nImplement Codex-specific JSONRPC client methods and approval handling.\n\n**Interface**:\n```typescript\nexport class AppServerClient {\n  constructor(\n    private rpc: JsonRpcPeer,\n    private approvalService?: IApprovalService\n  );\n  \n  // Lifecycle methods\n  async initialize(): Promise<InitializeResponse>;\n  \n  // Conversation methods\n  async newConversation(params: NewConversationParams): Promise<NewConversationResponse>;\n  async resumeConversation(\n    rolloutPath: string,\n    overrides: NewConversationParams\n  ): Promise<ResumeConversationResponse>;\n  async addConversationListener(conversationId: string): Promise<void>;\n  async sendUserMessage(conversationId: string, message: string): Promise<void>;\n  \n  // Approval handling\n  async handleExecCommandApproval(request: ExecCommandApprovalRequest): Promise<ExecCommandApprovalResponse>;\n  async handleApplyPatchApproval(request: ApplyPatchApprovalRequest): Promise<ApplyPatchApprovalResponse>;\n}\n```\n\n**Types** (from `@openai/codex` protocol):\n```typescript\ninterface NewConversationParams {\n  cwd?: string;\n  sandbox?: 'read-only' | 'workspace-write' | 'danger-full-access';\n  approvalPolicy?: 'unless-trusted' | 'on-failure' | 'on-request' | 'never';\n  model?: string;\n  profile?: string;\n  baseInstructions?: string;\n  includePlanTool?: boolean;\n  includeApplyPatchTool?: boolean;\n  config?: Record<string, unknown>;\n}\n\ninterface NewConversationResponse {\n  conversationId: string;\n  rolloutPath: string;\n  model: string;\n  reasoningEffort?: 'low' | 'medium' | 'high';\n}\n\ninterface ResumeConversationParams {\n  path: string;\n  overrides?: NewConversationParams;\n}\n\ninterface ResumeConversationResponse {\n  conversationId: string;\n  model: string;\n  reasoningEffort?: 'low' | 'medium' | 'high';\n}\n\ninterface ExecCommandApprovalRequest {\n  callId: string;\n  command: string[];\n  cwd: string;\n  reason?: string;\n}\n\ninterface ExecCommandApprovalResponse {\n  decision: 'Approved' | 'Denied' | 'ApprovedForSession' | 'Abort';\n}\n\ninterface ApplyPatchApprovalRequest {\n  callId: string;\n  changes: Record<string, FileChange>;\n  reason?: string;\n  grantRoot?: boolean;\n}\n\ninterface ApplyPatchApprovalResponse {\n  decision: 'Approved' | 'Denied' | 'ApprovedForSession' | 'Abort';\n}\n```\n\n**Implementation Details**:\n\n**Initialize**:\n```typescript\nasync initialize(): Promise<InitializeResponse> {\n  const response = await this.rpc.request<InitializeResponse>('initialize', {\n    clientInfo: {\n      name: 'agent-execution-engine',\n      version: '1.0.0',\n    },\n  });\n  \n  // Send initialized notification\n  await this.rpc.send({\n    jsonrpc: '2.0',\n    method: 'initialized',\n  });\n  \n  return response;\n}\n```\n\n**Handle Exec Command Approval**:\n```typescript\nasync handleExecCommandApproval(\n  request: ExecCommandApprovalRequest\n): Promise<ExecCommandApprovalResponse> {\n  // Default to auto-approve if no approval service\n  if (!this.approvalService) {\n    return { decision: 'Approved' };\n  }\n  \n  const decision = await this.approvalService.requestApproval({\n    requestId: request.callId,\n    toolName: 'bash',\n    toolInput: {\n      command: request.command.join(' '),\n      cwd: request.cwd,\n    },\n    context: request.reason,\n  });\n  \n  // Map ApprovalDecision to ReviewDecision\n  if (decision.status === 'approved') {\n    return { decision: 'Approved' };\n  } else if (decision.status === 'denied' && decision.reason) {\n    // If user provides feedback, use Abort (sends feedback to agent)\n    return { decision: 'Abort' };\n  } else {\n    return { decision: 'Denied' };\n  }\n}\n```\n\n**Send Feedback** (after denial):\n```typescript\nprivate async sendFeedback(conversationId: string, feedback: string): Promise<void> {\n  await this.sendUserMessage(conversationId, `User feedback: ${feedback}`);\n}\n```\n\n---\n\n### R4: Output Normalization\n\n**Priority**: P0 (Critical)\n\nParse Codex event stream and convert to `NormalizedEntry` format.\n\n**Codex Event Types** (from `codex/event/*` notifications):\n```typescript\n// Agent messages\ninterface AgentMessageDeltaEvent {\n  delta: string;  // Streaming assistant message chunk\n}\n\ninterface AgentMessageEvent {\n  message: string;  // Complete assistant message\n}\n\n// Thinking/Reasoning\ninterface AgentReasoningDeltaEvent {\n  delta: string;  // Streaming reasoning chunk\n}\n\ninterface AgentReasoningEvent {\n  text: string;  // Complete reasoning\n}\n\n// Tool calls - Bash\ninterface ExecCommandBeginEvent {\n  callId: string;\n  command: string[];\n  cwd: string;\n}\n\ninterface ExecCommandOutputDeltaEvent {\n  callId: string;\n  stream: 'stdout' | 'stderr';\n  chunk: Buffer;\n}\n\ninterface ExecCommandEndEvent {\n  callId: string;\n  exitCode: number;\n  formattedOutput: string;\n}\n\n// Tool calls - Edit\ninterface PatchApplyBeginEvent {\n  callId: string;\n  changes: Record<string, FileChange>;\n}\n\ninterface PatchApplyEndEvent {\n  callId: string;\n  success: boolean;\n}\n\n// Tool calls - MCP\ninterface McpToolCallBeginEvent {\n  callId: string;\n  invocation: { server: string; tool: string; arguments: unknown };\n}\n\ninterface McpToolCallEndEvent {\n  callId: string;\n  result: { content: unknown; isError?: boolean };\n}\n\n// Other events\ninterface SessionConfiguredEvent {\n  sessionId: string;\n  model: string;\n  reasoningEffort?: string;\n}\n\ninterface TokenCountEvent {\n  info: { inputTokens: number; outputTokens: number };\n}\n\ninterface ErrorEvent {\n  message: string;\n}\n\ninterface TaskCompleteEvent {} // Signals end of turn\n```\n\n**Normalization Logic**:\n```typescript\nasync *normalizeOutput(\n  stream: AsyncIterable<OutputChunk>,\n  workDir: string\n): AsyncIterable<NormalizedEntry> {\n  const state = new NormalizationState();\n  \n  for await (const chunk of stream) {\n    if (chunk.type === 'stderr') continue; // Ignore stderr\n    \n    const lines = chunk.data.toString().split('\\n');\n    \n    for (const line of lines) {\n      if (!line.trim()) continue;\n      \n      let json: unknown;\n      try {\n        json = JSON.parse(line);\n      } catch {\n        continue; // Skip non-JSON lines\n      }\n      \n      // Handle JSONRPC notifications (codex/event/*)\n      if (isJSONRPCNotification(json) && json.method.startsWith('codex/event')) {\n        const event = json.params?.msg;\n        \n        if (!event) continue;\n        \n        // Map event to NormalizedEntry\n        const entries = this.mapEventToEntry(event, state, workDir);\n        for (const entry of entries) {\n          yield entry;\n        }\n      }\n    }\n  }\n}\n\nprivate mapEventToEntry(\n  event: CodexEvent,\n  state: NormalizationState,\n  workDir: string\n): NormalizedEntry[] {\n  const eventType = event.constructor.name; // Or use discriminator field\n  \n  switch (eventType) {\n    case 'AgentMessageDelta':\n      return [state.appendAssistantMessage(event.delta)];\n    \n    case 'AgentReasoningDelta':\n      return [state.appendThinking(event.delta)];\n    \n    case 'ExecCommandBegin':\n      return [state.createCommand(event.callId, event.command.join(' '))];\n    \n    case 'ExecCommandOutputDelta':\n      return [state.updateCommandOutput(event.callId, event.stream, event.chunk)];\n    \n    case 'ExecCommandEnd':\n      return [state.completeCommand(event.callId, event.exitCode, event.formattedOutput)];\n    \n    case 'PatchApplyBegin':\n      return state.createPatches(event.callId, event.changes, workDir);\n    \n    case 'PatchApplyEnd':\n      return state.completePatches(event.callId, event.success);\n    \n    // ... handle other event types\n    \n    default:\n      return [];\n  }\n}\n```\n\n**Normalization State** (stateful tracking):\n```typescript\nclass NormalizationState {\n  private entryIndex = 0;\n  private assistantMessage?: { index: number; content: string };\n  private thinking?: { index: number; content: string };\n  private commands = new Map<string, CommandState>();\n  private patches = new Map<string, PatchState>();\n  \n  appendAssistantMessage(delta: string): NormalizedEntry {\n    if (!this.assistantMessage) {\n      this.assistantMessage = { index: this.nextIndex(), content: delta };\n    } else {\n      this.assistantMessage.content += delta;\n    }\n    \n    return {\n      index: this.assistantMessage.index,\n      type: { kind: 'assistant_message' },\n      content: this.assistantMessage.content,\n      timestamp: new Date(),\n    };\n  }\n  \n  createCommand(callId: string, command: string): NormalizedEntry {\n    const index = this.nextIndex();\n    this.commands.set(callId, {\n      index,\n      command,\n      stdout: '',\n      stderr: '',\n      exitCode: null,\n      status: 'created',\n    });\n    \n    return {\n      index,\n      type: {\n        kind: 'tool_use',\n        tool: {\n          toolName: 'bash',\n          action: { kind: 'command_run', command, result: null },\n          status: 'created',\n        },\n      },\n      content: `\\`${command}\\``,\n      timestamp: new Date(),\n    };\n  }\n  \n  completeCommand(callId: string, exitCode: number, output: string): NormalizedEntry {\n    const cmd = this.commands.get(callId)!;\n    cmd.exitCode = exitCode;\n    cmd.status = exitCode === 0 ? 'success' : 'failed';\n    \n    return {\n      index: cmd.index,\n      type: {\n        kind: 'tool_use',\n        tool: {\n          toolName: 'bash',\n          action: {\n            kind: 'command_run',\n            command: cmd.command,\n            result: {\n              exitStatus: { kind: 'exit_code', code: exitCode },\n              output,\n            },\n          },\n          status: cmd.status,\n        },\n      },\n      content: `\\`${cmd.command}\\``,\n      timestamp: new Date(),\n    };\n  }\n  \n  // ... similar methods for patches, MCP tools, etc.\n}\n```\n\n---\n\n### R5: Session Management\n\n**Priority**: P1 (High)\n\nSupport session resumption via rollout files.\n\n**SessionHandler Class**:\n```typescript\nexport class SessionHandler {\n  private static readonly ROLLOUT_DIR = path.join(os.homedir(), '.codex', 'rollouts');\n  \n  /**\n   * Fork a rollout file for session resumption\n   * \n   * Codex stores conversation history in rollout files at:\n   * ~/.codex/rollouts/{sessionId}.jsonl\n   * \n   * We copy the file to a temporary location for resumption.\n   */\n  static async forkRolloutFile(sessionId: string): Promise<string> {\n    const sourcePath = path.join(this.ROLLOUT_DIR, `${sessionId}.jsonl`);\n    \n    if (!fs.existsSync(sourcePath)) {\n      throw new Error(`Rollout file not found for session: ${sessionId}`);\n    }\n    \n    // Create fork with new ID\n    const forkedSessionId = `${sessionId}-fork-${Date.now()}`;\n    const destPath = path.join(this.ROLLOUT_DIR, `${forkedSessionId}.jsonl`);\n    \n    await fs.promises.copyFile(sourcePath, destPath);\n    \n    return destPath;\n  }\n  \n  /**\n   * Extract session ID from rollout path\n   */\n  static extractSessionId(rolloutPath: string): string {\n    const filename = path.basename(rolloutPath, '.jsonl');\n    return filename;\n  }\n}\n```\n\n**Usage in ResumeTask**:\n```typescript\nasync resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild> {\n  // 1. Fork rollout file\n  const rolloutPath = await SessionHandler.forkRolloutFile(sessionId);\n  \n  // 2. Spawn process and initialize\n  const child = await this.spawnCodexProcess(task.workDir, task.prompt, sessionId);\n  \n  // 3. Resume conversation using forked rollout\n  await this.client.resumeConversation(rolloutPath, this.buildConversationParams(task.workDir));\n  \n  // 4. Send new user message\n  await this.client.sendUserMessage(task.prompt);\n  \n  return child;\n}\n```\n\n---\n\n### R6: Error Handling\n\n**Priority**: P1 (High)\n\nGraceful error handling for common failure scenarios.\n\n**Error Types**:\n```typescript\nexport class CodexExecutorError extends Error {\n  constructor(message: string, public code: string, public cause?: Error) {\n    super(message);\n    this.name = 'CodexExecutorError';\n  }\n  \n  static notAvailable(): CodexExecutorError {\n    return new CodexExecutorError(\n      'Codex CLI not available. Install with: npm install -g @openai/codex',\n      'NOT_AVAILABLE'\n    );\n  }\n  \n  static sessionNotFound(sessionId: string): CodexExecutorError {\n    return new CodexExecutorError(\n      `Session rollout file not found: ${sessionId}`,\n      'SESSION_NOT_FOUND'\n    );\n  }\n  \n  static rpcTimeout(method: string): CodexExecutorError {\n    return new CodexExecutorError(\n      `JSONRPC request timeout: ${method}`,\n      'RPC_TIMEOUT'\n    );\n  }\n}\n```\n\n**Timeout Handling**:\n```typescript\nasync request<T>(\n  method: string,\n  params?: unknown,\n  timeoutMs = 30000\n): Promise<T> {\n  return Promise.race([\n    this.rpc.request<T>(method, params),\n    new Promise<never>((_, reject) =>\n      setTimeout(() => reject(CodexExecutorError.rpcTimeout(method)), timeoutMs)\n    ),\n  ]);\n}\n```\n\n---\n\n## File Structure\n\n```\nsrc/agents/codex/\n├── types/\n│   ├── protocol.ts              # Codex protocol types (events, requests, responses)\n│   ├── config.ts                # CodexConfig interface\n│   └── index.ts                 # Re-export types\n│\n├── jsonrpc/\n│   ├── peer.ts                  # JsonRpcPeer class (JSONRPC 2.0 handler)\n│   ├── types.ts                 # JSONRPC base types\n│   └── index.ts                 # Re-export\n│\n├── client/\n│   ├── app-server-client.ts     # AppServerClient class\n│   ├── session-handler.ts       # SessionHandler (rollout file management)\n│   └── index.ts                 # Re-export\n│\n├── normalizer/\n│   ├── normalizer.ts            # Output normalization logic\n│   ├── state.ts                 # NormalizationState class\n│   ├── mappers.ts               # Event → NormalizedEntry mappers\n│   └── index.ts                 # Re-export\n│\n├── executor.ts                  # CodexExecutor class (main entry)\n├── errors.ts                    # CodexExecutorError\n└── index.ts                     # Public API exports\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n**File**: `tests/unit/agents/codex/jsonrpc/peer.test.ts`\n```typescript\ndescribe('JsonRpcPeer', () => {\n  it('should send requests and receive responses', async () => {\n    const { stdin, stdout } = createMockStreams();\n    const peer = new JsonRpcPeer(stdin, stdout, exitSignal);\n    \n    // Simulate server response\n    setTimeout(() => {\n      stdout.emit('data', JSON.stringify({\n        jsonrpc: '2.0',\n        id: 1,\n        result: { status: 'ok' },\n      }) + '\\n');\n    }, 10);\n    \n    const result = await peer.request('test', { foo: 'bar' });\n    expect(result).toEqual({ status: 'ok' });\n  });\n  \n  it('should handle server requests and send responses', async () => {\n    const { stdin, stdout } = createMockStreams();\n    const peer = new JsonRpcPeer(stdin, stdout, exitSignal);\n    \n    let receivedRequest: any;\n    peer.onRequest(async (req) => {\n      receivedRequest = req;\n      return { result: 'handled' };\n    });\n    \n    stdout.emit('data', JSON.stringify({\n      jsonrpc: '2.0',\n      method: 'serverRequest',\n      params: { test: true },\n      id: 'server-1',\n    }) + '\\n');\n    \n    await waitFor(() => receivedRequest !== undefined);\n    \n    expect(receivedRequest.method).toBe('serverRequest');\n    expect(stdin.write).toHaveBeenCalledWith(\n      expect.stringContaining('\"id\":\"server-1\"')\n    );\n  });\n});\n```\n\n**File**: `tests/unit/agents/codex/normalizer/normalizer.test.ts`\n```typescript\ndescribe('Codex Output Normalizer', () => {\n  it('should normalize AgentMessageDelta events', async () => {\n    const events = [\n      { method: 'codex/event/agent_message_delta', params: { msg: { delta: 'Hello ' } } },\n      { method: 'codex/event/agent_message_delta', params: { msg: { delta: 'world!' } } },\n    ];\n    \n    const entries = [];\n    for await (const entry of normalizeCodexOutput(createEventStream(events), '/tmp')) {\n      entries.push(entry);\n    }\n    \n    expect(entries).toHaveLength(2);\n    expect(entries[0].type.kind).toBe('assistant_message');\n    expect(entries[0].content).toBe('Hello ');\n    expect(entries[1].content).toBe('Hello world!');\n  });\n  \n  it('should normalize ExecCommand events', async () => {\n    const events = [\n      { \n        method: 'codex/event/exec_command_begin',\n        params: { msg: { callId: 'cmd-1', command: ['ls', '-la'] } }\n      },\n      { \n        method: 'codex/event/exec_command_end',\n        params: { msg: { callId: 'cmd-1', exitCode: 0, formattedOutput: '...' } }\n      },\n    ];\n    \n    const entries = [];\n    for await (const entry of normalizeCodexOutput(createEventStream(events), '/tmp')) {\n      entries.push(entry);\n    }\n    \n    expect(entries).toHaveLength(2);\n    expect(entries[0].type.kind).toBe('tool_use');\n    expect(entries[0].type.tool.toolName).toBe('bash');\n    expect(entries[0].type.tool.status).toBe('created');\n    expect(entries[1].type.tool.status).toBe('success');\n  });\n});\n```\n\n### Integration Tests\n\n**File**: `tests/integration/agents/codex/executor.test.ts`\n```typescript\ndescribe('CodexExecutor Integration', () => {\n  it('should execute a simple task', async () => {\n    const executor = new CodexExecutor({ model: 'gpt-4o' });\n    \n    const spawned = await executor.executeTask({\n      id: 'test-1',\n      type: 'custom',\n      prompt: 'List files in current directory',\n      workDir: '/tmp',\n      config: {},\n    });\n    \n    expect(spawned.process.pid).toBeDefined();\n    \n    // Collect output\n    const entries: NormalizedEntry[] = [];\n    const outputStream = createOutputChunks(spawned.process);\n    \n    for await (const entry of executor.normalizeOutput(outputStream, '/tmp')) {\n      entries.push(entry);\n      \n      // Stop after task complete\n      if (entry.type.kind === 'tool_use' && \n          entry.type.tool.toolName === 'bash' &&\n          entry.type.tool.status === 'success') {\n        break;\n      }\n    }\n    \n    expect(entries.length).toBeGreaterThan(0);\n    expect(entries.some(e => e.type.kind === 'assistant_message')).toBe(true);\n    expect(entries.some(e => e.type.kind === 'tool_use')).toBe(true);\n  }, 60000); // 60s timeout\n});\n```\n\n---\n\n## Documentation Requirements\n\n### JSDoc Standards\n\n```typescript\n/**\n * Codex CLI executor using app-server mode with JSONRPC 2.0 protocol.\n * \n * Supports interactive approvals, session resumption, and comprehensive\n * output normalization including tool calls, reasoning, and errors.\n * \n * @example\n * ```typescript\n * const executor = new CodexExecutor({\n *   model: 'gpt-4o',\n *   sandbox: 'workspace-write',\n *   askForApproval: 'on-request',\n * });\n * \n * const spawned = await executor.executeTask({\n *   id: 'task-1',\n *   prompt: 'Add login feature',\n *   workDir: '/path/to/project',\n * });\n * \n * // Process normalized output\n * for await (const entry of executor.normalizeOutput(outputStream, workDir)) {\n *   console.log(entry.type.kind, entry.content);\n * }\n * ```\n */\nexport class CodexExecutor extends BaseAgentExecutor { ... }\n```\n\n---\n\n## Non-Functional Requirements\n\n### NFR1: Performance\n- JSONRPC request/response handling should be < 100ms\n- Output normalization should support streaming (no buffering)\n- Session forking should be < 500ms\n\n### NFR2: Reliability\n- Handle broken pipe errors gracefully (process exit)\n- Retry JSONRPC requests on timeout (up to 3 attempts)\n- Validate all JSONRPC messages before processing\n\n### NFR3: Compatibility\n- Support Codex CLI versions >= 0.58.0\n- Support Node.js >= 18.0.0\n- Work with existing `IApprovalService` implementations\n\n---\n\n## Dependencies\n\n### Internal\n- `src/agents/base/base-executor.ts` - BaseAgentExecutor\n- `src/agents/types/normalized-output.ts` - NormalizedEntry types\n- `src/agents/types/approval-service.ts` - IApprovalService\n- `src/process/types.ts` - ManagedProcess\n\n### External\n- `@openai/codex` - Type definitions (peer dependency)\n- None (spawn npx directly, no runtime deps)\n\n---\n\n## Deliverables\n\nSprint complete when:\n- ✅ `CodexExecutor` implemented and tested\n- ✅ `JsonRpcPeer` handles bidirectional JSONRPC 2.0\n- ✅ `AppServerClient` implements all Codex app-server methods\n- ✅ Output normalization supports all Codex events\n- ✅ Session resumption working via rollout files\n- ✅ Integration tests pass with real Codex CLI\n- ✅ JSDoc on all public APIs\n- ✅ 100% test coverage on new code\n- ✅ No TypeScript errors in strict mode\n\n---\n\n## Timeline\n\n**Week 1**:\n- Day 1-2: Implement JsonRpcPeer and types\n- Day 3-4: Implement AppServerClient\n- Day 5: Implement SessionHandler\n\n**Week 2**:\n- Day 1-2: Implement CodexExecutor and integration\n- Day 3-4: Implement output normalization\n- Day 5: Testing and bug fixes\n\n**Week 3**:\n- Day 1-2: Integration tests with real Codex CLI\n- Day 3-4: Documentation and examples\n- Day 5: Code review and refinements\n\n---\n\n## References\n\n- **vibe-kanban** - Reference implementation:\n  - `executors/src/executors/codex.rs` - Main executor (375 lines)\n  - `executors/src/executors/codex/jsonrpc.rs` - JsonRpcPeer (223 lines)\n  - `executors/src/executors/codex/client.rs` - AppServerClient (487 lines)\n  - `executors/src/executors/codex/normalize_logs.rs` - Normalization (1167 lines)\n  - `executors/src/executors/codex/session.rs` - Session management\n- **Codex CLI** - Official documentation:\n  - [Codex GitHub](https://github.com/openai/codex)\n  - [Codex app-server protocol](https://github.com/openai/codex/blob/main/docs/app-server.md)\n- **JSONRPC 2.0 Specification**: https://www.jsonrpc.org/specification","priority":1,"archived":0,"archived_at":null,"created_at":"2025-11-20 10:43:37","updated_at":"2025-11-20 10:43:37","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["codex","executor","implementation","jsonrpc","sprint-2"]}
{"id":"s-1qyw","uuid":"33c0ac92-8937-426d-a14a-877ed5c79048","title":"Cursor Executor - Simple JSONL Stream Protocol Implementation","file_path":"specs/cursor_executor_simple_jsonl_stream_protocol_imple.md","content":"# Cursor Executor - Simple JSONL Stream Protocol Implementation\n\n## Overview\n\nImplement a Cursor CLI executor that uses the `cursor-agent` command with `--output-format=stream-json` for JSONL (JSON Lines) output. This is the **simplest protocol** among all agents - it's unidirectional (no bidirectional communication), uses `--force` for auto-approval, and supports session resumption via `--resume`.\n\n**Reference Implementation**: vibe-kanban's Cursor executor (Rust)\n\n- `executors/src/executors/cursor.rs` - Main executor (1265 lines, includes comprehensive type definitions)\n\n**Key Characteristics**:\n\n- ✅ **Simplest protocol**: Line-delimited JSON on stdout\n- ✅ **No bidirectional communication**: stdin closes after sending prompt\n- ✅ **Auto-approval**: `--force` flag bypasses interactive approvals\n- ✅ **Session resumption**: `--resume <session_id>` flag\n- ✅ **Rich tool set**: 11 built-in tools (shell, read, write, edit, delete, grep, glob, ls, semsearch, todo, mcp)\n\n## Goals\n\n1. ✅ Implement `CursorExecutor` extending `BaseAgentExecutor`\n1. ✅ Parse JSONL output stream (6 message types)\n1. ✅ Support 11 different tool call types\n1. ✅ Handle edit tool with 3 edit strategies (applyPatch, strReplace, multiStrReplace)\n1. ✅ Normalize Cursor JSONL to unified `NormalizedEntry` format\n1. ✅ Support session resumption via `--resume` flag\n1. ✅ Detect authentication errors and prompt setup\n\n## Success Criteria\n\n- Spawns cursor-agent process successfully\n- Parses all 6 Cursor message types (system, user, assistant, thinking, tool\\_call, result)\n- Handles all 11 tool types + generic fallback\n- Normalizes streaming assistant messages correctly\n- Extracts and reports session IDs\n- Supports session resumption with `--resume`\n- Detects \"Authentication required\" errors\n- All tests pass (unit + integration)\n- JSDoc documentation on all public APIs\n\n---\n\n## Architecture\n\n### Component Diagram\n\n```\n┌─────────────────────────────────────────────────────────┐\n│            CursorExecutor (IAgentExecutor)              │\n│                                                         │\n│  + executeTask()     - Spawn new session               │\n│  + resumeTask()      - Resume with --resume flag       │\n│  + normalizeOutput() - Parse JSONL to NormalizedEntry  │\n└──────────────────┬──────────────────────────────────────┘\n                   │\n                   │ uses\n                   ▼\n┌─────────────────────────────────────────────────────────┐\n│         JsonlStreamParser (JSONL Line Parser)           │\n│                                                         │\n│  + parseLine(line) - Parse JSON line to CursorMessage  │\n└──────────────────┬──────────────────────────────────────┘\n                   │\n                   │ produces\n                   ▼\n┌─────────────────────────────────────────────────────────┐\n│              CursorMessage (Discriminated Union)        │\n│                                                         │\n│  • System     - Session init, model info               │\n│  • User       - User message                           │\n│  • Assistant  - Assistant response (streaming)         │\n│  • Thinking   - Extended thinking (streaming)          │\n│  • ToolCall   - Tool execution (started/completed)     │\n│  • Result     - Task completion metadata               │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Protocol Flow\n\n**1\\. New Session Flow**:\n\n```\nCursorExecutor.executeTask()\n  ↓\nSpawn: cursor-agent -p --output-format=stream-json [--force] [--model MODEL]\n  ↓\nWrite prompt to stdin\n  ↓\nClose stdin (no further input)\n  ↓\nRead stdout line-by-line:\n  ← {\"type\":\"system\",\"subtype\":\"init\",\"session_id\":\"...\",\"model\":\"...\"}\n  ← {\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"...\"}]}}\n  ← {\"type\":\"tool_call\",\"subtype\":\"started\",\"call_id\":\"...\",\"tool_call\":{...}}\n  ← {\"type\":\"tool_call\",\"subtype\":\"completed\",\"call_id\":\"...\",\"tool_call\":{...}}\n  ← {\"type\":\"result\",\"subtype\":\"success\",\"duration_ms\":...}\n```\n\n**2\\. Resume Session Flow**:\n\n```\nCursorExecutor.resumeTask(sessionId)\n  ↓\nSpawn: cursor-agent -p --output-format=stream-json --resume SESSION_ID [--force]\n  ↓\nWrite new prompt to stdin\n  ↓\nClose stdin\n  ↓\n(Same JSONL output as new session)\n```\n\n**3\\. Auto-Approval with --force**:\n\n- No approval requests sent to server\n- All tool calls execute immediately\n- Cursor handles permissions internally\n\n---\n\n## Requirements\n\n### R1: CursorExecutor Class\n\n**Priority**: P0 (Critical)\n\nImplement the main executor class extending `BaseAgentExecutor`.\n\n**Interface**:\n\n```typescript\nexport interface CursorConfig {\n  force?: boolean;           // Auto-approve all tools (default: false)\n  model?: string;            // Model: 'auto', 'sonnet-4.5', 'sonnet-4.5-thinking', 'gpt-5', 'opus-4.1', 'grok'\n  appendPrompt?: string;     // Additional prompt suffix\n}\n\nexport class CursorExecutor extends BaseAgentExecutor {\n  constructor(private config: CursorConfig);\n  \n  async executeTask(task: ExecutionTask): Promise<SpawnedChild>;\n  async resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>;\n  async *normalizeOutput(\n    stream: AsyncIterable<OutputChunk>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry>;\n  getCapabilities(): AgentCapabilities;\n  async checkAvailability(): Promise<boolean>;\n}\n```\n\n**Implementation Details**:\n\n**Spawn Process**:\n\n```typescript\nasync executeTask(task: ExecutionTask): Promise<SpawnedChild> {\n  // Ensure MCP servers are trusted (if present)\n  await this.ensureMcpServerTrust(task.workDir);\n  \n  // Build command: cursor-agent -p --output-format=stream-json [--force] [--model MODEL]\n  const args = ['-p', '--output-format=stream-json'];\n  \n  if (this.config.force) {\n    args.push('--force');\n  }\n  \n  if (this.config.model) {\n    args.push('--model', this.config.model);\n  }\n  \n  // Spawn process\n  const child = spawn('cursor-agent', args, {\n    cwd: task.workDir,\n    stdio: ['pipe', 'pipe', 'pipe'],\n  });\n  \n  // Send prompt and close stdin\n  const prompt = this.appendPrompt(task.prompt);\n  child.stdin!.write(prompt);\n  child.stdin!.end();\n  \n  return {\n    process: this.wrapChildProcess(child),\n  };\n}\n```\n\n**Resume Session**:\n\n```typescript\nasync resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild> {\n  await this.ensureMcpServerTrust(task.workDir);\n  \n  // Add --resume flag\n  const args = ['-p', '--output-format=stream-json', '--resume', sessionId];\n  \n  if (this.config.force) {\n    args.push('--force');\n  }\n  \n  if (this.config.model) {\n    args.push('--model', this.config.model);\n  }\n  \n  const child = spawn('cursor-agent', args, {\n    cwd: task.workDir,\n    stdio: ['pipe', 'pipe', 'pipe'],\n  });\n  \n  const prompt = this.appendPrompt(task.prompt);\n  child.stdin!.write(prompt);\n  child.stdin!.end();\n  \n  return {\n    process: this.wrapChildProcess(child),\n  };\n}\n```\n\n**Capabilities**:\n\n```typescript\ngetCapabilities(): AgentCapabilities {\n  return {\n    supportsSessionResume: true,\n    requiresSetup: true,  // Requires 'cursor-agent login' or CURSOR_API_KEY\n    supportsApprovals: false,  // Uses --force, no interactive approvals\n    supportsMcp: true,\n    protocol: 'jsonl',\n  };\n}\n```\n\n**Availability Check**:\n\n```typescript\nasync checkAvailability(): Promise<boolean> {\n  try {\n    // Check if cursor-agent exists in PATH\n    const result = await exec('which cursor-agent');\n    return result.stdout.trim().length > 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n---\n\n### R2: Cursor Message Types\n\n**Priority**: P0 (Critical)\n\nDefine TypeScript types for all Cursor JSONL messages.\n\n**Base Types**:\n\n```typescript\n// Discriminated union of all message types\nexport type CursorMessage =\n  | CursorSystemMessage\n  | CursorUserMessage\n  | CursorAssistantMessage\n  | CursorThinkingMessage\n  | CursorToolCallMessage\n  | CursorResultMessage;\n\n// Helper to extract session ID from any message\nexport function extractSessionId(message: CursorMessage): string | undefined {\n  return message.session_id;\n}\n```\n\n**1\\. System Message**:\n\n```typescript\ninterface CursorSystemMessage {\n  type: 'system';\n  subtype?: string;  // 'init', etc.\n  api_key_source?: string;\n  cwd?: string;\n  session_id?: string;\n  model?: string;\n  permission_mode?: string;\n}\n```\n\n**2\\. User Message**:\n\n```typescript\ninterface CursorUserMessage {\n  type: 'user';\n  message: CursorMessageContent;\n  session_id?: string;\n}\n\ninterface CursorMessageContent {\n  role: string;  // 'user' | 'assistant'\n  content: CursorContentItem[];\n}\n\ninterface CursorContentItem {\n  type: 'text';\n  text: string;\n}\n```\n\n**3\\. Assistant Message** (streaming):\n\n```typescript\ninterface CursorAssistantMessage {\n  type: 'assistant';\n  message: CursorMessageContent;\n  session_id?: string;\n}\n\n// Helper to concatenate text chunks\nfunction concatText(message: CursorMessageContent): string {\n  return message.content\n    .filter(item => item.type === 'text')\n    .map(item => item.text)\n    .join('');\n}\n```\n\n**4\\. Thinking Message** (extended thinking):\n\n```typescript\ninterface CursorThinkingMessage {\n  type: 'thinking';\n  subtype?: string;\n  text?: string;\n  session_id?: string;\n}\n```\n\n**5\\. Tool Call Message**:\n\n```typescript\ninterface CursorToolCallMessage {\n  type: 'tool_call';\n  subtype?: 'started' | 'completed';  // Lifecycle\n  call_id?: string;\n  tool_call: CursorToolCall;\n  session_id?: string;\n}\n```\n\n**6\\. Result Message**:\n\n```typescript\ninterface CursorResultMessage {\n  type: 'result';\n  subtype?: string;  // 'success', 'error'\n  is_error?: boolean;\n  duration_ms?: number;\n  result?: unknown;\n}\n```\n\n---\n\n### R3: Cursor Tool Call Types\n\n**Priority**: P0 (Critical)\n\nDefine types for all 11 Cursor tools plus generic fallback.\n\n**Tool Call Union**:\n\n```typescript\nexport type CursorToolCall =\n  | CursorShellTool\n  | CursorReadTool\n  | CursorWriteTool\n  | CursorEditTool\n  | CursorDeleteTool\n  | CursorLsTool\n  | CursorGlobTool\n  | CursorGrepTool\n  | CursorSemSearchTool\n  | CursorTodoTool\n  | CursorMcpTool\n  | CursorUnknownTool;  // Fallback for future tools\n```\n\n**1\\. Shell Tool** (bash commands):\n\n```typescript\ninterface CursorShellTool {\n  shellToolCall: {\n    args: {\n      command: string;\n      working_directory?: string;\n      timeout?: number;\n    };\n    result?: {\n      success?: { stdout?: string; stderr?: string; exitCode?: number };\n      failure?: { stdout?: string; stderr?: string; exitCode?: number };\n    };\n  };\n}\n```\n\n**2\\. Read Tool**:\n\n```typescript\ninterface CursorReadTool {\n  readToolCall: {\n    args: {\n      path: string;\n      offset?: number;\n      limit?: number;\n    };\n    result?: unknown;\n  };\n}\n```\n\n**3\\. Write Tool**:\n\n```typescript\ninterface CursorWriteTool {\n  writeToolCall: {\n    args: {\n      path: string;\n      contents?: string;  // or: file_text, content\n    };\n    result?: unknown;\n  };\n}\n```\n\n**4\\. Edit Tool** (most complex - 3 edit strategies):\n\n```typescript\ninterface CursorEditTool {\n  editToolCall: {\n    args: {\n      path: string;\n      applyPatch?: {\n        patchContent: string;  // Unified diff patch\n      };\n      strReplace?: {\n        oldText: string;\n        newText: string;\n        replaceAll?: boolean;\n      };\n      multiStrReplace?: {\n        edits: Array<{\n          oldText: string;\n          newText: string;\n          replaceAll?: boolean;\n        }>;\n      };\n    };\n    result?: {\n      success?: {\n        path: string;\n        resultForModel?: string;\n        linesAdded?: number;\n        linesRemoved?: number;\n        diffString?: string;  // Unified diff of changes\n        afterFullFileContent?: string;\n      };\n    };\n  };\n}\n```\n\n**5\\. Delete Tool**:\n\n```typescript\ninterface CursorDeleteTool {\n  deleteToolCall: {\n    args: {\n      path: string;\n    };\n    result?: unknown;\n  };\n}\n```\n\n**6\\. Grep Tool**:\n\n```typescript\ninterface CursorGrepTool {\n  grepToolCall: {\n    args: {\n      pattern: string;\n      path?: string;\n      glob_filter?: string;\n      output_mode?: string;\n      case_insensitive?: boolean;\n      multiline?: boolean;\n      head_limit?: number;\n      type?: string;\n    };\n    result?: unknown;\n  };\n}\n```\n\n**7\\. Glob Tool**:\n\n```typescript\ninterface CursorGlobTool {\n  globToolCall: {\n    args: {\n      glob_pattern?: string;\n      path?: string;  // or: target_directory\n    };\n    result?: unknown;\n  };\n}\n```\n\n**8\\. Ls Tool**:\n\n```typescript\ninterface CursorLsTool {\n  lsToolCall: {\n    args: {\n      path: string;\n      ignore?: string[];\n    };\n    result?: unknown;\n  };\n}\n```\n\n**9\\. SemSearch Tool** (semantic search):\n\n```typescript\ninterface CursorSemSearchTool {\n  semSearchToolCall: {\n    args: {\n      query: string;\n      target_directories?: string[];\n      explanation?: string;\n    };\n    result?: unknown;\n  };\n}\n```\n\n**10\\. Todo Tool**:\n\n```typescript\ninterface CursorTodoTool {\n  updateTodosToolCall: {\n    args: {\n      todos?: Array<{\n        id?: string;\n        content: string;\n        status: string;  // 'pending' | 'in_progress' | 'completed'\n        created_at?: string;\n        updated_at?: string;\n        dependencies?: string[];\n      }>;\n    };\n    result?: unknown;\n  };\n}\n```\n\n**11\\. MCP Tool**:\n\n```typescript\ninterface CursorMcpTool {\n  mcpToolCall: {\n    args: {\n      name: string;\n      args: unknown;\n      provider_identifier?: string;\n      tool_name?: string;\n    };\n    result?: {\n      success?: {\n        content?: Array<{\n          text?: { text: string };\n        }>;\n        isError?: boolean;\n      };\n      failure?: {\n        content?: Array<{\n          text?: { text: string };\n        }>;\n        isError?: boolean;\n      };\n    };\n  };\n}\n```\n\n**12\\. Unknown Tool** (future compatibility):\n\n```typescript\ninterface CursorUnknownTool {\n  [toolName: string]: {\n    args: Record<string, unknown>;\n    result?: unknown;\n  };\n}\n```\n\n**Tool Name Extraction**:\n\n```typescript\nfunction getToolName(toolCall: CursorToolCall): string {\n  if ('shellToolCall' in toolCall) return 'shell';\n  if ('readToolCall' in toolCall) return 'read';\n  if ('writeToolCall' in toolCall) return 'write';\n  if ('editToolCall' in toolCall) return 'edit';\n  if ('deleteToolCall' in toolCall) return 'delete';\n  if ('lsToolCall' in toolCall) return 'ls';\n  if ('globToolCall' in toolCall) return 'glob';\n  if ('grepToolCall' in toolCall) return 'grep';\n  if ('semSearchToolCall' in toolCall) return 'semsearch';\n  if ('updateTodosToolCall' in toolCall) return 'todo';\n  if ('mcpToolCall' in toolCall) return 'mcp';\n  // Unknown: extract first key\n  return Object.keys(toolCall)[0];\n}\n```\n\n---\n\n### R4: Output Normalization\n\n**Priority**: P0 (Critical)\n\nParse Cursor JSONL stream and convert to `NormalizedEntry` format.\n\n**Normalization State**:\n\n```typescript\nclass CursorNormalizationState {\n  private entryIndex = 0;\n  private assistantMessage?: { index: number; content: string };\n  private thinkingMessage?: { index: number; content: string };\n  private toolCalls = new Map<string, { index: number; entry: NormalizedEntry }>();\n  \n  private modelReported = false;\n  private sessionIdReported = false;\n  \n  nextIndex(): number {\n    return this.entryIndex++;\n  }\n  \n  // Handle streaming assistant messages\n  handleAssistantMessage(message: CursorAssistantMessage): NormalizedEntry {\n    const chunk = concatText(message.message);\n    \n    if (!this.assistantMessage) {\n      // New message\n      this.assistantMessage = { index: this.nextIndex(), content: chunk };\n    } else {\n      // Append to existing message\n      this.assistantMessage.content += chunk;\n    }\n    \n    return {\n      index: this.assistantMessage.index,\n      type: { kind: 'assistant_message' },\n      content: this.assistantMessage.content,\n      timestamp: new Date(),\n    };\n  }\n  \n  // Handle streaming thinking\n  handleThinking(message: CursorThinkingMessage): NormalizedEntry | null {\n    if (!message.text) return null;\n    \n    if (!this.thinkingMessage) {\n      this.thinkingMessage = { index: this.nextIndex(), content: message.text };\n    } else {\n      this.thinkingMessage.content += message.text;\n    }\n    \n    return {\n      index: this.thinkingMessage.index,\n      type: { kind: 'thinking' },\n      content: this.thinkingMessage.content,\n      timestamp: new Date(),\n    };\n  }\n  \n  // Handle tool call started\n  handleToolCallStarted(\n    message: CursorToolCallMessage,\n    workDir: string\n  ): NormalizedEntry | null {\n    if (!message.call_id) return null;\n    \n    const toolName = getToolName(message.tool_call);\n    const { actionType, content } = this.mapToolToAction(message.tool_call, workDir);\n    \n    const index = this.nextIndex();\n    const entry: NormalizedEntry = {\n      index,\n      type: {\n        kind: 'tool_use',\n        tool: {\n          toolName,\n          action: actionType,\n          status: 'created',\n        },\n      },\n      content,\n      timestamp: new Date(),\n    };\n    \n    this.toolCalls.set(message.call_id, { index, entry });\n    return entry;\n  }\n  \n  // Handle tool call completed\n  handleToolCallCompleted(\n    message: CursorToolCallMessage,\n    workDir: string\n  ): NormalizedEntry | null {\n    if (!message.call_id) return null;\n    \n    const existing = this.toolCalls.get(message.call_id);\n    if (!existing) return null;\n    \n    // Update entry with result\n    const { actionType, content } = this.mapToolToActionWithResult(\n      message.tool_call,\n      workDir\n    );\n    \n    return {\n      index: existing.index,\n      type: {\n        kind: 'tool_use',\n        tool: {\n          toolName: getToolName(message.tool_call),\n          action: actionType,\n          status: 'success',\n        },\n      },\n      content,\n      timestamp: new Date(),\n    };\n  }\n}\n```\n\n**Tool to Action Mapping**:\n\n```typescript\nfunction mapToolToAction(\n  toolCall: CursorToolCall,\n  workDir: string\n): { actionType: ActionType; content: string } {\n  if ('shellToolCall' in toolCall) {\n    return {\n      actionType: {\n        kind: 'command_run',\n        command: toolCall.shellToolCall.args.command,\n        result: null,\n      },\n      content: `\\`${toolCall.shellToolCall.args.command}\\``,\n    };\n  }\n  \n  if ('readToolCall' in toolCall) {\n    const path = makePathRelative(toolCall.readToolCall.args.path, workDir);\n    return {\n      actionType: { kind: 'file_read', path },\n      content: `\\`${path}\\``,\n    };\n  }\n  \n  if ('writeToolCall' in toolCall) {\n    const path = makePathRelative(toolCall.writeToolCall.args.path, workDir);\n    return {\n      actionType: { kind: 'file_edit', path, changes: [] },\n      content: `\\`${path}\\``,\n    };\n  }\n  \n  if ('editToolCall' in toolCall) {\n    const path = makePathRelative(toolCall.editToolCall.args.path, workDir);\n    const changes = extractEditChanges(toolCall.editToolCall.args);\n    return {\n      actionType: { kind: 'file_edit', path, changes },\n      content: `\\`${path}\\``,\n    };\n  }\n  \n  if ('deleteToolCall' in toolCall) {\n    const path = makePathRelative(toolCall.deleteToolCall.args.path, workDir);\n    return {\n      actionType: { kind: 'file_edit', path, changes: [{ type: 'delete' }] },\n      content: `\\`${path}\\``,\n    };\n  }\n  \n  if ('grepToolCall' in toolCall) {\n    return {\n      actionType: { kind: 'search', query: toolCall.grepToolCall.args.pattern },\n      content: `\\`${toolCall.grepToolCall.args.pattern}\\``,\n    };\n  }\n  \n  if ('semSearchToolCall' in toolCall) {\n    return {\n      actionType: { kind: 'search', query: toolCall.semSearchToolCall.args.query },\n      content: `\\`${toolCall.semSearchToolCall.args.query}\\``,\n    };\n  }\n  \n  if ('updateTodosToolCall' in toolCall) {\n    const todos = toolCall.updateTodosToolCall.args.todos?.map(t => ({\n      content: t.content,\n      status: t.status,\n      priority: null,\n    })) || [];\n    return {\n      actionType: { kind: 'todo_management', todos, operation: 'write' },\n      content: 'TODO list updated',\n    };\n  }\n  \n  if ('mcpToolCall' in toolCall) {\n    const provider = toolCall.mcpToolCall.args.provider_identifier || 'mcp';\n    const toolName = toolCall.mcpToolCall.args.tool_name || toolCall.mcpToolCall.args.name;\n    return {\n      actionType: {\n        kind: 'tool',\n        toolName: `mcp:${provider}:${toolName}`,\n        arguments: toolCall.mcpToolCall.args.args,\n        result: null,\n      },\n      content: toolName,\n    };\n  }\n  \n  // Default for unknown tools\n  return {\n    actionType: { kind: 'other', description: `Tool: ${getToolName(toolCall)}` },\n    content: getToolName(toolCall),\n  };\n}\n```\n\n**Extract Edit Changes** (from 3 strategies):\n\n```typescript\nfunction extractEditChanges(args: CursorEditTool['editToolCall']['args']): FileChange[] {\n  const changes: FileChange[] = [];\n  \n  // Strategy 1: applyPatch (unified diff)\n  if (args.applyPatch) {\n    const hunks = extractUnifiedDiffHunks(args.applyPatch.patchContent);\n    changes.push({\n      type: 'edit',\n      unifiedDiff: concatenateDiffHunks(args.path, hunks),\n    });\n  }\n  \n  // Strategy 2: strReplace (simple find/replace)\n  if (args.strReplace) {\n    changes.push({\n      type: 'edit',\n      unifiedDiff: createUnifiedDiff(\n        args.path,\n        args.strReplace.oldText,\n        args.strReplace.newText\n      ),\n    });\n  }\n  \n  // Strategy 3: multiStrReplace (multiple find/replaces)\n  if (args.multiStrReplace) {\n    const hunks = args.multiStrReplace.edits.map(edit =>\n      createUnifiedDiffHunk(edit.oldText, edit.newText)\n    );\n    changes.push({\n      type: 'edit',\n      unifiedDiff: concatenateDiffHunks(args.path, hunks),\n    });\n  }\n  \n  return changes;\n}\n```\n\n**Normalize Output** (main entry point):\n\n```typescript\nasync *normalizeOutput(\n  stream: AsyncIterable<OutputChunk>,\n  workDir: string\n): AsyncIterable<NormalizedEntry> {\n  const state = new CursorNormalizationState();\n  \n  for await (const chunk of stream) {\n    if (chunk.type === 'stderr') {\n      // Check for authentication errors\n      const stderr = chunk.data.toString();\n      if (stderr.includes('Authentication required')) {\n        yield {\n          index: state.nextIndex(),\n          type: {\n            kind: 'error',\n            error: { kind: 'setup_required' },\n          },\n          content: stderr.trim(),\n          timestamp: new Date(),\n        };\n      }\n      continue;\n    }\n    \n    const lines = chunk.data.toString().split('\\n');\n    \n    for (const line of lines) {\n      if (!line.trim()) continue;\n      \n      let message: CursorMessage;\n      try {\n        message = JSON.parse(line);\n      } catch {\n        // Non-JSON line, treat as system message\n        yield {\n          index: state.nextIndex(),\n          type: { kind: 'system_message' },\n          content: line,\n          timestamp: new Date(),\n        };\n        continue;\n      }\n      \n      // Extract session ID if present\n      const sessionId = extractSessionId(message);\n      if (sessionId && !state.sessionIdReported) {\n        // Emit session ID via separate channel (not as NormalizedEntry)\n        state.sessionIdReported = true;\n      }\n      \n      // Handle each message type\n      switch (message.type) {\n        case 'system':\n          if (message.model && !state.modelReported) {\n            yield {\n              index: state.nextIndex(),\n              type: { kind: 'system_message' },\n              content: `System initialized with model: ${message.model}`,\n              timestamp: new Date(),\n            };\n            state.modelReported = true;\n          }\n          break;\n        \n        case 'assistant':\n          yield state.handleAssistantMessage(message);\n          break;\n        \n        case 'thinking':\n          const thinkingEntry = state.handleThinking(message);\n          if (thinkingEntry) yield thinkingEntry;\n          break;\n        \n        case 'tool_call':\n          if (message.subtype === 'started') {\n            const entry = state.handleToolCallStarted(message, workDir);\n            if (entry) yield entry;\n          } else if (message.subtype === 'completed') {\n            const entry = state.handleToolCallCompleted(message, workDir);\n            if (entry) yield entry;\n          }\n          break;\n        \n        case 'result':\n          // Metadata only, don't emit\n          break;\n      }\n    }\n  }\n}\n```\n\n---\n\n### R5: MCP Server Trust\n\n**Priority**: P2 (Medium)\n\nEnsure MCP servers listed in `~/.cursor/mcp.json` are trusted before execution.\n\n**MCP Config Location**:\n\n```typescript\nfunction getDefaultMcpConfigPath(): string {\n  return path.join(os.homedir(), '.cursor', 'mcp.json');\n}\n```\n\n**Trust Check**:\n\n```typescript\nasync function ensureMcpServerTrust(workDir: string): Promise<void> {\n  const mcpConfigPath = this.getDefaultMcpConfigPath();\n  \n  if (!fs.existsSync(mcpConfigPath)) {\n    // No MCP config, nothing to trust\n    return;\n  }\n  \n  try {\n    const config = JSON.parse(fs.readFileSync(mcpConfigPath, 'utf-8'));\n    \n    // Check if any MCP servers are configured\n    if (!config.mcpServers || Object.keys(config.mcpServers).length === 0) {\n      return;\n    }\n    \n    // For each server, ensure it's trusted\n    for (const [serverName, serverConfig] of Object.entries(config.mcpServers)) {\n      if (!serverConfig.trusted) {\n        console.warn(`MCP server '${serverName}' is not trusted. Trust it in Cursor settings.`);\n      }\n    }\n  } catch (err) {\n    console.warn('Failed to read MCP config:', err);\n  }\n}\n```\n\n---\n\n### R6: Error Handling\n\n**Priority**: P1 (High)\n\nHandle authentication errors and common failure scenarios.\n\n**Authentication Error Detection**:\n\n```typescript\nconst AUTH_ERROR_MESSAGE = 'Authentication required. Please run \\'cursor-agent login\\' first, or set CURSOR_API_KEY environment variable.';\n\nfunction detectAuthError(stderr: string): boolean {\n  return stderr.includes(AUTH_ERROR_MESSAGE);\n}\n```\n\n**Error Types**:\n\n```typescript\nexport class CursorExecutorError extends Error {\n  constructor(message: string, public code: string, public cause?: Error) {\n    super(message);\n    this.name = 'CursorExecutorError';\n  }\n  \n  static notAvailable(): CursorExecutorError {\n    return new CursorExecutorError(\n      'Cursor CLI not available. Install from: https://cursor.sh',\n      'NOT_AVAILABLE'\n    );\n  }\n  \n  static authRequired(): CursorExecutorError {\n    return new CursorExecutorError(\n      AUTH_ERROR_MESSAGE,\n      'AUTH_REQUIRED'\n    );\n  }\n  \n  static sessionNotFound(sessionId: string): CursorExecutorError {\n    return new CursorExecutorError(\n      `Session not found: ${sessionId}`,\n      'SESSION_NOT_FOUND'\n    );\n  }\n}\n```\n\n---\n\n## File Structure\n\n```\nsrc/agents/cursor/\n├── types/\n│   ├── messages.ts              # CursorMessage types (system, user, assistant, etc.)\n│   ├── tools.ts                 # CursorToolCall types (all 11 tools)\n│   ├── config.ts                # CursorConfig interface\n│   └── index.ts                 # Re-export types\n│\n├── normalizer/\n│   ├── normalizer.ts            # Output normalization logic\n│   ├── state.ts                 # CursorNormalizationState class\n│   ├── mappers.ts               # Tool → ActionType mappers\n│   └── index.ts                 # Re-export\n│\n├── mcp/\n│   ├── trust.ts                 # MCP server trust checking\n│   └── index.ts                 # Re-export\n│\n├── executor.ts                  # CursorExecutor class (main entry)\n├── errors.ts                    # CursorExecutorError\n└── index.ts                     # Public API exports\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n**File**: `tests/unit/agents/cursor/types/messages.test.ts`\n\n```typescript\ndescribe('Cursor Message Parsing', () => {\n  it('should parse system init message', () => {\n    const json = '{\"type\":\"system\",\"subtype\":\"init\",\"session_id\":\"sess-123\",\"model\":\"GPT-5\"}';\n    const message = JSON.parse(json) as CursorMessage;\n    \n    expect(message.type).toBe('system');\n    expect(extractSessionId(message)).toBe('sess-123');\n  });\n  \n  it('should parse assistant message with text chunks', () => {\n    const json = '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Hello\"}]}}';\n    const message = JSON.parse(json) as CursorAssistantMessage;\n    \n    expect(message.type).toBe('assistant');\n    expect(concatText(message.message)).toBe('Hello');\n  });\n});\n```\n\n**File**: `tests/unit/agents/cursor/types/tools.test.ts`\n\n```typescript\ndescribe('Cursor Tool Call Parsing', () => {\n  it('should parse shell tool call', () => {\n    const json = '{\"shellToolCall\":{\"args\":{\"command\":\"ls -la\"}}}';\n    const toolCall = JSON.parse(json) as CursorToolCall;\n    \n    expect(getToolName(toolCall)).toBe('shell');\n    expect('shellToolCall' in toolCall).toBe(true);\n  });\n  \n  it('should parse edit tool with applyPatch', () => {\n    const json = '{\"editToolCall\":{\"args\":{\"path\":\"file.txt\",\"applyPatch\":{\"patchContent\":\"...\"}}}}';\n    const toolCall = JSON.parse(json) as CursorToolCall;\n    \n    expect(getToolName(toolCall)).toBe('edit');\n  });\n  \n  it('should parse unknown tool to fallback', () => {\n    const json = '{\"unknownTool\":{\"args\":{\"foo\":\"bar\"}}}';\n    const toolCall = JSON.parse(json) as CursorToolCall;\n    \n    expect(getToolName(toolCall)).toBe('unknownTool');\n  });\n});\n```\n\n**File**: `tests/unit/agents/cursor/normalizer/normalizer.test.ts`\n\n```typescript\ndescribe('Cursor Output Normalizer', () => {\n  it('should coalesce streaming assistant messages', async () => {\n    const messages = [\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Hello \"}]}}',\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"world!\"}]}}',\n    ];\n    \n    const entries = [];\n    for await (const entry of normalizeOutput(createStream(messages), '/tmp')) {\n      entries.push(entry);\n    }\n    \n    expect(entries).toHaveLength(2);\n    expect(entries[0].content).toBe('Hello ');\n    expect(entries[1].content).toBe('Hello world!');\n    expect(entries[0].index).toBe(entries[1].index); // Same entry, updated\n  });\n  \n  it('should handle tool_call lifecycle', async () => {\n    const messages = [\n      '{\"type\":\"tool_call\",\"subtype\":\"started\",\"call_id\":\"cmd-1\",\"tool_call\":{\"shellToolCall\":{\"args\":{\"command\":\"ls\"}}}}',\n      '{\"type\":\"tool_call\",\"subtype\":\"completed\",\"call_id\":\"cmd-1\",\"tool_call\":{\"shellToolCall\":{\"args\":{\"command\":\"ls\"},\"result\":{\"success\":{\"stdout\":\"file1\\\\nfile2\",\"exitCode\":0}}}}}',\n    ];\n    \n    const entries = [];\n    for await (const entry of normalizeOutput(createStream(messages), '/tmp')) {\n      entries.push(entry);\n    }\n    \n    expect(entries).toHaveLength(2);\n    expect(entries[0].type.kind).toBe('tool_use');\n    expect(entries[0].type.tool.status).toBe('created');\n    expect(entries[1].type.tool.status).toBe('success');\n    expect(entries[0].index).toBe(entries[1].index); // Same entry, updated\n  });\n});\n```\n\n### Integration Tests\n\n**File**: `tests/integration/agents/cursor/executor.test.ts`\n\n```typescript\ndescribe('CursorExecutor Integration', () => {\n  it('should execute a simple task', async () => {\n    const executor = new CursorExecutor({ force: true });\n    \n    const spawned = await executor.executeTask({\n      id: 'test-1',\n      type: 'custom',\n      prompt: 'List files in current directory',\n      workDir: '/tmp',\n      config: {},\n    });\n    \n    expect(spawned.process.pid).toBeDefined();\n    \n    // Collect output\n    const entries: NormalizedEntry[] = [];\n    const outputStream = createOutputChunks(spawned.process);\n    \n    for await (const entry of executor.normalizeOutput(outputStream, '/tmp')) {\n      entries.push(entry);\n    }\n    \n    expect(entries.length).toBeGreaterThan(0);\n    expect(entries.some(e => e.type.kind === 'assistant_message')).toBe(true);\n    expect(entries.some(e => e.type.kind === 'tool_use')).toBe(true);\n  }, 60000); // 60s timeout\n  \n  it('should detect authentication errors', async () => {\n    // Mock cursor-agent that returns auth error\n    const executor = new CursorExecutor({});\n    \n    const spawned = await executor.executeTask({\n      id: 'test-2',\n      prompt: 'Test',\n      workDir: '/tmp',\n    });\n    \n    const entries: NormalizedEntry[] = [];\n    for await (const entry of executor.normalizeOutput(createOutputChunks(spawned.process), '/tmp')) {\n      entries.push(entry);\n      \n      if (entry.type.kind === 'error' && entry.type.error.kind === 'setup_required') {\n        expect(entry.content).toContain('Authentication required');\n        break;\n      }\n    }\n  });\n});\n```\n\n---\n\n## Documentation Requirements\n\n### JSDoc Standards\n\n```typescript\n/**\n * Cursor CLI executor using simple JSONL stream protocol.\n * \n * The simplest agent protocol - unidirectional output with auto-approval\n * via --force flag. Supports 11 built-in tools and MCP server integration.\n * \n * @example Basic usage\n * ```typescript\n * const executor = new CursorExecutor({\n *   force: true,        // Auto-approve all tools\n *   model: 'gpt-5',     // Use GPT-5 model\n * });\n * \n * const spawned = await executor.executeTask({\n *   id: 'task-1',\n *   prompt: 'Add login feature',\n *   workDir: '/path/to/project',\n * });\n * \n * // Process normalized output\n * for await (const entry of executor.normalizeOutput(outputStream, workDir)) {\n *   console.log(entry.type.kind, entry.content);\n * }\n * ```\n * \n * @example Session resumption\n * ```typescript\n * // Resume from previous session\n * const spawned = await executor.resumeTask({\n *   id: 'task-2',\n *   prompt: 'Continue work',\n *   workDir: '/path/to/project',\n * }, 'sess-abc123');\n * ```\n */\nexport class CursorExecutor extends BaseAgentExecutor { ... }\n```\n\n---\n\n## Non-Functional Requirements\n\n### NFR1: Performance\n\n- JSONL parsing should be < 10ms per line\n- Output normalization should support streaming (no buffering)\n- Tool call mapping should be O(1) lookup\n\n### NFR2: Simplicity\n\n- No bidirectional communication complexity\n- No approval request/response handling\n- Single-pass JSONL parsing\n\n### NFR3: Compatibility\n\n- Support Cursor CLI versions >= 0.40.0\n- Support Node.js >= 18.0.0\n- Handle future tool types via fallback\n\n---\n\n## Dependencies\n\n### Internal\n\n- `src/agents/base/base-executor.ts` - BaseAgentExecutor\n- `src/agents/types/normalized-output.ts` - NormalizedEntry types\n- `src/process/types.ts` - ManagedProcess\n\n### External\n\n- None (spawn cursor-agent directly, no runtime deps)\n\n---\n\n## Deliverables\n\nSprint complete when:\n\n- ✅ `CursorExecutor` implemented and tested\n- ✅ All 6 message types parsed correctly\n- ✅ All 11 tool types + fallback handled\n- ✅ Edit tool handles all 3 strategies (applyPatch, strReplace, multiStrReplace)\n- ✅ Output normalization supports streaming\n- ✅ Session resumption working via `--resume`\n- ✅ Authentication error detection working\n- ✅ Integration tests pass with real Cursor CLI\n- ✅ JSDoc on all public APIs\n- ✅ 100% test coverage on new code\n- ✅ No TypeScript errors in strict mode\n\n---\n\n## Timeline\n\n**Week 1**:\n\n- Day 1-2: Define all message and tool types\n- Day 3-4: Implement CursorExecutor (spawn, resume, capabilities)\n- Day 5: Implement basic JSONL parsing\n\n**Week 2**:\n\n- Day 1-3: Implement output normalization (all message types + tools)\n- Day 4: Implement edit tool change extraction (3 strategies)\n- Day 5: Testing and bug fixes\n\n**Week 3**:\n\n- Day 1-2: Integration tests with real Cursor CLI\n- Day 3-4: Documentation and examples\n- Day 5: Code review and refinements\n\n---\n\n## References\n\n- **vibe-kanban** - Reference implementation:\n  - `executors/src/executors/cursor.rs` - Complete implementation (1265 lines)\n- **Cursor CLI** - Official documentation:\n  - [Cursor CLI GitHub](https://github.com/getcursor/cursor)\n  - Install: [https://cursor.sh](https://cursor.sh)\n- **Authentication**:\n  - Run `cursor-agent login` OR set `CURSOR_API_KEY` environment variable\n\n---\n\n## Comparison to Other Agents\n\n| Feature | Cursor | Codex | Claude Code | Gemini |\n| --- | --- | --- | --- | --- |\n| Protocol | JSONL | JSONRPC 2.0 | Stream-JSON + Control | ACP |\n| Communication | Unidirectional | Bidirectional | Bidirectional | Bidirectional |\n| Approvals | \\--force (none) | Interactive | Interactive | Interactive |\n| Tool Count | 11 built-in | ~5 built-in | ~15 built-in | Variable (MCP) |\n| Complexity | ⭐ (Simplest) | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |\n| Session Resume | \\--resume flag | Rollout files | Session ID | Session ID |\n\n**Cursor is the simplest to implement** - perfect starting point for Sprint 2!","priority":1,"archived":0,"archived_at":null,"created_at":"2025-11-20 10:53:27","updated_at":"2025-11-20 20:17:31","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["cursor","executor","implementation","jsonl","sprint-2"]}
{"id":"s-iaik","uuid":"e39d0ed0-0616-41f2-abe0-a6ae834dd6a0","title":"Gemini Executor - Agent Client Protocol (ACP) Implementation","file_path":"specs/gemini_executor_agent_client_protocol_acp_implemen.md","content":"# Gemini Executor - Agent Client Protocol (ACP) Implementation\n\n## Overview\n\nThe Gemini CLI executor (`gemini-cli` / `@google/gemini-cli`) implements the **Agent Client Protocol (ACP)**, the most complex protocol among all supported agents. Unlike simpler protocols (Cursor JSONL, Codex JSONRPC), ACP requires:\n\n1. **Bidirectional duplex channels** - Complex stdio plumbing with tokio duplex streams\n2. **Agent-Client Protocol library** - Integration with `agent-client-protocol` library (Rust crate, needs TypeScript equivalent)\n3. **Session management** - Persistent session storage with forking and history replay\n4. **Rich client interface** - File system operations, terminal operations, permission requests\n5. **Complex event model** - 8+ event types with streaming updates\n\n**Complexity: ⭐⭐⭐⭐** (Most complex)\n\n## Protocol Architecture\n\n### Three-Layer Architecture\n\n```\n┌─────────────────────────────────────────────┐\n│  GeminiExecutor (IAgentExecutor)            │  - Thin wrapper, config builder\n│  - buildProcessConfig()                     │  - Inherits from BaseAgentExecutor\n│  - executeTask()                            │\n└──────────────────┬──────────────────────────┘\n                   │\n                   ↓\n┌─────────────────────────────────────────────┐\n│  AcpAgentHarness                            │  - Process spawning + ACP bootstrap\n│  - spawn_with_command()                     │  - Duplex channel plumbing\n│  - setupDuplexChannels()                    │  - Session forking support\n│  - bootstrapAcpClient()                     │\n└──────────────────┬──────────────────────────┘\n                   │\n                   ↓\n┌─────────────────────────────────────────────┐\n│  AcpClient (implements acp.Client)          │  - Protocol message handling\n│  - session_notification()                   │  - Permission auto-approval\n│  - request_permission()                     │  - Event emission to msg_store\n│  - read_text_file() [not implemented]       │\n│  - write_text_file() [not implemented]      │\n│  - create_terminal() [not implemented]      │\n└──────────────────┬──────────────────────────┘\n                   │\n                   ↓\n┌─────────────────────────────────────────────┐\n│  SessionManager                             │  - Persistent JSONL storage\n│  - append_raw_line()                        │  - Session forking\n│  - fork_session()                           │  - Resume prompt generation\n│  - read_session_raw()                       │\n└─────────────────────────────────────────────┘\n```\n\n### Protocol Flow\n\n```\n┌───────────┐                  ┌──────────────┐                 ┌────────────┐\n│  Engine   │                  │ ACP Harness  │                 │ gemini-cli │\n└─────┬─────┘                  └──────┬───────┘                 └──────┬─────┘\n      │                               │                                │\n      │ executeTask(task)             │                                │\n      ├──────────────────────────────>│                                │\n      │                               │                                │\n      │                               │ spawn(\"gemini\", [\"--experimental-acp\"])\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │<─ stdout ─────────────────────│\n      │                               │                                │\n      │                               │ setupDuplexChannels()          │\n      │                               │   stdout → acp_incoming        │\n      │                               │   acp_outgoing → stdin         │\n      │                               │                                │\n      │                               │ ClientSideConnection::new()    │\n      │                               │   .initialize(capabilities)    │\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │<─ InitializeResponse ──────────│\n      │                               │                                │\n      │                               │ session_manager.fork_session() │\n      │                               │   (if resuming)                │\n      │                               │                                │\n      │                               │ client.prompt(prompt, session_id)\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │<─ SessionUpdate::AgentMessageChunk\n      │<─ NormalizedEntry ────────────│                                │\n      │   (via onOutput handler)      │                                │\n      │                               │                                │\n      │                               │<─ SessionUpdate::ToolCall ─────│\n      │<─ NormalizedEntry ────────────│   (read, edit, execute)        │\n      │                               │                                │\n      │                               │ request_permission() ──────────>│\n      │                               │   (auto-approve)               │\n      │                               │                                │\n      │                               │<─ SessionUpdate::ToolCallUpdate │\n      │<─ NormalizedEntry ────────────│   (streaming updates)          │\n      │                               │                                │\n      │                               │<─ Done ────────────────────────│\n      │<─ TaskResult ─────────────────│                                │\n```\n\n## Requirements\n\n### R1: GeminiExecutor Implementation\n\n**Description**: Implement thin wrapper executor for Gemini CLI\n\n**Acceptance Criteria**:\n- Extends `BaseAgentExecutor`\n- Uses `AcpAgentHarness` for all spawning logic\n- Implements `buildProcessConfig()` with Gemini-specific args\n- Supports `--experimental-acp` flag\n- Integrates with profile system for configuration\n\n**Implementation**:\n\n```typescript\n// src/agents/gemini/executor.ts\nimport { BaseAgentExecutor } from '../base-executor.js';\nimport { AcpAgentHarness } from './acp/harness.js';\nimport type { ExecutionTask, SpawnedChild } from '@/engine/types.js';\nimport type { GeminiConfig } from './config.js';\n\nexport class GeminiExecutor extends BaseAgentExecutor {\n  private harness: AcpAgentHarness;\n\n  constructor(config: GeminiConfig) {\n    super(config);\n    this.harness = new AcpAgentHarness({\n      namespace: config.sessionNamespace || 'gemini-sessions',\n      autoApprove: config.autoApprove ?? true,\n    });\n  }\n\n  protected async spawnForTask(task: ExecutionTask): Promise<SpawnedChild> {\n    const geminiCommand = this.buildGeminiCommand(task);\n    const combinedPrompt = this.combinePrompt(task.prompt);\n    \n    return this.harness.spawnWithCommand(\n      task.workDir,\n      combinedPrompt,\n      geminiCommand,\n      task.sessionId // For session resumption\n    );\n  }\n\n  private buildGeminiCommand(task: ExecutionTask): ProcessCommand {\n    const config = this.config as GeminiConfig;\n    const executable = config.executablePath || 'npx';\n    const args: string[] = [];\n\n    if (executable === 'npx') {\n      args.push('-y', '@google/gemini-cli');\n    }\n\n    // REQUIRED: Enable ACP protocol\n    args.push('--experimental-acp');\n\n    // Optional args\n    if (config.model) {\n      args.push('--model', config.model);\n    }\n\n    return {\n      executable,\n      args,\n      env: {\n        ...process.env,\n        ...config.env,\n      },\n    };\n  }\n\n  private combinePrompt(userPrompt: string): string {\n    const config = this.config as GeminiConfig;\n    if (config.systemPrompt) {\n      return `${config.systemPrompt}\\n\\n${userPrompt}`;\n    }\n    return userPrompt;\n  }\n}\n\ninterface ProcessCommand {\n  executable: string;\n  args: string[];\n  env: Record<string, string>;\n}\n```\n\n---\n\n### R2: AcpAgentHarness Implementation\n\n**Description**: Implement ACP bootstrap and duplex channel plumbing\n\n**Acceptance Criteria**:\n- Spawns child process and creates duplex channels for stdio\n- Wires child stdout → ACP incoming, ACP outgoing → child stdin\n- Bootstraps `ClientSideConnection` with initialize handshake\n- Supports session forking with history replay\n- Emits exit signal when prompt completes\n\n**Implementation**:\n\n```typescript\n// src/agents/gemini/acp/harness.ts\nimport { spawn } from 'child_process';\nimport { Duplex } from 'stream';\nimport { ClientSideConnection } from './client-side-connection.js';\nimport { AcpClient } from './client.js';\nimport { SessionManager } from './session.js';\nimport type { SpawnedChild, ManagedProcess } from '@/process/types.js';\n\nexport interface AcpHarnessConfig {\n  namespace: string;\n  autoApprove?: boolean;\n}\n\nexport class AcpAgentHarness {\n  private config: AcpHarnessConfig;\n  private sessionManager: SessionManager;\n\n  constructor(config: AcpHarnessConfig) {\n    this.config = config;\n    this.sessionManager = new SessionManager(config.namespace);\n  }\n\n  async spawnWithCommand(\n    workDir: string,\n    prompt: string,\n    command: { executable: string; args: string[]; env: Record<string, string> },\n    existingSessionId?: string\n  ): Promise<SpawnedChild> {\n    // 1. Spawn process\n    const child = spawn(command.executable, command.args, {\n      cwd: workDir,\n      env: command.env,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n\n    const origStdout = child.stdout!;\n    const origStdin = child.stdin!;\n\n    // 2. Create duplex channels for ACP\n    const [acpIncomingReader, toAcpWriter] = this.createDuplex();\n    const [acpOutgoingReader, fromAcpWriter] = this.createDuplex();\n\n    // 3. Wire child stdout → ACP incoming\n    origStdout.on('data', (chunk) => {\n      toAcpWriter.write(chunk);\n    });\n    origStdout.on('end', () => {\n      toAcpWriter.end();\n    });\n\n    // 4. Wire ACP outgoing → child stdin\n    acpOutgoingReader.on('data', (chunk) => {\n      origStdin.write(chunk);\n    });\n    acpOutgoingReader.on('end', () => {\n      origStdin.end();\n    });\n\n    // 5. Create ACP client and connection\n    const eventEmitter = new EventTarget();\n    const acpClient = new AcpClient(eventEmitter, {\n      autoApprove: this.config.autoApprove ?? true,\n    });\n\n    const connection = new ClientSideConnection(\n      acpIncomingReader,\n      fromAcpWriter,\n      acpClient\n    );\n\n    // 6. Initialize ACP protocol\n    await connection.initialize({\n      name: 'vibe-kanban-execution-engine',\n      version: '1.0.0',\n      capabilities: {\n        terminal: false,\n        fileSystem: false,\n      },\n    });\n\n    // 7. Handle session forking\n    let sessionId: string;\n    if (existingSessionId) {\n      sessionId = this.generateSessionId();\n      await this.sessionManager.forkSession(existingSessionId, sessionId);\n      const history = await this.sessionManager.readSessionRaw(sessionId);\n      // Pass history in prompt metadata (ACP-specific)\n      await connection.prompt(prompt, { sessionId, history });\n    } else {\n      sessionId = this.generateSessionId();\n      await connection.prompt(prompt, { sessionId });\n    }\n\n    // 8. Listen for ACP events and emit as NormalizedEntry\n    eventEmitter.addEventListener('acp-event', (e: Event) => {\n      const acpEvent = (e as CustomEvent).detail;\n      this.sessionManager.appendRawLine(sessionId, JSON.stringify(acpEvent));\n      // Normalize and emit via onOutput handler (handled by BaseAgentExecutor)\n    });\n\n    // 9. Wait for prompt completion and emit exit signal\n    connection.onPromptComplete(() => {\n      eventEmitter.dispatchEvent(new CustomEvent('exit-signal', {\n        detail: { exitCode: 0, signal: null },\n      }));\n    });\n\n    return {\n      process: this.wrapChildProcess(child, eventEmitter),\n      sessionId,\n    };\n  }\n\n  private createDuplex(): [Duplex, Duplex] {\n    const duplex1 = new Duplex({\n      read() {},\n      write(chunk, encoding, callback) {\n        duplex2.push(chunk);\n        callback();\n      },\n    });\n\n    const duplex2 = new Duplex({\n      read() {},\n      write(chunk, encoding, callback) {\n        duplex1.push(chunk);\n        callback();\n      },\n    });\n\n    return [duplex1, duplex2];\n  }\n\n  private generateSessionId(): string {\n    return `session-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;\n  }\n\n  private wrapChildProcess(\n    child: ChildProcess,\n    eventEmitter: EventTarget\n  ): ManagedProcess {\n    return {\n      id: `gemini-${Date.now()}`,\n      status: 'running',\n      startTime: Date.now(),\n      process: child,\n      stdout: eventEmitter, // Emit via events instead of raw stream\n      stderr: child.stderr!,\n    };\n  }\n}\n```\n\n---\n\n### R3: AcpClient Protocol Handler\n\n**Description**: Implement ACP client interface with event emission and permission handling\n\n**Acceptance Criteria**:\n- Implements `acp.Client` interface from agent-client-protocol library\n- Handles `session_notification()` with 8+ event types\n- Auto-approves `request_permission()` with best available option\n- Emits structured `AcpEvent` enum for normalization\n- Stubs unimplemented methods (file system, terminal operations)\n\n**Implementation**:\n\n```typescript\n// src/agents/gemini/acp/client.ts\nimport type {\n  Client,\n  RequestPermissionRequest,\n  RequestPermissionResponse,\n  SessionNotification,\n  RequestPermissionOutcome,\n  Error as AcpError,\n} from 'agent-client-protocol';\nimport { AcpEvent } from './types.js';\n\nexport interface AcpClientConfig {\n  autoApprove: boolean;\n}\n\nexport class AcpClient implements Client {\n  private eventTarget: EventTarget;\n  private config: AcpClientConfig;\n\n  constructor(eventTarget: EventTarget, config: AcpClientConfig) {\n    this.eventTarget = eventTarget;\n    this.config = config;\n  }\n\n  recordUserPromptEvent(prompt: string): void {\n    this.sendEvent({ type: 'User', content: prompt });\n  }\n\n  async requestPermission(\n    args: RequestPermissionRequest\n  ): Promise<RequestPermissionResponse> {\n    // Forward as event\n    this.sendEvent({\n      type: 'RequestPermission',\n      request: args,\n    });\n\n    if (!this.config.autoApprove) {\n      // TODO: Integrate with approval service\n      throw new Error('Manual approval not implemented');\n    }\n\n    // Auto-approve with best available option\n    const chosenOption =\n      args.options.find((o) => o.kind === 'AllowAlways') ||\n      args.options.find((o) => o.kind === 'AllowOnce') ||\n      args.options[0];\n\n    const outcome: RequestPermissionOutcome = chosenOption\n      ? { Selected: { optionId: chosenOption.id } }\n      : 'Cancelled';\n\n    return {\n      outcome,\n      meta: undefined,\n    };\n  }\n\n  async sessionNotification(args: SessionNotification): Promise<void> {\n    // Convert SessionUpdate variants to AcpEvent\n    const event = this.mapSessionUpdate(args);\n    if (event) {\n      this.sendEvent(event);\n    }\n  }\n\n  // File system operations - not implemented\n  async writeTextFile(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'writeTextFile not supported');\n  }\n\n  async readTextFile(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'readTextFile not supported');\n  }\n\n  // Terminal operations - not implemented\n  async createTerminal(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'createTerminal not supported');\n  }\n\n  async terminalOutput(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'terminalOutput not supported');\n  }\n\n  async releaseTerminal(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'releaseTerminal not supported');\n  }\n\n  async waitForTerminalExit(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'waitForTerminalExit not supported');\n  }\n\n  async killTerminalCommand(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'killTerminalCommand not supported');\n  }\n\n  // Extension methods\n  async extMethod(args: any): Promise<any> {\n    throw new AcpError('method_not_found', 'extMethod not supported');\n  }\n\n  async extNotification(args: any): Promise<void> {\n    // Ignore extension notifications\n  }\n\n  private mapSessionUpdate(notification: SessionNotification): AcpEvent | null {\n    const update = notification.update;\n\n    if ('AgentMessageChunk' in update) {\n      return {\n        type: 'Message',\n        content: update.AgentMessageChunk.content,\n      };\n    }\n\n    if ('AgentThoughtChunk' in update) {\n      return {\n        type: 'Thought',\n        content: update.AgentThoughtChunk.content,\n      };\n    }\n\n    if ('ToolCall' in update) {\n      return {\n        type: 'ToolCall',\n        toolCall: update.ToolCall,\n      };\n    }\n\n    if ('ToolCallUpdate' in update) {\n      return {\n        type: 'ToolUpdate',\n        update: update.ToolCallUpdate,\n      };\n    }\n\n    if ('Plan' in update) {\n      return {\n        type: 'Plan',\n        plan: update.Plan,\n      };\n    }\n\n    if ('AvailableCommandsUpdate' in update) {\n      return {\n        type: 'AvailableCommands',\n        commands: update.AvailableCommandsUpdate.available_commands,\n      };\n    }\n\n    if ('CurrentModeUpdate' in update) {\n      return {\n        type: 'CurrentMode',\n        modeId: update.CurrentModeUpdate.current_mode_id,\n      };\n    }\n\n    // Catch-all for unhandled updates\n    return {\n      type: 'Other',\n      notification,\n    };\n  }\n\n  private sendEvent(event: AcpEvent): void {\n    this.eventTarget.dispatchEvent(\n      new CustomEvent('acp-event', { detail: event })\n    );\n  }\n}\n```\n\n**AcpEvent Type Definitions**:\n\n```typescript\n// src/agents/gemini/acp/types.ts\nimport type {\n  ContentBlock,\n  ToolCall,\n  ToolCallUpdate,\n  Plan,\n  AvailableCommand,\n  SessionModeId,\n  RequestPermissionRequest,\n  SessionNotification,\n} from 'agent-client-protocol';\n\nexport type AcpEvent =\n  | { type: 'User'; content: string }\n  | { type: 'SessionStart'; sessionId: string }\n  | { type: 'Message'; content: ContentBlock }\n  | { type: 'Thought'; content: ContentBlock }\n  | { type: 'ToolCall'; toolCall: ToolCall }\n  | { type: 'ToolUpdate'; update: ToolCallUpdate }\n  | { type: 'Plan'; plan: Plan }\n  | { type: 'AvailableCommands'; commands: AvailableCommand[] }\n  | { type: 'CurrentMode'; modeId: SessionModeId }\n  | { type: 'RequestPermission'; request: RequestPermissionRequest }\n  | { type: 'Error'; message: string }\n  | { type: 'Done'; sessionId: string }\n  | { type: 'Other'; notification: SessionNotification };\n```\n\n---\n\n### R4: SessionManager Implementation\n\n**Description**: Implement persistent session storage with forking and normalization\n\n**Acceptance Criteria**:\n- Stores sessions as JSONL files in namespace directory (e.g., `~/.vibe-kanban/gemini-sessions/`)\n- Supports session forking (copy existing session to new ID)\n- Normalizes ACP events before storing (removes sessionId, unwraps update envelope)\n- Generates resume prompts from session history\n- Provides session deletion\n\n**Implementation**:\n\n```typescript\n// src/agents/gemini/acp/session.ts\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { homedir } from 'os';\nimport type { AcpEvent } from './types.js';\n\nexport class SessionManager {\n  private baseDir: string;\n\n  constructor(namespace: string) {\n    const isDev = process.env.NODE_ENV === 'development';\n    const vkDir = join(homedir(), '.vibe-kanban', isDev ? 'dev' : '');\n    this.baseDir = join(vkDir, namespace);\n    this.ensureBaseDir();\n  }\n\n  private async ensureBaseDir(): Promise<void> {\n    await fs.mkdir(this.baseDir, { recursive: true });\n  }\n\n  private sessionFilePath(sessionId: string): string {\n    return join(this.baseDir, `${sessionId}.jsonl`);\n  }\n\n  /**\n   * Append normalized ACP event to session log\n   * \n   * Normalization rules:\n   * - Remove top-level `sessionId`\n   * - For User events: store as {\"user\": \"prompt text\"}\n   * - For Message/Thought with text: store as {\"assistant\": \"text\"} or {\"thinking\": \"text\"}\n   * - For ToolCall/ToolUpdate: store full event\n   * - Skip SessionStart, Error, Done, Other events\n   */\n  async appendRawLine(sessionId: string, rawJson: string): Promise<void> {\n    const normalized = this.normalizeSessionEvent(rawJson);\n    if (!normalized) return;\n\n    const path = this.sessionFilePath(sessionId);\n    await fs.appendFile(path, normalized + '\\n', 'utf-8');\n  }\n\n  private normalizeSessionEvent(rawJson: string): string | null {\n    let event: AcpEvent;\n    try {\n      event = JSON.parse(rawJson) as AcpEvent;\n    } catch {\n      return null;\n    }\n\n    // Skip these event types\n    if (\n      event.type === 'SessionStart' ||\n      event.type === 'Error' ||\n      event.type === 'Done' ||\n      event.type === 'Other'\n    ) {\n      return null;\n    }\n\n    // Special normalization for common cases\n    if (event.type === 'User') {\n      return JSON.stringify({ user: event.content });\n    }\n\n    if (event.type === 'Message' || event.type === 'Thought') {\n      const content = event.content;\n      if ('Text' in content) {\n        const key = event.type === 'Message' ? 'assistant' : 'thinking';\n        return JSON.stringify({ [key]: content.Text.text });\n      }\n    }\n\n    // Convert RequestPermission to ToolUpdate for storage\n    if (event.type === 'RequestPermission') {\n      return JSON.stringify({\n        type: 'ToolUpdate',\n        update: event.request.toolCall,\n      });\n    }\n\n    // Store full event for other types\n    return JSON.stringify(event);\n  }\n\n  async readSessionRaw(sessionId: string): Promise<string> {\n    const path = this.sessionFilePath(sessionId);\n    try {\n      return await fs.readFile(path, 'utf-8');\n    } catch {\n      return '';\n    }\n  }\n\n  async forkSession(oldId: string, newId: string): Promise<void> {\n    const oldPath = this.sessionFilePath(oldId);\n    const newPath = this.sessionFilePath(newId);\n\n    try {\n      await fs.copyFile(oldPath, newPath);\n    } catch {\n      // If old session doesn't exist, create empty new session\n      await fs.writeFile(newPath, '', 'utf-8');\n    }\n  }\n\n  async deleteSession(sessionId: string): Promise<void> {\n    const path = this.sessionFilePath(sessionId);\n    try {\n      await fs.unlink(path);\n    } catch {\n      // Ignore if file doesn't exist\n    }\n  }\n\n  async generateResumePrompt(\n    sessionId: string,\n    currentPrompt: string\n  ): Promise<string> {\n    const sessionContext = await this.readSessionRaw(sessionId);\n\n    return `RESUME CONTEXT FOR CONTINUING TASK\n\n=== EXECUTION HISTORY ===\nThe following is the conversation history from this session:\n${sessionContext}\n\n=== CURRENT REQUEST ===\n${currentPrompt}\n\n=== INSTRUCTIONS ===\nYou are continuing work on the above task. The execution history shows the previous conversation in this session. Please continue from where the previous execution left off, taking into account all the context provided above.`;\n  }\n}\n```\n\n---\n\n### R5: Output Normalization\n\n**Description**: Convert ACP events to unified `NormalizedEntry` format\n\n**Acceptance Criteria**:\n- Handles all 8+ AcpEvent types (Message, Thought, ToolCall, ToolUpdate, Plan, etc.)\n- Implements streaming coalescing for Message/Thought chunks\n- Maps ACP ToolKind to ActionType (Read, Edit, Execute, Delete, Search, Fetch, Think, etc.)\n- Extracts file changes from Edit tool diffs\n- Parses command output from Execute tool\n- Converts tool status (Pending/InProgress → Created, Completed → Success, Failed → Failed)\n\n**Implementation**:\n\n```typescript\n// src/agents/gemini/acp/normalize.ts\nimport type { AcpEvent } from './types.js';\nimport type {\n  NormalizedEntry,\n  NormalizedEntryType,\n  ActionType,\n  ToolStatus,\n  FileChange,\n} from '@/logs/types.js';\nimport type {\n  ToolCall,\n  ToolCallUpdate,\n  ToolKind,\n  ToolCallStatus,\n  ContentBlock,\n} from 'agent-client-protocol';\n\ninterface StreamingState {\n  assistantText?: { index: number; content: string };\n  thinkingText?: { index: number; content: string };\n}\n\ninterface ToolState {\n  index: number;\n  id: string;\n  kind: ToolKind;\n  title: string;\n  status: ToolCallStatus;\n  path?: string;\n  content: any[];\n  rawInput?: any;\n  rawOutput?: any;\n}\n\nexport class AcpNormalizer {\n  private streamingState: StreamingState = {};\n  private toolStates = new Map<string, ToolState>();\n  private nextIndex = 0;\n\n  normalize(event: AcpEvent, workDir: string): NormalizedEntry | null {\n    switch (event.type) {\n      case 'Error':\n        return this.normalizeError(event.message);\n\n      case 'Message':\n        return this.normalizeMessage(event.content);\n\n      case 'Thought':\n        return this.normalizeThought(event.content);\n\n      case 'ToolCall':\n        return this.normalizeToolCall(event.toolCall, workDir);\n\n      case 'ToolUpdate':\n        return this.normalizeToolUpdate(event.update, workDir);\n\n      case 'Plan':\n        return this.normalizePlan(event.plan);\n\n      case 'AvailableCommands':\n        return this.normalizeAvailableCommands(event.commands);\n\n      case 'CurrentMode':\n        return this.normalizeCurrentMode(event.modeId);\n\n      case 'Done':\n        this.streamingState = {};\n        return null;\n\n      default:\n        return null;\n    }\n  }\n\n  private normalizeError(message: string): NormalizedEntry {\n    return {\n      timestamp: Date.now(),\n      entryType: {\n        type: 'ErrorMessage',\n        errorType: 'Other',\n      },\n      content: message,\n      metadata: null,\n    };\n  }\n\n  private normalizeMessage(content: ContentBlock): NormalizedEntry | null {\n    this.streamingState.thinkingText = undefined;\n\n    if ('Text' in content) {\n      const isNew = !this.streamingState.assistantText;\n      if (isNew) {\n        this.streamingState.assistantText = {\n          index: this.nextIndex++,\n          content: '',\n        };\n      }\n\n      const state = this.streamingState.assistantText!;\n      state.content += content.Text.text;\n\n      return {\n        timestamp: Date.now(),\n        entryType: { type: 'AssistantMessage' },\n        content: state.content,\n        metadata: null,\n      };\n    }\n\n    return null;\n  }\n\n  private normalizeThought(content: ContentBlock): NormalizedEntry | null {\n    this.streamingState.assistantText = undefined;\n\n    if ('Text' in content) {\n      const isNew = !this.streamingState.thinkingText;\n      if (isNew) {\n        this.streamingState.thinkingText = {\n          index: this.nextIndex++,\n          content: '',\n        };\n      }\n\n      const state = this.streamingState.thinkingText!;\n      state.content += content.Text.text;\n\n      return {\n        timestamp: Date.now(),\n        entryType: { type: 'Thinking' },\n        content: state.content,\n        metadata: null,\n      };\n    }\n\n    return null;\n  }\n\n  private normalizeToolCall(\n    toolCall: ToolCall,\n    workDir: string\n  ): NormalizedEntry {\n    this.streamingState = {};\n\n    const id = toolCall.id.toString();\n    const isNew = !this.toolStates.has(id);\n\n    if (isNew) {\n      this.toolStates.set(id, {\n        index: this.nextIndex++,\n        id,\n        kind: toolCall.kind,\n        title: toolCall.title,\n        status: toolCall.status,\n        path: toolCall.locations?.[0]?.path,\n        content: toolCall.content || [],\n        rawInput: toolCall.rawInput,\n        rawOutput: toolCall.rawOutput,\n      });\n    } else {\n      // Update existing tool state\n      const state = this.toolStates.get(id)!;\n      if (toolCall.title) state.title = toolCall.title;\n      if (toolCall.status) state.status = toolCall.status;\n      if (toolCall.content) state.content = toolCall.content;\n      if (toolCall.rawInput) state.rawInput = toolCall.rawInput;\n      if (toolCall.rawOutput) state.rawOutput = toolCall.rawOutput;\n    }\n\n    const state = this.toolStates.get(id)!;\n    const action = this.mapToActionType(state, workDir);\n\n    return {\n      timestamp: Date.now(),\n      entryType: {\n        type: 'ToolUse',\n        toolName: state.title,\n        actionType: action,\n        status: this.convertToolStatus(state.status),\n      },\n      content: this.getToolContent(state),\n      metadata: null,\n    };\n  }\n\n  private normalizeToolUpdate(\n    update: ToolCallUpdate,\n    workDir: string\n  ): NormalizedEntry | null {\n    // Convert ToolCallUpdate to ToolCall and normalize\n    const toolCall = this.toolCallUpdateToToolCall(update);\n    return this.normalizeToolCall(toolCall, workDir);\n  }\n\n  private normalizePlan(plan: any): NormalizedEntry {\n    const body = plan.entries\n      .map((e: any, i: number) => `${i + 1}. ${e.content}`)\n      .join('\\n');\n\n    return {\n      timestamp: Date.now(),\n      entryType: { type: 'SystemMessage' },\n      content: `Plan:\\n${body}`,\n      metadata: null,\n    };\n  }\n\n  private normalizeAvailableCommands(commands: any[]): NormalizedEntry {\n    const body = commands.map((c) => `- ${c.name}`).join('\\n');\n\n    return {\n      timestamp: Date.now(),\n      entryType: { type: 'SystemMessage' },\n      content: `Available commands:\\n${body}`,\n      metadata: null,\n    };\n  }\n\n  private normalizeCurrentMode(modeId: any): NormalizedEntry {\n    return {\n      timestamp: Date.now(),\n      entryType: { type: 'SystemMessage' },\n      content: `Current mode: ${modeId}`,\n      metadata: null,\n    };\n  }\n\n  private mapToActionType(state: ToolState, workDir: string): ActionType {\n    switch (state.kind) {\n      case 'Read':\n        // Special case: read_many_files\n        if (state.id.startsWith('read_many_files')) {\n          return {\n            type: 'Tool',\n            toolName: 'read_many_files',\n            arguments: { files: state.title },\n            result: this.extractTextContent(state.content),\n          };\n        }\n        return {\n          type: 'FileRead',\n          path: state.path || '',\n        };\n\n      case 'Edit':\n        return {\n          type: 'FileEdit',\n          path: state.path || '',\n          changes: this.extractFileChanges(state),\n        };\n\n      case 'Execute':\n        const command = this.parseExecuteCommand(state.title);\n        const result = state.rawOutput\n          ? this.parseShellOutput(state.rawOutput)\n          : null;\n        return {\n          type: 'CommandRun',\n          command,\n          result,\n        };\n\n      case 'Delete':\n        return {\n          type: 'FileEdit',\n          path: state.path || '',\n          changes: [{ type: 'Delete' }],\n        };\n\n      case 'Search':\n        const query = state.rawInput?.query || state.title;\n        return { type: 'Search', query };\n\n      case 'Fetch':\n        const url = state.rawInput?.url || this.extractUrlFromText(state.title);\n        return { type: 'WebFetch', url };\n\n      case 'Think':\n        return {\n          type: 'Tool',\n          toolName: 'think',\n          arguments: { title: state.title },\n          result: this.extractTextContent(state.content),\n        };\n\n      default:\n        return {\n          type: 'Tool',\n          toolName: this.extractToolNameFromId(state.id) || state.title,\n          arguments: state.rawInput,\n          result: state.rawOutput\n            ? { type: 'Json', value: state.rawOutput }\n            : this.extractTextContent(state.content),\n        };\n    }\n  }\n\n  private extractFileChanges(state: ToolState): FileChange[] {\n    const changes: FileChange[] = [];\n\n    for (const item of state.content) {\n      if ('Diff' in item) {\n        const diff = item.Diff;\n        const oldText = diff.oldText || '';\n\n        if (oldText === '') {\n          changes.push({\n            type: 'Write',\n            content: diff.newText,\n          });\n        } else {\n          changes.push({\n            type: 'Edit',\n            unifiedDiff: this.createUnifiedDiff(\n              diff.path,\n              oldText,\n              diff.newText\n            ),\n            hasLineNumbers: false,\n          });\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  private parseShellOutput(rawOutput: any): any {\n    return {\n      exitStatus: rawOutput.exitCode\n        ? { ExitCode: { code: rawOutput.exitCode } }\n        : { Success: { success: true } },\n      output: rawOutput.stdout || rawOutput.stderr || null,\n    };\n  }\n\n  private convertToolStatus(status: ToolCallStatus): ToolStatus {\n    if (status === 'Pending' || status === 'InProgress') {\n      return 'Created';\n    }\n    if (status === 'Completed') {\n      return 'Success';\n    }\n    return 'Failed';\n  }\n\n  private extractTextContent(content: any[]): any {\n    const text = content\n      .filter((c) => 'Content' in c && 'Text' in c.Content.content)\n      .map((c) => c.Content.content.Text.text)\n      .join('\\n');\n\n    return text ? { type: 'Markdown', value: text } : null;\n  }\n\n  private parseExecuteCommand(title: string): string {\n    return title.split(' (')[0].trim();\n  }\n\n  private extractToolNameFromId(id: string): string | null {\n    const lastDash = id.lastIndexOf('-');\n    if (lastDash === -1) return null;\n\n    const tail = id.slice(lastDash + 1);\n    if (/^\\d+$/.test(tail)) {\n      return id.slice(0, lastDash);\n    }\n\n    return null;\n  }\n\n  private extractUrlFromText(text: string): string {\n    const match = text.match(/https?:\\/\\/[^\\s\"')]+/);\n    return match ? match[0] : '';\n  }\n\n  private toolCallUpdateToToolCall(update: ToolCallUpdate): ToolCall {\n    // Merge update fields into ToolCall structure\n    return {\n      id: update.id,\n      kind: update.fields.kind || ('Other' as ToolKind),\n      title: update.fields.title || '',\n      status: update.fields.status || ('Pending' as ToolCallStatus),\n      locations: update.fields.locations || [],\n      content: update.fields.content || [],\n      rawInput: update.fields.rawInput,\n      rawOutput: update.fields.rawOutput,\n    };\n  }\n\n  private createUnifiedDiff(path: string, oldText: string, newText: string): string {\n    // Simple diff implementation (use a library like diff in production)\n    return `--- ${path}\\n+++ ${path}\\n${newText}`;\n  }\n\n  private getToolContent(state: ToolState): string {\n    if (state.kind === 'Execute') {\n      return this.parseExecuteCommand(state.title);\n    }\n    if (state.kind === 'Think') {\n      return 'Saving memory';\n    }\n    return state.title;\n  }\n}\n```\n\n---\n\n### R6: ClientSideConnection Bridge\n\n**Description**: Create TypeScript bridge for agent-client-protocol library\n\n**Acceptance Criteria**:\n- Wraps agent-client-protocol's ClientSideConnection (Rust crate)\n- Provides `initialize()` for protocol handshake\n- Provides `prompt()` for starting conversations\n- Handles incoming/outgoing duplex streams\n- Emits `onPromptComplete` event for exit signal\n\n**Implementation Notes**:\n\nSince `agent-client-protocol` is a Rust crate, we have two options:\n\n1. **Option A: Use WASM binding** (if available)\n   - Compile Rust crate to WASM\n   - Use wasm-bindgen for TypeScript bindings\n\n2. **Option B: Reimplement ACP protocol in TypeScript**\n   - Study agent-client-protocol Rust source\n   - Implement JSONRPC-like message passing\n   - Handle Initialize, Prompt, SessionNotification flows\n\n**Recommended**: Start with Option B (pure TypeScript implementation) for portability and debugging ease. Reference the Rust implementation as specification.\n\n```typescript\n// src/agents/gemini/acp/client-side-connection.ts\nimport type { Readable, Writable } from 'stream';\nimport type { AcpClient } from './client.js';\n\nexport interface ClientCapabilities {\n  name: string;\n  version: string;\n  capabilities: {\n    terminal: boolean;\n    fileSystem: boolean;\n  };\n}\n\nexport class ClientSideConnection {\n  private incoming: Readable;\n  private outgoing: Writable;\n  private client: AcpClient;\n  private promptCompleteCallback?: () => void;\n  private requestId = 0;\n\n  constructor(\n    incoming: Readable,\n    outgoing: Writable,\n    client: AcpClient\n  ) {\n    this.incoming = incoming;\n    this.outgoing = outgoing;\n    this.client = client;\n    this.startListening();\n  }\n\n  async initialize(capabilities: ClientCapabilities): Promise<void> {\n    const message = {\n      jsonrpc: '2.0',\n      method: 'initialize',\n      params: capabilities,\n      id: this.requestId++,\n    };\n\n    this.send(message);\n    // Wait for response (simplified, needs proper JSONRPC handling)\n    await this.waitForResponse(message.id);\n  }\n\n  async prompt(\n    prompt: string,\n    metadata?: { sessionId?: string; history?: string }\n  ): Promise<void> {\n    const message = {\n      jsonrpc: '2.0',\n      method: 'prompt',\n      params: {\n        prompt,\n        sessionId: metadata?.sessionId,\n        history: metadata?.history,\n      },\n      id: this.requestId++,\n    };\n\n    this.send(message);\n  }\n\n  onPromptComplete(callback: () => void): void {\n    this.promptCompleteCallback = callback;\n  }\n\n  private startListening(): void {\n    let buffer = '';\n\n    this.incoming.on('data', (chunk) => {\n      buffer += chunk.toString();\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || '';\n\n      for (const line of lines) {\n        if (line.trim()) {\n          this.handleMessage(JSON.parse(line));\n        }\n      }\n    });\n  }\n\n  private handleMessage(message: any): void {\n    // Handle JSONRPC requests from server\n    if (message.method === 'session_notification') {\n      this.client.sessionNotification(message.params);\n    } else if (message.method === 'request_permission') {\n      this.client.requestPermission(message.params).then((response) => {\n        this.send({\n          jsonrpc: '2.0',\n          result: response,\n          id: message.id,\n        });\n      });\n    } else if (message.method === 'prompt_complete') {\n      this.promptCompleteCallback?.();\n    }\n  }\n\n  private send(message: any): void {\n    this.outgoing.write(JSON.stringify(message) + '\\n');\n  }\n\n  private async waitForResponse(id: number): Promise<any> {\n    // Simplified response waiting (needs proper promise queue)\n    return new Promise((resolve) => {\n      const handler = (chunk: Buffer) => {\n        const message = JSON.parse(chunk.toString());\n        if (message.id === id) {\n          this.incoming.off('data', handler);\n          resolve(message.result);\n        }\n      };\n      this.incoming.on('data', handler);\n    });\n  }\n}\n```\n\n---\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **AcpClient Tests** (`tests/unit/agents/gemini/acp/client.test.ts`)\n   - Test auto-approval logic (AllowAlways > AllowOnce > first)\n   - Test session_notification mapping to AcpEvent\n   - Test error throwing for unimplemented methods\n\n2. **SessionManager Tests** (`tests/unit/agents/gemini/acp/session.test.ts`)\n   - Test session JSONL persistence\n   - Test session forking\n   - Test event normalization\n   - Test resume prompt generation\n\n3. **AcpNormalizer Tests** (`tests/unit/agents/gemini/acp/normalize.test.ts`)\n   - Test streaming coalescing (Message/Thought)\n   - Test ToolCall mapping to ActionType\n   - Test file change extraction from Edit tools\n   - Test shell output parsing from Execute tools\n\n### Integration Tests\n\n1. **GeminiExecutor E2E Test** (`tests/e2e/agents/gemini.test.ts`)\n   - Spawn Gemini CLI with `--experimental-acp`\n   - Send prompt and verify NormalizedEntry output\n   - Test session resumption across multiple executions\n   - Verify exit signal emission\n\n## Integration with Existing Infrastructure\n\n### Reusability\n\n| Component | Existing Code | New Code | Reusability |\n|-----------|--------------|----------|-------------|\n| Process spawning | IProcessManager, ProcessConfig | AcpAgentHarness duplex wiring | 70% |\n| Task execution | ExecutionTask, SimpleExecutionEngine | GeminiExecutor | 95% |\n| Output handling | onOutput hook, MsgStore | AcpNormalizer | 60% |\n| Session management | N/A | SessionManager, AcpClient | 0% (new) |\n| **Total** | - | - | **65%** |\n\n**New Infrastructure (~2500 lines)**:\n- AcpAgentHarness: ~200 lines (duplex channel plumbing)\n- AcpClient: ~150 lines (protocol handler)\n- SessionManager: ~150 lines (JSONL persistence)\n- ClientSideConnection: ~200 lines (JSONRPC bridge)\n- AcpNormalizer: ~500 lines (output normalization)\n- GeminiExecutor: ~100 lines (thin wrapper)\n- Type definitions: ~200 lines\n\n### Dependencies\n\n**Production**:\n```json\n{\n  \"agent-client-protocol\": \"^0.1.0\" // Or TypeScript reimplementation\n}\n```\n\n### Configuration\n\n```typescript\n// Profile system integration\n{\n  \"executors\": {\n    \"GEMINI\": {\n      \"DEFAULT\": {\n        \"executor\": \"gemini\",\n        \"executablePath\": \"npx\",\n        \"args\": [\"-y\", \"@google/gemini-cli\", \"--experimental-acp\"],\n        \"env\": {},\n        \"sessionNamespace\": \"gemini-sessions\",\n        \"autoApprove\": true,\n        \"model\": \"gemini-2.5-flash-thinking-exp-01-21\" // Optional\n      }\n    }\n  }\n}\n```\n\n## Comparison with Other Protocols\n\n| Feature | Cursor (JSONL) | Codex (JSONRPC) | Claude (Stream-JSON) | Gemini (ACP) |\n|---------|---------------|-----------------|---------------------|--------------|\n| Communication | Unidirectional | Bidirectional | Bidirectional | Bidirectional |\n| Protocol | Line-delimited JSON | JSONRPC 2.0 | Custom JSON | JSONRPC-like |\n| Approval handling | No | Yes (server requests) | Yes (control channel) | Yes (request_permission) |\n| Session persistence | No | Yes (rollout files) | No | Yes (JSONL + forking) |\n| Streaming | Message coalescing | Event accumulation | Native streaming | Message/Thought chunks |\n| Exit signal | No (stdin close) | Yes (Done event) | Yes (control channel) | Yes (prompt_complete) |\n| Complexity | ⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |\n\n## Implementation Order\n\n1. **Phase 1: Core Types** (1 day)\n   - Define AcpEvent discriminated union\n   - Define TypeScript interfaces for agent-client-protocol types\n   - Create GeminiConfig type\n\n2. **Phase 2: Session Management** (2 days)\n   - Implement SessionManager with JSONL persistence\n   - Implement session forking and normalization\n   - Write unit tests\n\n3. **Phase 3: AcpClient** (2 days)\n   - Implement AcpClient with event emission\n   - Implement auto-approval logic\n   - Write unit tests\n\n4. **Phase 4: AcpAgentHarness** (3 days)\n   - Implement duplex channel plumbing\n   - Implement ClientSideConnection (or WASM binding)\n   - Bootstrap ACP protocol with initialize handshake\n   - Write integration tests\n\n5. **Phase 5: Output Normalization** (3 days)\n   - Implement AcpNormalizer for all event types\n   - Implement streaming coalescing\n   - Implement ToolCall → ActionType mapping\n   - Write comprehensive unit tests\n\n6. **Phase 6: GeminiExecutor** (1 day)\n   - Implement thin wrapper around AcpAgentHarness\n   - Integrate with profile system\n   - Write E2E tests\n\n7. **Phase 7: Documentation** (1 day)\n   - Update AGENTS.md with Gemini setup instructions\n   - Add examples to README.md\n   - Document ACP protocol specifics\n\n**Total Estimated Time**: 13 days\n\n## References\n\n- **Vibe-Kanban Gemini Implementation**: `references/vibe-kanban/crates/executors/src/executors/gemini.rs`\n- **ACP Harness**: `references/vibe-kanban/crates/executors/src/executors/acp/harness.rs`\n- **ACP Client**: `references/vibe-kanban/crates/executors/src/executors/acp/client.rs`\n- **ACP Normalization**: `references/vibe-kanban/crates/executors/src/executors/acp/normalize_logs.rs`\n- **Session Manager**: `references/vibe-kanban/crates/executors/src/executors/acp/session.rs`\n- **Agent Client Protocol (Rust crate)**: https://github.com/google-labs/agent-client-protocol (assumed)\n- **Gemini CLI Documentation**: `references/vibe-kanban/docs/agents/gemini-cli.mdx`","priority":2,"archived":0,"archived_at":null,"created_at":"2025-11-20 11:00:22","updated_at":"2025-11-20 11:00:22","parent_id":null,"parent_uuid":null,"relationships":[{"from":"s-iaik","from_type":"spec","to":"s-6s6c","to_type":"spec","type":"depends-on"}],"tags":["acp","agent-executor","gemini","protocol","session-management"]}
{"id":"s-gku1","uuid":"a028274c-e948-465f-bd26-be730d939763","title":"GitHub Copilot Executor - Plain Text Streaming Protocol Implementation","file_path":"specs/github_copilot_executor_plain_text_streaming_proto.md","content":"# GitHub Copilot Executor - Plain Text Streaming Protocol Implementation\n\n## Overview\n\nThe GitHub Copilot CLI executor (`@github/copilot`) implements the **simplest protocol** among all executors analyzed. It uses **plain text streaming** with ANSI escape code handling, making it the most straightforward implementation after Cursor.\n\n**Key Characteristics**:\n1. **Plain text output** - No structured JSON, just raw text with ANSI escapes\n2. **File-based session management** - Sessions stored as `<UUID>.log` files\n3. **External debug logs** - Requires `--log-dir` for session tracking\n4. **MCP support** - Native Model Context Protocol integration\n5. **Tool permission controls** - Fine-grained allow/deny tool configuration\n\n**Complexity: ⭐** (Tied with Cursor for simplest)\n\n## Protocol Architecture\n\n### Two-Layer Architecture\n\n```\n┌─────────────────────────────────────────────┐\n│  CopilotExecutor (IAgentExecutor)           │  - Config builder\n│  - buildProcessConfig()                     │  - Inherits from BaseAgentExecutor\n│  - executeTask()                            │  - Session ID discovery\n└──────────────────┬──────────────────────────┘\n                   │\n                   ↓\n┌─────────────────────────────────────────────┐\n│  PlainTextLogProcessor                      │  - ANSI escape stripping\n│  - process(line)                            │  - Line batching\n│  - transform_lines()                        │  - Converts to AssistantMessage\n└─────────────────────────────────────────────┘\n```\n\n### Protocol Flow\n\n```\n┌───────────┐                  ┌──────────────┐                 ┌─────────────┐\n│  Engine   │                  │   Copilot    │                 │ copilot CLI │\n└─────┬─────┘                  │   Executor   │                 └──────┬──────┘\n      │                        └──────┬───────┘                        │\n      │ executeTask(task)             │                                │\n      ├──────────────────────────────>│                                │\n      │                               │                                │\n      │                               │ spawn(\"npx @github/copilot\",   │\n      │                               │   [\"--no-color\",               │\n      │                               │    \"--log-level\", \"debug\",     │\n      │                               │    \"--log-dir\", tempDir])      │\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │ stdin.write(prompt)            │\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │ stdin.close()                  │\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │<─ stdout (plain text) ─────────│\n      │<─ NormalizedEntry ────────────│   (with ANSI escapes)          │\n      │   (AssistantMessage)          │                                │\n      │                               │                                │\n      │                               │ watchSessionId(tempDir)        │\n      │                               │   - Polling for <uuid>.log     │\n      │                               │   - Extract UUID as session    │\n      │                               │                                │\n      │                               │<─ [copilot-session] uuid ──────│\n      │<─ sessionId ──────────────────│   (emitted to stdout)          │\n      │                               │                                │\n      │                               │<─ Process exit ────────────────│\n      │<─ TaskResult ─────────────────│                                │\n```\n\n### Session Resumption Flow\n\n```\n┌───────────┐                  ┌──────────────┐                 ┌─────────────┐\n│  Engine   │                  │   Copilot    │                 │ copilot CLI │\n└─────┬─────┘                  │   Executor   │                 └──────┬──────┘\n      │                        └──────┬───────┘                        │\n      │ executeTask(task)             │                                │\n      │   sessionId = \"abc-123\"       │                                │\n      ├──────────────────────────────>│                                │\n      │                               │                                │\n      │                               │ spawn(\"npx @github/copilot\",   │\n      │                               │   [\"--resume\", \"abc-123\"])     │\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │ stdin.write(followUpPrompt)    │\n      │                               ├───────────────────────────────>│\n      │                               │                                │\n      │                               │<─ stdout (continues session) ──│\n      │<─ NormalizedEntry ────────────│                                │\n```\n\n## Requirements\n\n### R1: CopilotExecutor Implementation\n\n**Description**: Implement GitHub Copilot executor with log-based session tracking\n\n**Acceptance Criteria**:\n- Extends `BaseAgentExecutor`\n- Uses `npx -y @github/copilot@0.0.358` as default executable\n- Creates temporary log directory for each execution\n- Implements session ID discovery by polling log directory for `<UUID>.log` file\n- Supports `--resume` for follow-up execution\n- Integrates with profile system for configuration\n\n**Implementation**:\n\n```typescript\n// src/agents/copilot/executor.ts\nimport { spawn } from 'child_process';\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { tmpdir } from 'os';\nimport { v4 as uuidv4 } from 'uuid';\nimport { BaseAgentExecutor } from '../base-executor.js';\nimport type { ExecutionTask, SpawnedChild } from '@/engine/types.js';\nimport type { CopilotConfig } from './config.js';\n\nexport class CopilotExecutor extends BaseAgentExecutor {\n  constructor(config: CopilotConfig) {\n    super(config);\n  }\n\n  protected async spawnForTask(task: ExecutionTask): Promise<SpawnedChild> {\n    const config = this.config as CopilotConfig;\n    const logDir = await this.createTempLogDir(task.workDir);\n\n    // Build command\n    const executable = config.executablePath || 'npx';\n    const args = this.buildArgs(config, logDir, task.sessionId);\n\n    // Spawn process\n    const child = spawn(executable, args, {\n      cwd: task.workDir,\n      env: {\n        ...process.env,\n        NODE_NO_WARNINGS: '1',\n        ...config.env,\n      },\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n\n    // Write prompt and close stdin\n    const combinedPrompt = this.combinePrompt(task.prompt);\n    child.stdin!.write(combinedPrompt);\n    child.stdin!.end();\n\n    // Start session ID discovery\n    const sessionIdPromise = this.watchSessionId(logDir);\n    sessionIdPromise.then((sessionId) => {\n      // Emit session ID to stdout for tracking\n      const sessionLine = `[copilot-session] ${sessionId}\\n`;\n      child.stdout!.push(sessionLine);\n    }).catch((err) => {\n      console.error('Failed to discover session ID:', err);\n    });\n\n    return {\n      process: this.wrapChildProcess(child),\n      sessionId: task.sessionId,\n    };\n  }\n\n  private buildArgs(\n    config: CopilotConfig,\n    logDir: string,\n    sessionId?: string\n  ): string[] {\n    const args: string[] = [];\n\n    // Executable wrapper (if using npx)\n    if (config.executablePath === 'npx' || !config.executablePath) {\n      args.push('-y', '@github/copilot@0.0.358');\n    }\n\n    // Required args for logging\n    args.push('--no-color');\n    args.push('--log-level', 'debug');\n    args.push('--log-dir', logDir);\n\n    // Session resumption\n    if (sessionId) {\n      args.push('--resume', sessionId);\n    }\n\n    // Model selection\n    if (config.model) {\n      args.push('--model', config.model);\n    }\n\n    // Tool permissions\n    if (config.allowAllTools) {\n      args.push('--allow-all-tools');\n    }\n\n    if (config.allowTool) {\n      args.push('--allow-tool', config.allowTool);\n    }\n\n    if (config.denyTool) {\n      args.push('--deny-tool', config.denyTool);\n    }\n\n    // Additional directories\n    if (config.addDir) {\n      for (const dir of config.addDir) {\n        args.push('--add-dir', dir);\n      }\n    }\n\n    // MCP server configuration\n    if (config.disableMcpServer) {\n      for (const server of config.disableMcpServer) {\n        args.push('--disable-mcp-server', server);\n      }\n    }\n\n    return args;\n  }\n\n  private async createTempLogDir(workDir: string): Promise<string> {\n    const baseLogDir = join(tmpdir(), 'copilot_logs');\n    await fs.mkdir(baseLogDir, { recursive: true });\n\n    // Create unique run directory\n    const runId = uuidv4();\n    const workDirName = workDir.split('/').pop() || 'unknown';\n    const runLogDir = join(baseLogDir, workDirName, runId);\n    await fs.mkdir(runLogDir, { recursive: true });\n\n    return runLogDir;\n  }\n\n  /**\n   * Poll log directory for <UUID>.log file and extract session ID\n   * \n   * Copilot creates a log file named <session-uuid>.log in the log directory.\n   * We poll every 200ms for up to 10 minutes to find this file.\n   */\n  private async watchSessionId(logDir: string): Promise<string> {\n    const timeout = 600_000; // 10 minutes\n    const interval = 200; // 200ms\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      try {\n        const entries = await fs.readdir(logDir);\n        \n        for (const entry of entries) {\n          if (entry.endsWith('.log')) {\n            const sessionId = entry.replace('.log', '');\n            \n            // Validate it's a UUID\n            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n            if (uuidRegex.test(sessionId)) {\n              return sessionId;\n            }\n          }\n        }\n      } catch (err) {\n        // Directory might not exist yet, continue polling\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, interval));\n    }\n\n    throw new Error(`No session log file found in ${logDir} after ${timeout}ms`);\n  }\n\n  private combinePrompt(userPrompt: string): string {\n    const config = this.config as CopilotConfig;\n    if (config.systemPrompt) {\n      return `${config.systemPrompt}\\n\\n${userPrompt}`;\n    }\n    return userPrompt;\n  }\n}\n```\n\n**Configuration Types**:\n\n```typescript\n// src/agents/copilot/config.ts\nimport type { BaseAgentConfig } from '../types.js';\n\nexport interface CopilotConfig extends BaseAgentConfig {\n  /** Model to use (e.g., \"gpt-4o\", \"claude-3.5-sonnet\") */\n  model?: string;\n\n  /** Allow all tools without prompting */\n  allowAllTools?: boolean;\n\n  /** Specific tool to allow (can be used multiple times in vibe-kanban) */\n  allowTool?: string;\n\n  /** Specific tool to deny */\n  denyTool?: string;\n\n  /** Additional directories to add to context */\n  addDir?: string[];\n\n  /** MCP servers to disable */\n  disableMcpServer?: string[];\n\n  /** System prompt to prepend to user prompt */\n  systemPrompt?: string;\n}\n```\n\n---\n\n### R2: PlainTextLogProcessor Implementation\n\n**Description**: Implement plain text output processor with ANSI escape stripping\n\n**Acceptance Criteria**:\n- Strips ANSI escape codes from output lines\n- Batches lines into paragraphs (separated by blank lines)\n- Converts batched text to `AssistantMessage` entries\n- Supports custom entry producers via builder pattern\n- Handles streaming output efficiently\n\n**Implementation**:\n\n```typescript\n// src/agents/copilot/plain-text-processor.ts\nimport stripAnsi from 'strip-ansi';\nimport type { NormalizedEntry, NormalizedEntryType } from '@/logs/types.js';\n\nexport interface PlainTextProcessorConfig {\n  /** Function to create NormalizedEntry from content */\n  entryProducer: (content: string) => NormalizedEntry;\n\n  /** Transform lines before processing */\n  transformLines?: (lines: string[]) => void;\n\n  /** Index provider for entry indices */\n  indexProvider: EntryIndexProvider;\n}\n\nexport class PlainTextLogProcessor {\n  private config: PlainTextProcessorConfig;\n  private lineBuffer: string[] = [];\n  private currentIndex: number | null = null;\n\n  constructor(config: PlainTextProcessorConfig) {\n    this.config = config;\n  }\n\n  static builder(): PlainTextProcessorBuilder {\n    return new PlainTextProcessorBuilder();\n  }\n\n  /**\n   * Process a line of output and return patches to emit\n   * \n   * Lines are batched into paragraphs. A paragraph ends when:\n   * - An empty line is encountered\n   * - A new paragraph starts (detected heuristically)\n   */\n  process(line: string): ConversationPatch[] {\n    const patches: ConversationPatch[] = [];\n\n    // Strip ANSI escapes\n    const cleanLine = stripAnsi(line);\n\n    // Check if this is a blank line (paragraph separator)\n    if (cleanLine.trim() === '') {\n      if (this.lineBuffer.length > 0) {\n        // Flush current paragraph\n        patches.push(this.flushParagraph());\n      }\n      return patches;\n    }\n\n    // Add line to buffer\n    this.lineBuffer.push(cleanLine);\n\n    // If this is the first line, allocate a new index\n    if (this.currentIndex === null) {\n      this.currentIndex = this.config.indexProvider.next();\n    }\n\n    // Create or update entry\n    const content = this.lineBuffer.join('');\n    const entry = this.config.entryProducer(content);\n\n    if (this.lineBuffer.length === 1) {\n      // First line of paragraph - add new entry\n      patches.push(ConversationPatch.add(this.currentIndex, entry));\n    } else {\n      // Subsequent lines - replace existing entry\n      patches.push(ConversationPatch.replace(this.currentIndex, entry));\n    }\n\n    return patches;\n  }\n\n  private flushParagraph(): ConversationPatch {\n    // Apply line transformations if configured\n    if (this.config.transformLines) {\n      this.config.transformLines(this.lineBuffer);\n    }\n\n    const content = this.lineBuffer.join('');\n    const entry = this.config.entryProducer(content);\n\n    const patch = ConversationPatch.replace(this.currentIndex!, entry);\n\n    // Reset state\n    this.lineBuffer = [];\n    this.currentIndex = null;\n\n    return patch;\n  }\n}\n\nexport class PlainTextProcessorBuilder {\n  private entryProducer?: (content: string) => NormalizedEntry;\n  private transformLines?: (lines: string[]) => void;\n  private indexProvider?: EntryIndexProvider;\n\n  normalizedEntryProducer(producer: (content: string) => NormalizedEntry): this {\n    this.entryProducer = producer;\n    return this;\n  }\n\n  transformLines(transformer: (lines: string[]) => void): this {\n    this.transformLines = transformer;\n    return this;\n  }\n\n  indexProvider(provider: EntryIndexProvider): this {\n    this.indexProvider = provider;\n    return this;\n  }\n\n  build(): PlainTextLogProcessor {\n    if (!this.entryProducer || !this.indexProvider) {\n      throw new Error('entryProducer and indexProvider are required');\n    }\n\n    return new PlainTextLogProcessor({\n      entryProducer: this.entryProducer,\n      transformLines: this.transformLines,\n      indexProvider: this.indexProvider,\n    });\n  }\n}\n\n// Helper types\ninterface EntryIndexProvider {\n  next(): number;\n}\n\ninterface ConversationPatch {\n  type: 'add' | 'replace';\n  index: number;\n  entry: NormalizedEntry;\n}\n\nconst ConversationPatch = {\n  add(index: number, entry: NormalizedEntry): ConversationPatch {\n    return { type: 'add', index, entry };\n  },\n\n  replace(index: number, entry: NormalizedEntry): ConversationPatch {\n    return { type: 'replace', index, entry };\n  },\n};\n```\n\n**Usage in CopilotExecutor**:\n\n```typescript\n// src/agents/copilot/executor.ts (continued)\nexport class CopilotExecutor extends BaseAgentExecutor {\n  // ... existing code ...\n\n  protected createOutputNormalizer(): PlainTextLogProcessor {\n    const entryIndexProvider = this.getEntryIndexProvider();\n\n    return PlainTextLogProcessor.builder()\n      .normalizedEntryProducer((content: string) => ({\n        timestamp: Date.now(),\n        entryType: { type: 'AssistantMessage' },\n        content,\n        metadata: null,\n      }))\n      .transformLines((lines: string[]) => {\n        // Strip ANSI escapes from each line\n        lines.forEach((line, i) => {\n          lines[i] = stripAnsi(line);\n        });\n      })\n      .indexProvider(entryIndexProvider)\n      .build();\n  }\n\n  protected async normalizeOutput(\n    stdout: ReadableStream<Uint8Array>\n  ): Promise<void> {\n    const processor = this.createOutputNormalizer();\n    const reader = stdout.getReader();\n    const decoder = new TextDecoder();\n\n    let buffer = '';\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || '';\n\n      for (const line of lines) {\n        // Check for session ID marker\n        if (line.startsWith('[copilot-session] ')) {\n          const sessionId = line.replace('[copilot-session] ', '').trim();\n          this.emitSessionId(sessionId);\n          continue;\n        }\n\n        // Process normal output lines\n        const patches = processor.process(line + '\\n');\n        for (const patch of patches) {\n          this.emitPatch(patch);\n        }\n      }\n    }\n\n    // Process remaining buffer\n    if (buffer) {\n      const patches = processor.process(buffer);\n      for (const patch of patches) {\n        this.emitPatch(patch);\n      }\n    }\n  }\n}\n```\n\n---\n\n### R3: Session Management Integration\n\n**Description**: Implement session tracking via log file discovery\n\n**Acceptance Criteria**:\n- Creates unique temporary log directory for each execution\n- Polls log directory for `<UUID>.log` file creation\n- Extracts session ID from filename\n- Emits session ID to stdout with `[copilot-session]` prefix\n- Supports `--resume` flag for follow-up executions\n\n**Implementation**: See R1 above (integrated into CopilotExecutor)\n\n**Key Points**:\n- **Log directory structure**: `<tmpdir>/copilot_logs/<workDir>/<runId>/`\n- **Session discovery**: Poll every 200ms for up to 10 minutes\n- **Session validation**: Verify filename matches UUID format\n- **Resume support**: Pass `--resume <session-id>` for follow-ups\n\n---\n\n### R4: MCP Configuration Support\n\n**Description**: Support GitHub Copilot's native MCP integration\n\n**Acceptance Criteria**:\n- Locates default MCP config at `~/.copilot/mcp-config.json`\n- Supports `--disable-mcp-server` flag to selectively disable servers\n- Validates MCP config file exists for availability check\n- Integrates with profile system MCP configuration\n\n**Implementation**:\n\n```typescript\n// src/agents/copilot/executor.ts (continued)\nexport class CopilotExecutor extends BaseAgentExecutor {\n  // ... existing code ...\n\n  getDefaultMcpConfigPath(): string | null {\n    const homeDir = require('os').homedir();\n    if (!homeDir) return null;\n\n    return join(homeDir, '.copilot', 'mcp-config.json');\n  }\n\n  async checkAvailability(): Promise<boolean> {\n    const mcpConfigPath = this.getDefaultMcpConfigPath();\n    if (!mcpConfigPath) return false;\n\n    try {\n      await fs.access(mcpConfigPath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  getMcpConfig(): McpConfig {\n    return {\n      configPaths: ['mcpServers'],\n      template: {\n        mcpServers: {},\n      },\n      preconfigured: this.getPreconfiguredMcpServers(),\n      mergeArrays: false,\n    };\n  }\n\n  private getPreconfiguredMcpServers(): Record<string, any> {\n    // GitHub Copilot has some built-in MCP servers\n    return {\n      // Add any preconfigured servers here\n    };\n  }\n}\n```\n\n---\n\n### R5: Tool Permission Configuration\n\n**Description**: Support fine-grained tool access control\n\n**Acceptance Criteria**:\n- Supports `--allow-all-tools` to enable all tools without prompting\n- Supports `--allow-tool <name>` to whitelist specific tools\n- Supports `--deny-tool <name>` to blacklist specific tools\n- Integrates with profile system configuration\n\n**Tool Examples**:\n- `bash` - Shell command execution\n- `read_file` - Read file contents\n- `write_file` - Write file contents\n- `edit_file` - Edit file with patches\n- `search` - Code search\n- `web_fetch` - Fetch URLs\n\n**Configuration Example**:\n\n```json\n{\n  \"executors\": {\n    \"COPILOT\": {\n      \"DEFAULT\": {\n        \"executor\": \"copilot\",\n        \"executablePath\": \"npx\",\n        \"allowAllTools\": false,\n        \"allowTool\": \"bash,read_file,write_file\",\n        \"denyTool\": \"web_fetch\",\n        \"model\": \"gpt-4o\"\n      },\n      \"UNRESTRICTED\": {\n        \"executor\": \"copilot\",\n        \"allowAllTools\": true,\n        \"model\": \"claude-3.5-sonnet\"\n      }\n    }\n  }\n}\n```\n\n---\n\n### R6: Additional Directory Context\n\n**Description**: Support adding extra directories to agent context\n\n**Acceptance Criteria**:\n- Supports `--add-dir <path>` to include additional directories\n- Allows multiple directories via array configuration\n- Paths are resolved relative to working directory\n\n**Use Cases**:\n- Adding shared library directories\n- Including configuration directories\n- Adding documentation directories\n\n**Example**:\n\n```typescript\nconst config: CopilotConfig = {\n  workDir: '/project/app',\n  addDir: [\n    '/project/shared-lib',\n    '/project/docs',\n  ],\n};\n```\n\n---\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **CopilotExecutor Tests** (`tests/unit/agents/copilot/executor.test.ts`)\n   - Test command building with various configurations\n   - Test session ID discovery logic\n   - Test temp directory creation\n   - Test prompt combination\n\n2. **PlainTextLogProcessor Tests** (`tests/unit/agents/copilot/plain-text-processor.test.ts`)\n   - Test ANSI escape stripping\n   - Test line batching into paragraphs\n   - Test entry creation and updates\n   - Test blank line handling\n\n### Integration Tests\n\n1. **CopilotExecutor E2E Test** (`tests/e2e/agents/copilot.test.ts`)\n   - Spawn Copilot CLI with test configuration\n   - Send prompt and verify NormalizedEntry output\n   - Verify session ID discovery\n   - Test session resumption with `--resume`\n   - Verify MCP config file detection\n\n## Integration with Existing Infrastructure\n\n### Reusability\n\n| Component | Existing Code | New Code | Reusability |\n|-----------|--------------|----------|-------------|\n| Process spawning | IProcessManager, ProcessConfig | CopilotExecutor spawn logic | 90% |\n| Task execution | ExecutionTask, SimpleExecutionEngine | CopilotExecutor | 95% |\n| Output handling | onOutput hook, MsgStore | PlainTextLogProcessor | 50% |\n| Session management | N/A | Session ID discovery | 0% (new) |\n| **Total** | - | - | **75%** |\n\n**New Infrastructure (~800 lines)**:\n- CopilotExecutor: ~300 lines (spawn, session discovery, config)\n- PlainTextLogProcessor: ~200 lines (ANSI stripping, batching)\n- Configuration types: ~100 lines\n- MCP integration: ~100 lines\n- Tests: ~100 lines\n\n### Dependencies\n\n**Production**:\n```json\n{\n  \"strip-ansi\": \"^7.1.0\"\n}\n```\n\n### Configuration\n\n```typescript\n// Profile system integration\n{\n  \"executors\": {\n    \"COPILOT\": {\n      \"DEFAULT\": {\n        \"executor\": \"copilot\",\n        \"executablePath\": \"npx\",\n        \"args\": [\"-y\", \"@github/copilot@0.0.358\"],\n        \"env\": {},\n        \"model\": \"gpt-4o\",\n        \"allowAllTools\": false,\n        \"allowTool\": \"bash,read_file,write_file,edit_file\",\n        \"addDir\": []\n      },\n      \"UNRESTRICTED\": {\n        \"executor\": \"copilot\",\n        \"allowAllTools\": true,\n        \"model\": \"claude-3.5-sonnet\"\n      }\n    }\n  }\n}\n```\n\n## Comparison with Other Protocols\n\n| Feature | Copilot | Cursor (JSONL) | Codex (JSONRPC) | Claude (Stream-JSON) | Gemini (ACP) |\n|---------|---------|----------------|-----------------|---------------------|--------------|\n| Communication | Unidirectional | Unidirectional | Bidirectional | Bidirectional | Bidirectional |\n| Output Format | Plain text | JSONL | JSONRPC | Stream-JSON | JSONRPC-like |\n| ANSI Escapes | Yes (strip) | No | No | No | No |\n| Approval handling | Built-in prompts | No | Yes (server requests) | Yes (control channel) | Yes (request_permission) |\n| Session persistence | Log files | No | Rollout files | No | JSONL + forking |\n| Session discovery | File polling | N/A | Embedded in output | N/A | Handshake |\n| MCP support | Native | No | Native | No | No |\n| Streaming | Plain text chunks | Message coalescing | Event accumulation | Native streaming | Message/Thought chunks |\n| Exit signal | Process exit | stdin close | Done event | Control channel | prompt_complete |\n| Complexity | ⭐ | ⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |\n\n## Implementation Order\n\n1. **Phase 1: Core Types** (0.5 days)\n   - Define CopilotConfig interface\n   - Create executor class skeleton\n\n2. **Phase 2: PlainTextLogProcessor** (1 day)\n   - Implement ANSI escape stripping\n   - Implement line batching logic\n   - Write unit tests\n\n3. **Phase 3: CopilotExecutor** (1.5 days)\n   - Implement command building with all flags\n   - Implement temp directory creation\n   - Write unit tests\n\n4. **Phase 4: Session Discovery** (1 day)\n   - Implement log file polling\n   - Implement session ID extraction and validation\n   - Test with real Copilot CLI\n\n5. **Phase 5: MCP Integration** (0.5 days)\n   - Implement MCP config path detection\n   - Implement availability check\n   - Test with real MCP config\n\n6. **Phase 6: E2E Tests** (1 day)\n   - Write integration tests with real Copilot CLI\n   - Test session resumption\n   - Verify output normalization\n\n7. **Phase 7: Documentation** (0.5 days)\n   - Update AGENTS.md with Copilot setup\n   - Add examples to README.md\n\n**Total Estimated Time**: 6 days\n\n## Special Considerations\n\n### 1. ANSI Escape Codes\n\nGitHub Copilot outputs ANSI escape codes for formatting (colors, bold, etc.). These must be stripped before processing:\n\n```typescript\nimport stripAnsi from 'strip-ansi';\n\nconst cleanLine = stripAnsi('\\x1b[32mHello\\x1b[0m'); // \"Hello\"\n```\n\n### 2. Session File Polling\n\nThe session ID is not emitted directly by Copilot. Instead, it creates a log file with the session ID as the filename. We must poll the log directory:\n\n```typescript\n// Copilot creates: /tmp/copilot_logs/project/run-uuid/abc-123-uuid.log\n// Extract session ID: abc-123-uuid\n```\n\n**Polling Strategy**:\n- Interval: 200ms\n- Timeout: 10 minutes (600,000ms)\n- Validation: Ensure filename matches UUID format\n\n### 3. No Structured Output\n\nUnlike Cursor/Codex/Claude/Gemini, Copilot outputs plain text with no structured events. This means:\n- **No tool use tracking** - Can't distinguish bash commands from text\n- **No thinking/reasoning** - No separate thinking stream\n- **No file changes** - Can't parse individual file edits\n- **Simple normalization** - Everything becomes `AssistantMessage`\n\n### 4. Built-in Tool Prompts\n\nCopilot has built-in approval prompts for dangerous tools (bash, write_file, etc.). These prompts appear in stdout as regular text and are processed like any other output.\n\n### 5. MCP Server Support\n\nCopilot supports MCP servers natively through `~/.copilot/mcp-config.json`. Format:\n\n```json\n{\n  \"mcpServers\": {\n    \"my-server\": {\n      \"command\": \"node\",\n      \"args\": [\"/path/to/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"...\"\n      }\n    }\n  }\n}\n```\n\n## Advantages and Disadvantages\n\n### Advantages\n\n1. **Simplest implementation** - No JSON parsing, no complex state tracking\n2. **Reliable session management** - File-based sessions are persistent and discoverable\n3. **Native MCP support** - First-class integration with Model Context Protocol\n4. **Fine-grained permissions** - Excellent tool access control\n5. **Model flexibility** - Supports multiple providers (GPT-4, Claude, etc.)\n\n### Disadvantages\n\n1. **No structured output** - Can't distinguish tool calls, thinking, or file changes\n2. **Limited observability** - Hard to track what the agent is doing\n3. **Session discovery overhead** - Polling for log files adds latency\n4. **ANSI escape handling** - Requires extra processing step\n5. **Plain text parsing** - Prone to interpretation errors\n\n## References\n\n- **Vibe-Kanban Copilot Implementation**: `references/vibe-kanban/crates/executors/src/executors/copilot.rs`\n- **GitHub Copilot CLI Documentation**: `references/vibe-kanban/docs/agents/github-copilot.mdx`\n- **GitHub Copilot CLI Docs**: https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli\n- **MCP Configuration**: `~/.copilot/mcp-config.json`\n\n## Authentication Setup\n\nBefore using GitHub Copilot CLI, users must authenticate:\n\n```bash\n# Run Copilot CLI\nnpx -y @github/copilot\n\n# When prompted, run login command\n/login\n\n# Follow the on-screen instructions to authenticate via GitHub\n```\n\n**Availability Check**:\n```typescript\nasync checkAvailability(): Promise<boolean> {\n  const mcpConfigPath = this.getDefaultMcpConfigPath();\n  if (!mcpConfigPath) return false;\n\n  try {\n    await fs.access(mcpConfigPath);\n    return true; // Config exists = user is authenticated\n  } catch {\n    return false;\n  }\n}\n```","priority":2,"archived":0,"archived_at":null,"created_at":"2025-11-20 18:37:47","updated_at":"2025-11-20 18:37:47","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["agent-executor","copilot","github","mcp","plain-text"]}
{"id":"s-8e3w","uuid":"44c84b0e-d50c-42a1-9c1a-06be60152578","title":"Standardized Metadata Across All Agents","file_path":"specs/standardized_metadata_across_all_agents.md","content":"# Standardized Metadata Across All Agents\n\n## Overview\n\nAll agent executors should expose consistent metadata in `NormalizedEntry.metadata` following a standardized format. This enables:\n- Session resumption across agents\n- Model tracking for observability\n- Consistent API for library consumers\n- Future extensibility\n\n## Requirements\n\n### 1. Metadata Interface\n\nAll agents must implement `NormalizedEntryMetadata`:\n\n```typescript\ninterface NormalizedEntryMetadata {\n  sessionId?: string | null;  // Session identifier for resumption\n  model?: string | null;       // AI model name\n  [key: string]: unknown;      // Agent-specific extensions\n}\n```\n\n### 2. Metadata on All Entry Types\n\nMetadata must be included on:\n- System messages\n- User messages\n- Assistant messages (including streaming chunks)\n- Tool use messages (started and completed)\n- Error messages\n- Any agent-specific message types (e.g., thinking)\n\n### 3. Metadata Behavior\n\n**Capture**: Extract `sessionId` and `model` from first system message\n**Propagate**: Include metadata on all subsequent entries\n**Graceful Degradation**: Return `undefined` if no metadata available (e.g., before system message)\n**No Null Values**: Only include fields that have values (don't include `null` fields)\n\n### 4. Agent-Specific Extensions\n\nAgents may add custom fields:\n- Cursor: `permissionMode`\n- Future: MCP server status, custom configuration, etc.\n\n## Implementation Status\n\n| Agent | sessionId | model | All Entry Types | Status |\n|-------|-----------|-------|-----------------|--------|\n| Claude Code | ✅ | ✅ | ✅ | Complete |\n| Cursor | ✅ | ✅ | ✅ | Complete |\n| Copilot | ⚠️ Partial | ❌ | ❌ | Needs work |\n| Codex | ❓ Unknown | ❓ Unknown | ❌ | Needs research |\n\n## Reference Implementations\n\n**Claude Code** (`src/agents/claude/normalizer.ts`):\n- Tracks sessionId and model in state\n- Provides metadata on all entries\n- Test coverage: 7 comprehensive tests\n\n**Cursor** (`src/agents/cursor/normalizer/state.ts`):\n- Tracks sessionId, model, and permissionMode\n- Provides metadata on all entries including thinking\n- Test coverage: 7 comprehensive tests\n\n## Testing Requirements\n\nAll implementations must include:\n\n1. **Unit Tests**:\n   - Metadata in system messages\n   - Metadata propagation to all entry types\n   - Streaming/coalescing scenarios\n   - Edge cases (no system message, partial metadata)\n\n2. **Integration Tests**:\n   - End-to-end workflow with metadata preservation\n   - Session resumption (if supported)\n\n## Documentation\n\n- **Spec**: `src/agents/types/agent-executor.ts`\n- **Guide**: `docs/METADATA.md`\n- **Roadmap**: `METADATA_ROADMAP.md`\n\n## Success Criteria\n\n- [ ] All agents have consistent metadata structure\n- [ ] SessionId available for session resumption (or documented as unsupported)\n- [ ] Model information exposed (or documented as unavailable)\n- [ ] 100% test coverage for metadata code paths\n- [ ] Documentation complete for all agents\n- [ ] Zero breaking changes to existing APIs\n","priority":1,"archived":0,"archived_at":null,"created_at":"2025-11-25 09:48:18","updated_at":"2025-11-25 09:48:18","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["agents","api","metadata","standardization"]}
{"id":"s-5trg","uuid":"9f3a5b41-6aa1-48d3-a609-93f6b05996ad","title":"Claude Code SDK Integration","file_path":"/Users/alexngai/GitHub/agent-execution-engine/.sudocode/specs/s-5trg.md","content":"# Claude Agent SDK Integration for Mid-Execution Messaging\n\n## Overview\n\nAdd support for sending additional messages to running Claude Code agents. This enables mid-execution guidance where users can provide context or instructions while Claude is actively working on a task.\n\n## Current State\n\nThe execution engine has partial infrastructure:\n- `ProtocolPeer` already supports `sendUserMessage()` via `--input-format stream-json`\n- `ClaudeCodeExecutor` attaches peer to process but doesn't expose it\n- No interface-level support for mid-execution messaging\n\n## Goal\n\nEnable callers to:\n1. Start a task: `const session = await executor.executeTask(task)`\n2. Send mid-execution messages: `await session.sendMessage(\"also add tests\")`\n3. Interrupt if needed: `await session.interrupt()`\n\n## Implementation Options\n\n### Option A: Expose Existing ProtocolPeer (Recommended - Lower Risk)\n\nLeverage existing `ProtocolPeer` infrastructure by exposing it through interfaces.\n\n**Pros:**\n- Minimal changes to existing code\n- Already tested bidirectional protocol\n- No new dependencies\n\n**Cons:**\n- Still uses CLI process spawning (not SDK)\n- Less future-proof than SDK approach\n\n### Option B: TypeScript SDK Integration (Higher Effort)\n\nReplace CLI spawning with `@anthropic-ai/claude-agent-sdk`:\n\n```typescript\nimport { query } from '@anthropic-ai/claude-agent-sdk';\n\nconst result = query({\n  prompt: async function* () {\n    yield initialMessage;\n    while (hasMoreInput) {\n      yield await getNextMessage();\n    }\n  }(),\n  options: { workDir, ... }\n});\n```\n\n**Pros:**\n- Official SDK support\n- Native streaming input\n- `interrupt()` method built-in\n\n**Cons:**\n- New dependency\n- More significant refactor\n- SDK may have different behavior\n\n## Recommended Approach: Hybrid\n\n**Phase 1**: Expose existing `ProtocolPeer` capabilities (Option A)\n**Phase 2**: Add SDK as alternative implementation (Option B)\n\n---\n\n## Phase 1: Interface Changes\n\n### 1. Extend `IAgentExecutor` Interface\n\nAdd optional mid-execution methods:\n\n```typescript\n// src/agents/types/agent-executor.ts\n\nexport interface IAgentExecutor {\n  // Existing methods...\n  executeTask(task: ExecutionTask): Promise<SpawnedChild>;\n  resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>;\n\n  // NEW: Mid-execution messaging\n  /**\n   * Send an additional message to a running task\n   *\n   * @param process - The spawned process from executeTask()\n   * @param message - Message content to send\n   * @returns Promise that resolves when message is sent\n   * @throws Error if agent doesn't support mid-execution messaging\n   */\n  sendMessage?(process: ManagedProcess, message: string): Promise<void>;\n\n  /**\n   * Interrupt a running task\n   *\n   * @param process - The spawned process to interrupt\n   * @returns Promise that resolves when interrupt is processed\n   */\n  interrupt?(process: ManagedProcess): Promise<void>;\n}\n\n// Update AgentCapabilities\nexport interface AgentCapabilities {\n  // Existing...\n  supportsSessionResume: boolean;\n  requiresSetup: boolean;\n  supportsApprovals: boolean;\n  supportsMcp: boolean;\n  protocol: ProtocolType;\n\n  // NEW\n  /**\n   * Whether the agent supports sending messages mid-execution\n   */\n  supportsMidExecutionMessages: boolean;\n}\n```\n\n### 2. Implement in ClaudeCodeExecutor\n\n```typescript\n// src/agents/claude/executor.ts\n\nexport class ClaudeCodeExecutor extends BaseAgentExecutor {\n  // Existing implementation...\n\n  /**\n   * Send a message to a running Claude process\n   */\n  async sendMessage(process: ManagedProcess, message: string): Promise<void> {\n    const claudeProcess = process as ClaudeManagedProcess;\n    if (!claudeProcess.peer) {\n      throw new Error('Process does not have protocol peer attached');\n    }\n\n    await claudeProcess.peer.sendUserMessage(message);\n  }\n\n  /**\n   * Interrupt a running Claude process\n   */\n  async interrupt(process: ManagedProcess): Promise<void> {\n    const claudeProcess = process as ClaudeManagedProcess;\n    if (claudeProcess.peer) {\n      await claudeProcess.peer.sendInterrupt();\n    } else {\n      process.process?.kill('SIGINT');\n    }\n  }\n\n  getCapabilities(): AgentCapabilities {\n    return {\n      supportsSessionResume: true,\n      requiresSetup: false,\n      supportsApprovals: true,\n      supportsMcp: true,\n      protocol: 'stream-json',\n      supportsMidExecutionMessages: true,  // NEW\n    };\n  }\n}\n```\n\n### 3. Add Interrupt to ProtocolPeer\n\n```typescript\n// src/agents/claude/protocol/protocol-peer.ts\n\nexport class ProtocolPeer {\n  /**\n   * Send interrupt signal to Claude CLI\n   */\n  async sendInterrupt(): Promise<void> {\n    const request: ControlMessage = {\n      type: 'control',\n      control: { type: 'interrupt' },\n    };\n    await this.writeMessage(request);\n  }\n}\n```\n\n### 4. Higher-Level Session Abstraction\n\n```typescript\n// src/agents/claude/session.ts\n\nexport class ClaudeSession {\n  private executor: ClaudeCodeExecutor;\n  private process: ManagedProcess | null = null;\n\n  constructor(config: ClaudeCodeConfig) {\n    this.executor = new ClaudeCodeExecutor(config);\n  }\n\n  async start(prompt: string, workDir: string): Promise<void> {\n    const task = createTask(prompt, workDir);\n    const spawned = await this.executor.executeTask(task);\n    this.process = spawned.process;\n  }\n\n  async sendMessage(message: string): Promise<void> {\n    if (!this.process) throw new Error('Session not started');\n    await this.executor.sendMessage(this.process, message);\n  }\n\n  async interrupt(): Promise<void> {\n    if (!this.process) throw new Error('Session not started');\n    await this.executor.interrupt(this.process);\n  }\n\n  async close(): Promise<void> {\n    if (this.process) {\n      await this.executor.interrupt(this.process);\n      this.process = null;\n    }\n  }\n}\n\n// Usage:\nconst session = new ClaudeSession({ workDir: '/project' });\nawait session.start('Build a login feature');\n\n// Later, mid-execution:\nawait session.sendMessage('Also add password validation');\n\nawait session.close();\n```\n\n---\n\n## Phase 2: SDK Integration (Future)\n\nAdd SDK as alternative implementation:\n\n```typescript\n// src/agents/claude/sdk-executor.ts\n\nimport { query } from '@anthropic-ai/claude-agent-sdk';\n\nexport class ClaudeSDKExecutor extends BaseAgentExecutor {\n  private messageQueue: AsyncQueue<SDKUserMessage>;\n\n  async executeTask(task: ExecutionTask): Promise<SpawnedChild> {\n    this.messageQueue = new AsyncQueue();\n    this.messageQueue.push(createUserMessage(task.prompt));\n\n    const queryResult = query({\n      prompt: this.messageQueue,\n      options: { workDir: task.workDir }\n    });\n\n    return { process: this.wrapQueryAsProcess(queryResult) };\n  }\n\n  async sendMessage(process: ManagedProcess, message: string): Promise<void> {\n    this.messageQueue.push(createUserMessage(message));\n  }\n\n  async interrupt(process: ManagedProcess): Promise<void> {\n    await (process as SDKManagedProcess).queryResult.interrupt();\n  }\n}\n```\n\n---\n\n## Files to Modify\n\n### Phase 1\n\n| File | Changes |\n|------|---------|\n| `src/agents/types/agent-executor.ts` | Add `sendMessage`, `interrupt`, `supportsMidExecutionMessages` |\n| `src/agents/claude/executor.ts` | Implement new methods |\n| `src/agents/claude/protocol/protocol-peer.ts` | Add `sendInterrupt()` |\n| `src/agents/claude/session.ts` | NEW: High-level session wrapper |\n| `src/agents/claude/index.ts` | Export new types |\n\n### Phase 2\n\n| File | Changes |\n|------|---------|\n| `package.json` | Add `@anthropic-ai/claude-agent-sdk` |\n| `src/agents/claude/sdk-executor.ts` | NEW: SDK-based implementation |\n\n---\n\n## Backwards Compatibility\n\n- All existing interfaces remain unchanged\n- New methods are optional (`sendMessage?`, `interrupt?`)\n- Capabilities declare support via `supportsMidExecutionMessages`\n- Existing code continues to work without modification\n\n---\n\n## Open Questions\n\n1. **Interrupt semantics**: Should interrupt cancel the current tool operation or the entire task?\n2. **Message ordering**: How to handle messages sent while Claude is still processing?\n3. **Session persistence**: Should mid-execution messages be part of session history for `--resume`?\n\n---\n\n## Success Criteria\n\n- [ ] Can send additional messages to running Claude process\n- [ ] Can interrupt a running task\n- [ ] Capabilities correctly advertise support\n- [ ] Backwards compatible with existing code\n- [ ] Unit and integration tests pass\n","priority":3,"archived":0,"archived_at":null,"created_at":"2025-12-06 10:14:44","updated_at":"2025-12-06 10:15:04","parent_id":null,"parent_uuid":null,"relationships":[],"tags":[]}
{"id":"s-1t3x","uuid":"1de326a0-582d-4548-8c60-03508228bdef","title":"Agent Client Protocol (ACP) Integration - Alternative Interface Layer","file_path":"specs/s-1t3x_agent_client_protocol_acp_integration_alternative_.md","content":"# Agent Client Protocol (ACP) Integration - Alternative Interface Layer\n\n## Overview\n\nThis spec defines an **alternative interface layer** for agents that support the Agent Client Protocol (ACP). Rather than replacing the existing `IAgentAdapter` interface, this creates a parallel `IAcpAgent` interface that coexists alongside CLI-based adapters.\n\n**Key Design Decision**: ACP is a fundamentally different paradigm from CLI execution - it uses JSON-RPC 2.0 over NDJSON streams with bidirectional communication, explicit session management, and structured capability negotiation. Rather than shoehorning this into the CLI-focused `IAgentAdapter`, we expose ACP as a first-class protocol.\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                       Consumer Code                                     │\n├─────────────────────────────────────────────────────────────────────────┤\n│                     Unified Agent Interface                              │\n│  ┌──────────────────────────────────────────────────────────────────┐   │\n│  │                    IUnifiedAgentExecutor                         │   │\n│  │  - executeTask(task) → Promise<ExecutionHandle>                  │   │\n│  │  - getCapabilities() → UnifiedCapabilities                       │   │\n│  └──────────────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────────────┤\n│              Protocol-Specific Executors                                │\n│  ┌─────────────────────────┐     ┌─────────────────────────┐           │\n│  │   CLI Executor          │     │   ACP Executor          │           │\n│  │   (IAgentExecutor)      │     │   (IAcpExecutor)        │           │\n│  │   - stream-json         │     │   - JSON-RPC 2.0        │           │\n│  │   - jsonl               │     │   - NDJSON stream       │           │\n│  │   - jsonrpc             │     │   - Bidirectional       │           │\n│  └─────────────────────────┘     └─────────────────────────┘           │\n├─────────────────────────────────────────────────────────────────────────┤\n│              Agent Implementations                                       │\n│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │\n│  │ Claude   │ │ Cursor   │ │ Codex    │ │ Gemini   │ │ Custom   │      │\n│  │ (both)   │ │ (CLI)    │ │ (CLI)    │ │ (ACP)    │ │ (either) │      │\n│  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n## Core Interfaces\n\n### R1: IAcpAgent Interface\n\n**Description**: Core interface for ACP-compatible agents. Mirrors the ACP SDK's `Agent` interface but with TypeScript-native patterns.\n\n```typescript\n// src/agents/acp/types.ts\n\nimport type { Stream } from '@agentclientprotocol/sdk';\n\n/**\n * ACP Agent Interface\n * \n * Implements the Agent Client Protocol for bidirectional communication.\n * Agents implementing this interface can be used with ACP-compatible clients\n * like Zed, VS Code extensions, or the execution engine's ACP executor.\n */\nexport interface IAcpAgent {\n  /**\n   * Initialize the ACP connection\n   * \n   * Called once when the connection is established. Used to negotiate\n   * protocol version and exchange capabilities.\n   */\n  initialize(params: AcpInitializeRequest): Promise<AcpInitializeResponse>;\n\n  /**\n   * Create a new conversation session\n   * \n   * Sessions maintain conversation state and can be resumed later\n   * (if the agent supports it).\n   */\n  newSession(params: AcpNewSessionRequest): Promise<AcpNewSessionResponse>;\n\n  /**\n   * Load/resume a previous session\n   * \n   * Optional - only required if agent declares loadSession capability.\n   */\n  loadSession?(params: AcpLoadSessionRequest): Promise<AcpLoadSessionResponse>;\n\n  /**\n   * Send a prompt to the agent\n   * \n   * The main entry point for user messages. Returns when the agent\n   * has finished processing (end of turn).\n   */\n  prompt(params: AcpPromptRequest): Promise<AcpPromptResponse>;\n\n  /**\n   * Cancel the current prompt processing\n   * \n   * Signals the agent to stop processing and return early.\n   */\n  cancel(params: AcpCancelNotification): Promise<void>;\n\n  /**\n   * Set the session mode (optional)\n   * \n   * Modes control agent behavior (e.g., \"plan\", \"architect\", \"default\").\n   */\n  setSessionMode?(params: AcpSetModeRequest): Promise<AcpSetModeResponse | void>;\n\n  /**\n   * Set the model for the session (optional)\n   */\n  setSessionModel?(params: AcpSetModelRequest): Promise<AcpSetModelResponse | void>;\n\n  /**\n   * Authenticate with the agent (optional)\n   */\n  authenticate?(params: AcpAuthenticateRequest): Promise<AcpAuthenticateResponse | void>;\n}\n\n/**\n * ACP Client Interface\n * \n * Callbacks that the execution engine must implement to handle\n * agent requests (file I/O, terminals, permissions).\n */\nexport interface IAcpClient {\n  /**\n   * Receive session updates (streaming output)\n   * \n   * Called by the agent to stream message chunks, tool calls,\n   * plans, and other real-time updates.\n   */\n  sessionUpdate(params: AcpSessionNotification): Promise<void>;\n\n  /**\n   * Handle permission requests\n   * \n   * Called when the agent needs approval for a tool use.\n   * The client must respond with the user's decision.\n   */\n  requestPermission(params: AcpRequestPermissionRequest): Promise<AcpRequestPermissionResponse>;\n\n  /**\n   * Read a text file from the workspace (optional)\n   */\n  readTextFile?(params: AcpReadTextFileRequest): Promise<AcpReadTextFileResponse>;\n\n  /**\n   * Write a text file to the workspace (optional)\n   */\n  writeTextFile?(params: AcpWriteTextFileRequest): Promise<AcpWriteTextFileResponse>;\n\n  /**\n   * Create a terminal for command execution (optional)\n   */\n  createTerminal?(params: AcpCreateTerminalRequest): Promise<AcpTerminalHandle>;\n}\n```\n\n### R2: ACP Type Definitions\n\n**Description**: TypeScript types mirroring the ACP protocol schema.\n\n```typescript\n// src/agents/acp/types.ts (continued)\n\n// ============================================\n// Initialize\n// ============================================\n\nexport interface AcpInitializeRequest {\n  protocolVersion: number;\n  clientCapabilities: AcpClientCapabilities;\n}\n\nexport interface AcpInitializeResponse {\n  protocolVersion: number;\n  agentCapabilities: AcpAgentCapabilities;\n  agentInfo: AcpAgentInfo;\n  authMethods?: AcpAuthMethod[];\n}\n\nexport interface AcpClientCapabilities {\n  fs?: {\n    readTextFile: boolean;\n    writeTextFile: boolean;\n  };\n  terminal?: boolean;\n  mcp?: {\n    serverDefinitions: boolean;\n    client: boolean;\n  };\n}\n\nexport interface AcpAgentCapabilities {\n  loadSession?: boolean;\n  mcpCapabilities?: {\n    http: boolean;\n    sse: boolean;\n    stdio: boolean;\n  };\n  promptCapabilities?: {\n    image: boolean;\n    embeddedContext: boolean;\n    audio: boolean;\n  };\n  sessionCapabilities?: {\n    modes: boolean;\n    models: boolean;\n  };\n}\n\nexport interface AcpAgentInfo {\n  name: string;\n  version: string;\n}\n\n// ============================================\n// Session Management\n// ============================================\n\nexport interface AcpNewSessionRequest {\n  cwd: string;\n  mcpServers?: AcpMcpServerConfig[];\n  _meta?: Record<string, unknown>;\n}\n\nexport interface AcpNewSessionResponse {\n  sessionId: string;\n  models: AcpSessionModelState;\n  modes: AcpSessionModes;\n}\n\nexport interface AcpLoadSessionRequest {\n  sessionId: string;\n  cwd: string;\n}\n\nexport interface AcpLoadSessionResponse {\n  sessionId: string;\n  models: AcpSessionModelState;\n  modes: AcpSessionModes;\n}\n\nexport interface AcpSessionModelState {\n  available: AcpModelInfo[];\n  current: string;\n}\n\nexport interface AcpModelInfo {\n  id: string;\n  displayName: string;\n}\n\nexport interface AcpSessionModes {\n  available: AcpModeInfo[];\n  current: string;\n}\n\nexport interface AcpModeInfo {\n  id: string;\n  displayName: string;\n  description?: string;\n}\n\n// ============================================\n// Prompt\n// ============================================\n\nexport interface AcpPromptRequest {\n  sessionId: string;\n  prompt: AcpPromptContent[];\n}\n\nexport type AcpPromptContent =\n  | { type: 'text'; text: string }\n  | { type: 'image'; uri?: string; data?: string; mimeType: string }\n  | { type: 'resource'; resource: AcpResource };\n\nexport interface AcpResource {\n  uri: string;\n  text?: string;\n  blob?: string;\n  mimeType?: string;\n}\n\nexport interface AcpPromptResponse {\n  stopReason: 'end_turn' | 'max_turn_requests' | 'cancelled';\n}\n\nexport interface AcpCancelNotification {\n  sessionId: string;\n}\n\n// ============================================\n// Session Updates (Agent → Client)\n// ============================================\n\nexport interface AcpSessionNotification {\n  sessionId: string;\n  update: AcpSessionUpdate;\n}\n\nexport type AcpSessionUpdate =\n  | { sessionUpdate: 'agent_message_chunk'; content: AcpMessageContent }\n  | { sessionUpdate: 'user_message_chunk'; content: AcpMessageContent }\n  | { sessionUpdate: 'agent_thought_chunk'; content: AcpMessageContent }\n  | { sessionUpdate: 'tool_call'; toolCallId: string; status: AcpToolStatus; title: string; kind: AcpToolKind; rawInput?: unknown; locations?: AcpLocation[] }\n  | { sessionUpdate: 'tool_call_update'; toolCallId: string; status?: AcpToolStatus; content?: AcpToolContent[]; rawOutput?: unknown }\n  | { sessionUpdate: 'plan'; entries: AcpPlanEntry[] }\n  | { sessionUpdate: 'current_mode_update'; currentModeId: string }\n  | { sessionUpdate: 'available_commands_update'; availableCommands: AcpCommand[] };\n\nexport type AcpMessageContent =\n  | { type: 'text'; text: string }\n  | { type: 'image'; source: AcpImageSource };\n\nexport type AcpToolStatus = 'pending' | 'in_progress' | 'completed' | 'failed';\n\nexport type AcpToolKind = 'read' | 'edit' | 'execute' | 'delete' | 'search' | 'fetch' | 'think' | 'mcp' | 'other';\n\nexport interface AcpLocation {\n  path: string;\n  startLine?: number;\n  endLine?: number;\n}\n\nexport type AcpToolContent =\n  | { type: 'text'; text: string }\n  | { type: 'diff'; path: string; oldText?: string; newText: string };\n\nexport interface AcpPlanEntry {\n  id: string;\n  content: string;\n  status: 'pending' | 'in_progress' | 'completed';\n}\n\nexport interface AcpCommand {\n  name: string;\n  description?: string;\n}\n\n// ============================================\n// Permissions\n// ============================================\n\nexport interface AcpRequestPermissionRequest {\n  sessionId: string;\n  toolCall: {\n    toolCallId: string;\n    title: string;\n    rawInput?: unknown;\n  };\n  options: AcpPermissionOption[];\n}\n\nexport interface AcpPermissionOption {\n  optionId: string;\n  name: string;\n  kind: 'allow_always' | 'allow_once' | 'reject_once' | 'reject_always';\n}\n\nexport interface AcpRequestPermissionResponse {\n  outcome?: {\n    optionId: string;\n  };\n}\n\n// ============================================\n// File System\n// ============================================\n\nexport interface AcpReadTextFileRequest {\n  path: string;\n}\n\nexport interface AcpReadTextFileResponse {\n  content: string;\n}\n\nexport interface AcpWriteTextFileRequest {\n  path: string;\n  content: string;\n}\n\nexport interface AcpWriteTextFileResponse {\n  success: boolean;\n}\n\n// ============================================\n// Terminal\n// ============================================\n\nexport interface AcpCreateTerminalRequest {\n  command: string;\n  args?: string[];\n  cwd?: string;\n  env?: Record<string, string>;\n}\n\nexport interface AcpTerminalHandle {\n  id: string;\n  currentOutput(): Promise<AcpTerminalOutputResponse>;\n  waitForExit(): Promise<AcpWaitForExitResponse>;\n  kill(): Promise<void>;\n  release(): Promise<void>;\n}\n\nexport interface AcpTerminalOutputResponse {\n  output: string;\n}\n\nexport interface AcpWaitForExitResponse {\n  exitCode: number;\n}\n\n// ============================================\n// Mode/Model\n// ============================================\n\nexport interface AcpSetModeRequest {\n  sessionId: string;\n  modeId: string;\n}\n\nexport interface AcpSetModeResponse {}\n\nexport interface AcpSetModelRequest {\n  sessionId: string;\n  modelId: string;\n}\n\nexport interface AcpSetModelResponse {}\n\n// ============================================\n// Authentication\n// ============================================\n\nexport interface AcpAuthMethod {\n  id: string;\n  displayName: string;\n}\n\nexport interface AcpAuthenticateRequest {\n  methodId: string;\n  credentials?: Record<string, unknown>;\n}\n\nexport interface AcpAuthenticateResponse {\n  success: boolean;\n  error?: string;\n}\n\n// ============================================\n// MCP Server Configuration\n// ============================================\n\nexport interface AcpMcpServerConfig {\n  name: string;\n  transport: 'stdio' | 'http' | 'sse';\n  command?: string;\n  args?: string[];\n  url?: string;\n  env?: Record<string, string>;\n}\n```\n\n### R3: IAcpExecutor Interface\n\n**Description**: Executor interface for running ACP agents. Provides a higher-level API than raw ACP protocol.\n\n```typescript\n// src/agents/acp/executor.ts\n\nimport type { IAcpAgent, IAcpClient, AcpSessionNotification, AcpPromptContent } from './types.js';\nimport type { NormalizedEntry, AgentCapabilities } from '../types/agent-executor.js';\n\n/**\n * ACP Session handle\n * \n * Represents an active session with an ACP agent. Provides methods\n * for sending prompts and receiving updates.\n */\nexport interface AcpSession {\n  /** Session ID */\n  readonly sessionId: string;\n\n  /** Available modes for this session */\n  readonly modes: { id: string; displayName: string }[];\n\n  /** Current mode */\n  readonly currentMode: string;\n\n  /** Available models */\n  readonly models: { id: string; displayName: string }[];\n\n  /** Current model */\n  readonly currentModel: string;\n\n  /**\n   * Send a prompt and get streaming updates\n   * \n   * @param content - Prompt content (text, images, resources)\n   * @returns AsyncIterable of session updates\n   */\n  prompt(content: AcpPromptContent[]): AsyncIterable<AcpSessionNotification>;\n\n  /**\n   * Send a text prompt (convenience method)\n   */\n  promptText(text: string): AsyncIterable<AcpSessionNotification>;\n\n  /**\n   * Cancel the current prompt\n   */\n  cancel(): Promise<void>;\n\n  /**\n   * Change the session mode\n   */\n  setMode(modeId: string): Promise<void>;\n\n  /**\n   * Change the model\n   */\n  setModel(modelId: string): Promise<void>;\n\n  /**\n   * Close the session\n   */\n  close(): Promise<void>;\n}\n\n/**\n * ACP Executor Configuration\n */\nexport interface AcpExecutorConfig {\n  /** Working directory for the agent */\n  workDir: string;\n\n  /** Permission handling mode */\n  permissionMode?: 'auto_approve' | 'auto_deny' | 'interactive';\n\n  /** Approval service for interactive mode */\n  approvalService?: IApprovalService;\n\n  /** MCP servers to connect */\n  mcpServers?: AcpMcpServerConfig[];\n\n  /** Custom client implementation (for advanced use) */\n  customClient?: Partial<IAcpClient>;\n}\n\n/**\n * ACP Executor Interface\n * \n * High-level interface for executing tasks with ACP agents.\n * Handles connection management, session lifecycle, and output normalization.\n */\nexport interface IAcpExecutor {\n  /**\n   * Connect to an ACP agent and create a session\n   * \n   * @param config - Executor configuration\n   * @returns Active session handle\n   */\n  connect(config: AcpExecutorConfig): Promise<AcpSession>;\n\n  /**\n   * Resume an existing session\n   * \n   * @param sessionId - Session ID to resume\n   * @param config - Executor configuration\n   * @returns Resumed session handle\n   */\n  resume(sessionId: string, config: AcpExecutorConfig): Promise<AcpSession>;\n\n  /**\n   * Get agent capabilities\n   */\n  getCapabilities(): AcpAgentCapabilities;\n\n  /**\n   * Get agent info (name, version)\n   */\n  getAgentInfo(): AcpAgentInfo;\n\n  /**\n   * Normalize ACP session updates to unified format\n   * \n   * Converts AcpSessionNotification stream to NormalizedEntry stream\n   * for consistent UI rendering.\n   */\n  normalizeUpdates(\n    updates: AsyncIterable<AcpSessionNotification>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry>;\n\n  /**\n   * Shutdown the executor and close all connections\n   */\n  shutdown(): Promise<void>;\n}\n```\n\n### R4: AcpConnection Class\n\n**Description**: Low-level connection handler for ACP protocol. Wraps the ACP SDK's connection classes.\n\n```typescript\n// src/agents/acp/connection.ts\n\nimport { AgentSideConnection, ClientSideConnection, ndJsonStream } from '@agentclientprotocol/sdk';\nimport type { Stream } from '@agentclientprotocol/sdk';\nimport type { IAcpAgent, IAcpClient } from './types.js';\nimport type { ChildProcess } from 'child_process';\nimport { spawn } from 'child_process';\nimport { Readable, Writable } from 'stream';\n\n/**\n * Connection mode\n */\nexport type AcpConnectionMode = \n  | 'agent_side'   // We are the agent (exposing IAcpAgent)\n  | 'client_side'; // We are the client (talking to an agent)\n\n/**\n * ACP Connection options\n */\nexport interface AcpConnectionOptions {\n  /** Connection mode */\n  mode: AcpConnectionMode;\n\n  /** For agent_side: The agent implementation to expose */\n  agent?: IAcpAgent;\n\n  /** For client_side: The client callbacks to handle agent requests */\n  client?: IAcpClient;\n\n  /** Stream to use (if not spawning a process) */\n  stream?: Stream;\n}\n\n/**\n * Spawn options for creating an ACP connection to a CLI agent\n */\nexport interface AcpSpawnOptions {\n  /** Executable path */\n  executable: string;\n\n  /** Command line arguments */\n  args: string[];\n\n  /** Working directory */\n  cwd: string;\n\n  /** Environment variables */\n  env?: Record<string, string>;\n\n  /** Client implementation for handling agent requests */\n  client: IAcpClient;\n}\n\n/**\n * ACP Connection\n * \n * Manages the low-level JSON-RPC connection over NDJSON streams.\n * Can operate in agent_side mode (we are the agent) or client_side mode\n * (we are talking to an agent).\n */\nexport class AcpConnection {\n  private connection: AgentSideConnection | ClientSideConnection;\n  private process?: ChildProcess;\n  private abortController: AbortController;\n\n  private constructor(\n    connection: AgentSideConnection | ClientSideConnection,\n    process?: ChildProcess\n  ) {\n    this.connection = connection;\n    this.process = process;\n    this.abortController = new AbortController();\n  }\n\n  /**\n   * Create a client-side connection by spawning an ACP-compatible CLI agent\n   * \n   * @param options - Spawn options\n   * @returns Connection to the agent\n   */\n  static async spawn(options: AcpSpawnOptions): Promise<AcpConnection> {\n    const child = spawn(options.executable, options.args, {\n      cwd: options.cwd,\n      env: { ...process.env, ...options.env },\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n\n    // Create NDJSON stream from process stdio\n    const stream = ndJsonStream(\n      nodeWritableToWebWritable(child.stdin!),\n      nodeReadableToWebReadable(child.stdout!)\n    );\n\n    // Create client-side connection\n    const connection = new ClientSideConnection(\n      (agent) => options.client, // We provide the client implementation\n      stream\n    );\n\n    return new AcpConnection(connection, child);\n  }\n\n  /**\n   * Create a connection from existing streams\n   * \n   * Useful for testing or non-process-based agents.\n   */\n  static fromStream(options: AcpConnectionOptions): AcpConnection {\n    if (!options.stream) {\n      throw new Error('Stream is required');\n    }\n\n    if (options.mode === 'agent_side') {\n      if (!options.agent) throw new Error('Agent implementation required for agent_side mode');\n      const connection = new AgentSideConnection(\n        (client) => options.agent!,\n        options.stream\n      );\n      return new AcpConnection(connection);\n    } else {\n      if (!options.client) throw new Error('Client implementation required for client_side mode');\n      const connection = new ClientSideConnection(\n        (agent) => options.client!,\n        options.stream\n      );\n      return new AcpConnection(connection);\n    }\n  }\n\n  /**\n   * Get the underlying connection (for direct protocol access)\n   */\n  getConnection(): AgentSideConnection | ClientSideConnection {\n    return this.connection;\n  }\n\n  /**\n   * Get the underlying process (if spawned)\n   */\n  getProcess(): ChildProcess | undefined {\n    return this.process;\n  }\n\n  /**\n   * Get abort signal for cancellation\n   */\n  get signal(): AbortSignal {\n    return this.abortController.signal;\n  }\n\n  /**\n   * Check if connection is closed\n   */\n  get isClosed(): boolean {\n    return this.abortController.signal.aborted;\n  }\n\n  /**\n   * Close the connection\n   */\n  async close(): Promise<void> {\n    this.abortController.abort();\n    \n    if (this.process) {\n      this.process.kill();\n      await new Promise<void>((resolve) => {\n        this.process!.on('exit', () => resolve());\n        setTimeout(resolve, 5000); // Timeout after 5s\n      });\n    }\n  }\n}\n\n// Helper functions for stream conversion\nfunction nodeReadableToWebReadable(readable: Readable): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      readable.on('data', (chunk) => {\n        controller.enqueue(chunk instanceof Buffer ? chunk : Buffer.from(chunk));\n      });\n      readable.on('end', () => controller.close());\n      readable.on('error', (err) => controller.error(err));\n    },\n    cancel() {\n      readable.destroy();\n    },\n  });\n}\n\nfunction nodeWritableToWebWritable(writable: Writable): WritableStream<Uint8Array> {\n  return new WritableStream({\n    write(chunk) {\n      return new Promise((resolve, reject) => {\n        writable.write(chunk, (err) => {\n          if (err) reject(err);\n          else resolve();\n        });\n      });\n    },\n    close() {\n      return new Promise((resolve) => {\n        writable.end(() => resolve());\n      });\n    },\n    abort(reason) {\n      writable.destroy(reason instanceof Error ? reason : new Error(String(reason)));\n    },\n  });\n}\n```\n\n### R5: AcpAgentAdapter Interface\n\n**Description**: Bridge interface for agents that support both CLI and ACP modes.\n\n```typescript\n// src/agents/acp/adapter.ts\n\nimport type { IAgentAdapter, BaseAgentConfig, AgentMetadata } from '../types/agent-adapter.js';\nimport type { IAcpAgent, AcpAgentCapabilities } from './types.js';\nimport type { ProcessConfig } from '../../process/types.js';\n\n/**\n * Extended agent config for ACP-capable agents\n */\nexport interface AcpAgentConfig extends BaseAgentConfig {\n  /** Prefer ACP protocol when available */\n  preferAcp?: boolean;\n\n  /** ACP-specific arguments to pass to CLI */\n  acpArgs?: string[];\n}\n\n/**\n * ACP Agent Adapter Interface\n * \n * Extends IAgentAdapter to add ACP support. Agents can implement this\n * interface to support both CLI and ACP modes.\n */\nexport interface IAcpAgentAdapter<TConfig extends AcpAgentConfig = AcpAgentConfig> \n  extends IAgentAdapter<TConfig> {\n  \n  /**\n   * Whether this agent supports ACP protocol\n   */\n  readonly supportsAcp: boolean;\n\n  /**\n   * ACP capabilities (if supported)\n   */\n  readonly acpCapabilities?: AcpAgentCapabilities;\n\n  /**\n   * Build ProcessConfig for ACP mode\n   * \n   * Returns the CLI arguments needed to start the agent in ACP mode.\n   * For example, Gemini CLI uses `--experimental-acp`.\n   */\n  buildAcpProcessConfig?(config: TConfig): ProcessConfig;\n\n  /**\n   * Create an ACP agent wrapper for SDK-based agents\n   * \n   * Some agents (like Claude Code) have native SDK support that implements\n   * IAcpAgent directly. This method returns such a wrapper if available.\n   */\n  createAcpAgent?(config: TConfig): IAcpAgent | null;\n\n  /**\n   * Check if ACP mode is available\n   * \n   * Some agents may have ACP support as an experimental flag or\n   * require specific versions.\n   */\n  checkAcpAvailability?(): Promise<boolean>;\n}\n\n/**\n * Type guard for ACP-capable adapters\n */\nexport function isAcpCapableAdapter(\n  adapter: IAgentAdapter\n): adapter is IAcpAgentAdapter {\n  return 'supportsAcp' in adapter && (adapter as IAcpAgentAdapter).supportsAcp;\n}\n```\n\n### R6: Unified Agent Interface\n\n**Description**: High-level interface that unifies CLI and ACP execution patterns.\n\n```typescript\n// src/agents/unified/types.ts\n\nimport type { ExecutionTask } from '../../engine/types.js';\nimport type { NormalizedEntry, AgentCapabilities } from '../types/agent-executor.js';\nimport type { AcpSession, AcpSessionNotification } from '../acp/types.js';\nimport type { ManagedProcess } from '../../process/types.js';\n\n/**\n * Unified execution handle\n * \n * Abstracts over CLI process execution and ACP session execution.\n */\nexport type ExecutionHandle = \n  | { type: 'process'; process: ManagedProcess; exitSignal?: Promise<void> }\n  | { type: 'acp'; session: AcpSession };\n\n/**\n * Unified capabilities\n * \n * Combines CLI AgentCapabilities with ACP-specific features.\n */\nexport interface UnifiedCapabilities extends AgentCapabilities {\n  /** Whether the agent prefers ACP when available */\n  prefersAcp: boolean;\n\n  /** ACP-specific capabilities (if supported) */\n  acp?: {\n    loadSession: boolean;\n    modes: boolean;\n    models: boolean;\n    mcp: { http: boolean; sse: boolean; stdio: boolean };\n    prompt: { image: boolean; embeddedContext: boolean; audio: boolean };\n  };\n}\n\n/**\n * Unified output stream\n * \n * Provides consistent iteration over either CLI output chunks\n * or ACP session notifications.\n */\nexport interface UnifiedOutputStream {\n  /** Iterate over normalized entries */\n  [Symbol.asyncIterator](): AsyncIterator<NormalizedEntry>;\n\n  /** Raw ACP updates (if using ACP mode) */\n  rawAcpUpdates?: AsyncIterable<AcpSessionNotification>;\n\n  /** Get execution metadata */\n  getMetadata(): { sessionId?: string; model?: string };\n}\n\n/**\n * Unified Agent Executor Interface\n * \n * High-level interface for executing tasks with any agent,\n * regardless of whether it uses CLI or ACP under the hood.\n */\nexport interface IUnifiedAgentExecutor {\n  /**\n   * Execute a task\n   * \n   * Automatically chooses CLI or ACP based on availability and preferences.\n   */\n  executeTask(task: ExecutionTask): Promise<{\n    handle: ExecutionHandle;\n    output: UnifiedOutputStream;\n  }>;\n\n  /**\n   * Resume a previous session\n   */\n  resumeTask(task: ExecutionTask, sessionId: string): Promise<{\n    handle: ExecutionHandle;\n    output: UnifiedOutputStream;\n  }>;\n\n  /**\n   * Send a message mid-execution\n   */\n  sendMessage(handle: ExecutionHandle, message: string): Promise<void>;\n\n  /**\n   * Interrupt/cancel execution\n   */\n  interrupt(handle: ExecutionHandle): Promise<void>;\n\n  /**\n   * Get unified capabilities\n   */\n  getCapabilities(): UnifiedCapabilities;\n\n  /**\n   * Check if agent is available\n   */\n  checkAvailability(): Promise<boolean>;\n\n  /**\n   * Shutdown and cleanup\n   */\n  shutdown(): Promise<void>;\n}\n```\n\n### R7: Claude ACP Adapter Implementation\n\n**Description**: Implementation of ACP support for Claude Code using the Claude SDK.\n\n```typescript\n// src/agents/claude/acp-adapter.ts\n\nimport type { IAcpAgentAdapter, AcpAgentConfig } from '../acp/adapter.js';\nimport type { IAcpAgent, AcpAgentCapabilities } from '../acp/types.js';\nimport type { AgentMetadata } from '../types/agent-adapter.js';\nimport type { ProcessConfig } from '../../process/types.js';\n\n/**\n * Claude Code config with ACP support\n */\nexport interface ClaudeAcpConfig extends AcpAgentConfig {\n  /** Claude-specific: output format for CLI mode */\n  outputFormat?: 'stream-json' | 'json' | 'text';\n\n  /** Enable print mode (required for stream-json) */\n  print?: boolean;\n\n  /** Permission mode */\n  permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan';\n\n  /** System prompt */\n  systemPrompt?: string;\n\n  /** Model to use */\n  model?: string;\n}\n\n/**\n * Claude Code ACP Adapter\n * \n * Supports both CLI (stream-json) and ACP (via @anthropic-ai/claude-agent-sdk) modes.\n */\nexport class ClaudeAcpAdapter implements IAcpAgentAdapter<ClaudeAcpConfig> {\n  readonly metadata: AgentMetadata = {\n    name: 'claude-code',\n    displayName: 'Claude Code',\n    version: '1.0.0',\n    supportedModes: ['structured', 'interactive', 'hybrid'],\n    supportsStreaming: true,\n    supportsStructuredOutput: true,\n  };\n\n  readonly supportsAcp = true;\n\n  readonly acpCapabilities: AcpAgentCapabilities = {\n    loadSession: true,\n    sessionCapabilities: {\n      modes: true,\n      models: true,\n    },\n    promptCapabilities: {\n      image: true,\n      embeddedContext: true,\n      audio: false,\n    },\n    mcpCapabilities: {\n      http: false,\n      sse: false,\n      stdio: true,\n    },\n  };\n\n  buildProcessConfig(config: ClaudeAcpConfig): ProcessConfig {\n    const args: string[] = [];\n\n    if (config.print) args.push('--print');\n    if (config.outputFormat) args.push('--output-format', config.outputFormat);\n    if (config.systemPrompt) args.push('--system-prompt', config.systemPrompt);\n    if (config.model) args.push('--model', config.model);\n\n    // Handle permission mode\n    if (config.permissionMode === 'bypassPermissions') {\n      args.push('--dangerously-skip-permissions');\n    }\n\n    return {\n      executablePath: config.executablePath || 'claude',\n      args,\n      workDir: config.workDir,\n      env: config.env,\n      mode: config.mode || 'structured',\n    };\n  }\n\n  buildAcpProcessConfig(config: ClaudeAcpConfig): ProcessConfig {\n    // Claude Code doesn't have a CLI ACP mode yet\n    // Instead, we use the SDK directly\n    throw new Error('Claude Code uses SDK-based ACP, not CLI ACP');\n  }\n\n  createAcpAgent(config: ClaudeAcpConfig): IAcpAgent | null {\n    // Import dynamically to avoid requiring the SDK\n    try {\n      const { ClaudeAcpAgent } = require('./claude-acp-agent.js');\n      return new ClaudeAcpAgent(config);\n    } catch {\n      return null;\n    }\n  }\n\n  async checkAcpAvailability(): Promise<boolean> {\n    try {\n      require('@anthropic-ai/claude-agent-sdk');\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  validateConfig(config: ClaudeAcpConfig): string[] {\n    const errors: string[] = [];\n\n    if (!config.workDir) {\n      errors.push('workDir is required');\n    }\n\n    if (config.outputFormat === 'stream-json' && !config.print) {\n      errors.push('stream-json output format requires print mode');\n    }\n\n    return errors;\n  }\n\n  getDefaultConfig(): Partial<ClaudeAcpConfig> {\n    return {\n      print: true,\n      outputFormat: 'stream-json',\n      permissionMode: 'default',\n      preferAcp: true, // Prefer ACP when SDK is available\n    };\n  }\n}\n```\n\n### R8: Output Normalization for ACP\n\n**Description**: Convert ACP session notifications to unified NormalizedEntry format.\n\n```typescript\n// src/agents/acp/normalizer.ts\n\nimport type {\n  AcpSessionNotification,\n  AcpSessionUpdate,\n  AcpToolStatus,\n  AcpToolKind,\n  AcpToolContent,\n} from './types.js';\nimport type {\n  NormalizedEntry,\n  NormalizedEntryType,\n  ToolUseEntry,\n  ActionType,\n} from '../types/agent-executor.js';\n\n/**\n * ACP Output Normalizer\n * \n * Converts ACP session notifications to unified NormalizedEntry format.\n * Handles streaming coalescing for message chunks and tool updates.\n */\nexport class AcpNormalizer {\n  private entryIndex = 0;\n  private currentAssistantText = '';\n  private currentThinkingText = '';\n  private toolStates = new Map<string, ToolState>();\n\n  /**\n   * Normalize a single ACP notification to NormalizedEntry\n   * \n   * May return null for incremental updates that don't produce new entries.\n   */\n  normalize(\n    notification: AcpSessionNotification,\n    workDir: string\n  ): NormalizedEntry | null {\n    const update = notification.update;\n    const sessionId = notification.sessionId;\n\n    switch (update.sessionUpdate) {\n      case 'agent_message_chunk':\n        return this.normalizeMessageChunk(update.content, 'assistant', sessionId);\n\n      case 'user_message_chunk':\n        return this.normalizeMessageChunk(update.content, 'user', sessionId);\n\n      case 'agent_thought_chunk':\n        return this.normalizeThoughtChunk(update.content, sessionId);\n\n      case 'tool_call':\n        return this.normalizeToolCall(update, workDir, sessionId);\n\n      case 'tool_call_update':\n        return this.normalizeToolUpdate(update, workDir, sessionId);\n\n      case 'plan':\n        return this.normalizePlan(update.entries, sessionId);\n\n      case 'current_mode_update':\n        return this.normalizeSystemMessage(`Mode changed to: ${update.currentModeId}`, sessionId);\n\n      case 'available_commands_update':\n        return null; // Don't emit for command updates\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Normalize async iterable of notifications\n   */\n  async *normalizeStream(\n    notifications: AsyncIterable<AcpSessionNotification>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry> {\n    for await (const notification of notifications) {\n      const entry = this.normalize(notification, workDir);\n      if (entry) {\n        yield entry;\n      }\n    }\n  }\n\n  /**\n   * Reset state for new session\n   */\n  reset(): void {\n    this.entryIndex = 0;\n    this.currentAssistantText = '';\n    this.currentThinkingText = '';\n    this.toolStates.clear();\n  }\n\n  private normalizeMessageChunk(\n    content: { type: string; text?: string },\n    role: 'assistant' | 'user',\n    sessionId: string\n  ): NormalizedEntry | null {\n    if (content.type !== 'text' || !content.text) return null;\n\n    // Reset thinking when assistant message starts\n    if (role === 'assistant') {\n      this.currentThinkingText = '';\n    }\n\n    // Coalesce text chunks\n    if (role === 'assistant') {\n      this.currentAssistantText += content.text;\n      return this.createEntry(\n        { kind: 'assistant_message' },\n        this.currentAssistantText,\n        { sessionId }\n      );\n    } else {\n      return this.createEntry(\n        { kind: 'user_message' },\n        content.text,\n        { sessionId }\n      );\n    }\n  }\n\n  private normalizeThoughtChunk(\n    content: { type: string; text?: string },\n    sessionId: string\n  ): NormalizedEntry | null {\n    if (content.type !== 'text' || !content.text) return null;\n\n    // Reset assistant text when thinking starts\n    this.currentAssistantText = '';\n\n    this.currentThinkingText += content.text;\n    return this.createEntry(\n      { kind: 'thinking', reasoning: this.currentThinkingText },\n      this.currentThinkingText,\n      { sessionId }\n    );\n  }\n\n  private normalizeToolCall(\n    update: Extract<AcpSessionUpdate, { sessionUpdate: 'tool_call' }>,\n    workDir: string,\n    sessionId: string\n  ): NormalizedEntry {\n    // Reset text coalescing\n    this.currentAssistantText = '';\n    this.currentThinkingText = '';\n\n    const toolState: ToolState = {\n      id: update.toolCallId,\n      title: update.title,\n      kind: update.kind,\n      status: update.status,\n      rawInput: update.rawInput,\n      locations: update.locations,\n      content: [],\n    };\n\n    this.toolStates.set(update.toolCallId, toolState);\n\n    return this.createToolEntry(toolState, workDir, sessionId);\n  }\n\n  private normalizeToolUpdate(\n    update: Extract<AcpSessionUpdate, { sessionUpdate: 'tool_call_update' }>,\n    workDir: string,\n    sessionId: string\n  ): NormalizedEntry | null {\n    const toolState = this.toolStates.get(update.toolCallId);\n    if (!toolState) return null;\n\n    // Update state\n    if (update.status) toolState.status = update.status;\n    if (update.content) toolState.content = update.content;\n    if (update.rawOutput) toolState.rawOutput = update.rawOutput;\n\n    return this.createToolEntry(toolState, workDir, sessionId);\n  }\n\n  private createToolEntry(\n    state: ToolState,\n    workDir: string,\n    sessionId: string\n  ): NormalizedEntry {\n    const action = this.mapToActionType(state, workDir);\n    const status = this.mapToolStatus(state.status);\n\n    const tool: ToolUseEntry = {\n      toolName: state.title,\n      action,\n      status,\n    };\n\n    // Add result if completed\n    if (status === 'success' || status === 'failed') {\n      tool.result = {\n        success: status === 'success',\n        data: state.rawOutput,\n      };\n    }\n\n    return this.createEntry(\n      { kind: 'tool_use', tool },\n      this.getToolContent(state),\n      { sessionId }\n    );\n  }\n\n  private mapToActionType(state: ToolState, workDir: string): ActionType {\n    const path = state.locations?.[0]?.path || '';\n\n    switch (state.kind) {\n      case 'read':\n        return { kind: 'file_read', path };\n\n      case 'edit':\n        const changes = this.extractFileChanges(state.content);\n        return { kind: 'file_edit', path, changes };\n\n      case 'execute':\n        const command = state.rawInput?.command || state.title;\n        return { kind: 'command_run', command };\n\n      case 'delete':\n        return { kind: 'file_edit', path, changes: [{ type: 'delete' }] };\n\n      case 'search':\n        const query = state.rawInput?.query || state.title;\n        return { kind: 'search', query };\n\n      case 'fetch':\n        return { kind: 'tool', toolName: 'fetch', args: state.rawInput };\n\n      case 'think':\n        return { kind: 'tool', toolName: 'think', args: { thought: state.title } };\n\n      case 'mcp':\n        return { kind: 'tool', toolName: state.title, args: state.rawInput };\n\n      default:\n        return { kind: 'tool', toolName: state.title, args: state.rawInput };\n    }\n  }\n\n  private extractFileChanges(content: AcpToolContent[]): { type: 'edit' | 'delete'; unifiedDiff?: string }[] {\n    return content\n      .filter((c): c is { type: 'diff'; path: string; oldText?: string; newText: string } => c.type === 'diff')\n      .map((diff) => ({\n        type: 'edit' as const,\n        unifiedDiff: `--- ${diff.path}\\n+++ ${diff.path}\\n${diff.newText}`,\n      }));\n  }\n\n  private mapToolStatus(status: AcpToolStatus): 'created' | 'running' | 'success' | 'failed' {\n    switch (status) {\n      case 'pending': return 'created';\n      case 'in_progress': return 'running';\n      case 'completed': return 'success';\n      case 'failed': return 'failed';\n    }\n  }\n\n  private getToolContent(state: ToolState): string {\n    if (state.kind === 'execute') {\n      return state.rawInput?.command || state.title;\n    }\n    return state.title;\n  }\n\n  private normalizePlan(\n    entries: { id: string; content: string; status: string }[],\n    sessionId: string\n  ): NormalizedEntry {\n    const planText = entries\n      .map((e, i) => {\n        const status = e.status === 'completed' ? '✓' : e.status === 'in_progress' ? '→' : '○';\n        return `${status} ${i + 1}. ${e.content}`;\n      })\n      .join('\\n');\n\n    return this.createEntry(\n      { kind: 'system_message' },\n      `Plan:\\n${planText}`,\n      { sessionId }\n    );\n  }\n\n  private normalizeSystemMessage(message: string, sessionId: string): NormalizedEntry {\n    return this.createEntry(\n      { kind: 'system_message' },\n      message,\n      { sessionId }\n    );\n  }\n\n  private createEntry(\n    type: NormalizedEntryType,\n    content: string,\n    metadata: { sessionId?: string; model?: string }\n  ): NormalizedEntry {\n    return {\n      index: this.entryIndex++,\n      timestamp: new Date(),\n      type,\n      content,\n      metadata,\n    };\n  }\n}\n\ninterface ToolState {\n  id: string;\n  title: string;\n  kind: AcpToolKind;\n  status: AcpToolStatus;\n  rawInput?: unknown;\n  rawOutput?: unknown;\n  locations?: { path: string; startLine?: number; endLine?: number }[];\n  content: AcpToolContent[];\n}\n```\n\n## File Structure\n\n```\nsrc/agents/\n├── acp/\n│   ├── index.ts              # Public exports\n│   ├── types.ts              # ACP type definitions (R2)\n│   ├── connection.ts         # Low-level connection handling (R4)\n│   ├── executor.ts           # IAcpExecutor interface (R3)\n│   ├── adapter.ts            # IAcpAgentAdapter interface (R5)\n│   ├── normalizer.ts         # Output normalization (R8)\n│   └── client.ts             # Default IAcpClient implementation\n├── unified/\n│   ├── index.ts              # Public exports\n│   ├── types.ts              # Unified interfaces (R6)\n│   └── executor.ts           # IUnifiedAgentExecutor implementation\n├── claude/\n│   ├── adapter.ts            # Existing CLI adapter\n│   ├── acp-adapter.ts        # ACP-capable adapter (R7)\n│   └── claude-acp-agent.ts   # IAcpAgent implementation using SDK\n├── gemini/\n│   ├── adapter.ts            # Existing CLI adapter\n│   └── acp-adapter.ts        # ACP-capable adapter\n└── types/\n    ├── agent-adapter.ts      # Existing (unchanged)\n    └── agent-executor.ts     # Existing (unchanged)\n```\n\n## Package Exports\n\n```typescript\n// src/index.ts additions\n\n// ACP layer\nexport * from './agents/acp/index.js';\n\n// Unified layer\nexport * from './agents/unified/index.js';\n\n// package.json exports additions\n{\n  \"exports\": {\n    \"./agents/acp\": \"./dist/agents/acp/index.js\",\n    \"./agents/unified\": \"./dist/agents/unified/index.js\"\n  }\n}\n```\n\n## Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"@agentclientprotocol/sdk\": \"^0.1.0\"\n  },\n  \"peerDependencies\": {\n    \"@anthropic-ai/claude-agent-sdk\": \"^0.1.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"@anthropic-ai/claude-agent-sdk\": {\n      \"optional\": true\n    }\n  }\n}\n```\n\n## Migration Path\n\n### For Existing Users\n\n1. **No Breaking Changes**: Existing `IAgentAdapter` and `IAgentExecutor` interfaces remain unchanged\n1. **Opt-in ACP**: New `IAcpAgentAdapter` interface extends existing adapter interface\n1. **Unified Interface**: New `IUnifiedAgentExecutor` provides consistent API for both modes\n\n### For New Integrations\n\n1. **Check ACP Support**: Use `isAcpCapableAdapter()` type guard\n1. **Prefer ACP**: Set `preferAcp: true` in config to use ACP when available\n1. **Fallback**: System automatically falls back to CLI mode if ACP unavailable\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **ACP Types** - Validate type definitions match SDK schema\n1. **AcpConnection** - Test stream conversion, process spawning\n1. **AcpNormalizer** - Test all notification types, coalescing\n1. **ClaudeAcpAdapter** - Test config building, availability checks\n\n### Integration Tests\n\n1. **End-to-end ACP flow** - Spawn agent, send prompt, receive updates\n1. **Fallback behavior** - ACP unavailable → CLI mode\n1. **Session resume** - Load existing session, continue conversation\n\n### Mock ACP Agent\n\nCreate a mock ACP agent for testing without real CLI:\n\n```typescript\n// tests/mocks/mock-acp-agent.ts\nexport class MockAcpAgent implements IAcpAgent {\n  async initialize() { /* ... */ }\n  async newSession() { /* ... */ }\n  async prompt() { /* ... */ }\n  async cancel() { /* ... */ }\n}\n```\n\n## References\n\n- **ACP SDK**: `/references/typescript-sdk/` - TypeScript SDK for ACP\n- **Claude ACP Adapter**: `/references/claude-code-acp/` - Reference implementation\n- **Existing Gemini Spec**: [[s-iaik]] - Gemini ACP implementation spec\n- **Agent Executor Types**: `src/agents/types/agent-executor.ts`\n- **Agent Adapter Types**: `src/agents/types/agent-adapter.ts`","priority":1,"archived":0,"archived_at":null,"created_at":"2025-12-06 22:47:47","updated_at":"2025-12-06 22:55:31","parent_id":null,"parent_uuid":null,"relationships":[{"from":"s-1t3x","from_type":"spec","to":"s-iaik","to_type":"spec","type":"related"}],"tags":["acp","agent-interface","architecture","protocol"]}
