{"id":"s-6s6c","uuid":"39269e44-ae39-4ea2-88a2-662fb3328ee1","title":"Sprint 1: Agent Execution Foundation - Unified Interface Layer","file_path":"specs/sprint_1_agent_execution_foundation_unified_interf.md","content":"# Sprint 1: Agent Execution Foundation - Unified Interface Layer\n\n## Overview\n\nBuild the foundational interfaces and types for a unified agent execution system that abstracts away protocol differences between CLI agents (Codex, Claude Code, Cursor, Gemini, etc.). This is the TypeScript equivalent of vibe-kanban's `StandardCodingAgentExecutor` trait system.\n\n**Key Design Principle**: This sprint **maximizes reusability** of existing infrastructure. The execution engine already has robust process management, task execution, resilience, and workflow layers. We're adding a **thin agent abstraction layer** on top, not replacing what works.\n\n## Goals\n\n1. ✅ Create a unified `IAgentExecutor` interface that all agents implement\n1. ✅ Design normalized output types for consistent UI rendering\n1. ✅ Implement an approval service interface for interactive tool approvals\n1. ✅ Build a base executor class with common functionality\n1. ✅ Create an agent profile/registry system for configuration management\n1. ✅ **Integrate seamlessly with existing process, engine, and resilience layers**\n\n## Success Criteria\n\n- All interfaces compile with TypeScript strict mode\n- Interface design supports all target agents (Cursor, Codex, Claude, Gemini)\n- Clear separation between agent-agnostic and agent-specific logic\n- Comprehensive JSDoc documentation on all public APIs\n- Example usage patterns documented\n- No breaking changes to existing `IAgentAdapter` interface\n- **Reuses existing** `ManagedProcess`**,** `ProcessConfig`**,** `IProcessManager` **types**\n- **Minimal changes to existing layers (process/engine/resilience/workflow)**\n\n---\n\n## Integration with Existing Infrastructure\n\n### What We're Reusing (95% of existing code)\n\nSprint 1 **builds on top of** existing infrastructure, not replacing it:\n\n#### Layer 1: Process Management (100% reusable)\n\n- ✅ `process/types.ts`: `ManagedProcess`, `ProcessConfig`, `ExecutionMode` - Used as-is\n- ✅ `process/manager.ts`: `IProcessManager` interface - Used directly by `BaseAgentExecutor`\n- ✅ `process/simple-manager.ts`: `SimpleProcessManager` - Default process manager\n- ✅ `process/pty-manager.ts`: `PtyProcessManager` - For interactive agents\n- ✅ `process/factory.ts`: `createProcessManager()` - Factory for creating managers\n\n**How we use it**:\n\n```typescript\nclass BaseAgentExecutor {\n  // Reuse existing IProcessManager to spawn/manage processes\n  protected async spawnProcess(config: ProcessConfig): Promise<ManagedProcess> {\n    const manager = createProcessManager(config);\n    return manager.acquireProcess(config);\n  }\n}\n```\n\n#### Layer 2: Execution Engine (95% reusable)\n\n- ✅ `engine/types.ts`: `ExecutionTask`, `TaskResult`, `TaskStatus` - Minor extension needed\n- ✅ `engine/simple-engine.ts`: `SimpleExecutionEngine` - Task queue and concurrency\n- ⚠️ `ExecutionTask` **extension**: Add optional `agentProfile?: AgentProfileId` field\n\n**Changes needed**:\n\n```typescript\n// engine/types.ts - ADD THIS FIELD\nexport interface ExecutionTask {\n  id: string;\n  type: \"issue\" | \"spec\" | \"custom\";\n  prompt: string;\n  workDir: string;\n  agentProfile?: AgentProfileId;  // NEW: Which agent to use (optional)\n  config: { timeout?: number; env?: Record<string, string> };\n  dependencies?: string[];\n}\n```\n\n**How we use it**:\n\n```typescript\n// SimpleExecutionEngine can use AgentProfileRegistry to route tasks\nclass SimpleExecutionEngine {\n  async submitTask(task: ExecutionTask): Promise<string> {\n    // If task.agentProfile specified, use that executor\n    const executor = task.agentProfile \n      ? this.agentRegistry.getExecutor(task.agentProfile)\n      : this.defaultExecutor;\n    \n    // Rest stays the same...\n  }\n}\n```\n\n#### Layer 3: Resilience (100% reusable)\n\n- ✅ `resilience/executor.ts`: `IResilientExecutor`, `ResilientExecutor` - No changes needed\n- ✅ `resilience/retry.ts`: Retry strategies - Works with any executor\n- ✅ `resilience/circuit-breaker.ts`: Circuit breaker - Agent-agnostic\n\n**How we use it**:\n\n```typescript\n// ResilientExecutor wraps ANY executor (including new agent executors)\nconst baseExecutor = new ClaudeCodeExecutor(config);\nconst resilientExecutor = new ResilientExecutor(baseExecutor, {\n  maxAttempts: 3,\n  backoffStrategy: 'exponential',\n});\n```\n\n#### Layer 4: Workflow (100% reusable)\n\n- ✅ `workflow/orchestrator.ts`: `IWorkflowOrchestrator` - No changes needed\n- ✅ `workflow/linear-orchestrator.ts`: `LinearOrchestrator` - Works with agent executors\n- ✅ `workflow/types.ts`: `WorkflowDefinition`, `WorkflowStep` - No changes needed\n\n**How we use it**:\n\n```typescript\n// Workflows can specify which agent to use per step\nconst workflow: WorkflowDefinition = {\n  id: 'feature-workflow',\n  steps: [\n    { \n      id: 'plan', \n      taskType: 'spec',\n      prompt: 'Plan the feature',\n      agentProfile: { executor: 'claude-code', variant: 'plan' }  // Use planning agent\n    },\n    { \n      id: 'implement', \n      taskType: 'issue',\n      prompt: 'Implement the feature',\n      agentProfile: { executor: 'cursor', variant: 'default' }  // Use Cursor\n    },\n  ],\n};\n```\n\n### What We're Adding (5% new code)\n\nOnly the **agent abstraction layer** is new:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│  NEW: Agent Abstraction Layer (~2700 lines)            │\n│  ┌───────────────────────────────────────────────────┐ │\n│  │ IAgentExecutor, BaseAgentExecutor                 │ │\n│  │ NormalizedOutput, AgentProfiles                   │ │\n│  └───────────────────────────────────────────────────┘ │\n└──────────────────┬──────────────────────────────────────┘\n                   │ uses\n┌──────────────────▼──────────────────────────────────────┐\n│  EXISTING: Process/Engine/Resilience/Workflow           │\n│  (95% unchanged, ~25,000 lines)                         │\n│  ┌───────────────────────────────────────────────────┐ │\n│  │ ✅ IProcessManager, ManagedProcess                │ │\n│  │ ✅ SimpleExecutionEngine, ResilientExecutor       │ │\n│  │ ✅ LinearOrchestrator                             │ │\n│  └───────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Reusability Breakdown\n\n| Component | Lines | Reusability | Changes |\n| --- | --- | --- | --- |\n| `process/*` | ~800 | 100% | None |\n| `engine/*` | ~600 | 95% | Add 1 field to `ExecutionTask` |\n| `resilience/*` | ~400 | 100% | None |\n| `workflow/*` | ~500 | 100% | None |\n| **Total Existing** | **~2,300** | **~95%** | **Minimal** |\n| **New (Sprint 1)** | **~700** | **N/A** | **All new** |\n\n### Integration Points\n\n#### 1\\. BaseAgentExecutor ↔ IProcessManager\n\n```typescript\nabstract class BaseAgentExecutor implements IAgentExecutor {\n  // INTEGRATION POINT: Use existing process manager\n  protected async spawnWithManager(config: ProcessConfig): Promise<ManagedProcess> {\n    const manager = createProcessManager(config);  // Existing factory\n    return manager.acquireProcess(config);\n  }\n  \n  // INTEGRATION POINT: Convert ChildProcess to ManagedProcess\n  protected wrapChildProcess(child: ChildProcess): ManagedProcess {\n    // Uses existing ManagedProcess type from process/types.ts\n    return {\n      id: generateId(),\n      pid: child.pid!,\n      status: 'running',\n      process: child,\n      streams: {\n        stdout: child.stdout!,\n        stderr: child.stderr!,\n        stdin: child.stdin!,\n      },\n      metrics: { totalDuration: 0, tasksCompleted: 0, successRate: 1 },\n    };\n  }\n}\n```\n\n#### 2\\. ExecutionTask ↔ AgentProfile\n\n```typescript\n// engine/types.ts - MINIMAL CHANGE\nexport interface ExecutionTask {\n  // ... existing fields ...\n  agentProfile?: AgentProfileId;  // NEW: Optional agent selection\n}\n\n// Usage in engine\nclass SimpleExecutionEngine {\n  constructor(\n    private processManager: IProcessManager,\n    private agentRegistry?: AgentProfileRegistry,  // NEW: Optional registry\n  ) {}\n  \n  async submitTask(task: ExecutionTask): Promise<string> {\n    // INTEGRATION POINT: Use registry if available, fallback to default\n    const executor = task.agentProfile && this.agentRegistry\n      ? this.agentRegistry.getExecutor(task.agentProfile)\n      : this.defaultExecutor;\n    \n    // Rest of implementation unchanged...\n  }\n}\n```\n\n#### 3\\. Workflow ↔ Agent Executors\n\n```typescript\n// No changes to WorkflowDefinition or WorkflowStep types needed!\n// Just use existing infrastructure:\n\nconst orchestrator = new LinearOrchestrator(resilientExecutor);\n\n// Workflow steps can optionally specify agentProfile\nconst workflow: WorkflowDefinition = {\n  id: 'build-feature',\n  steps: [\n    {\n      id: 'step1',\n      taskType: 'spec',\n      prompt: 'Plan the feature',\n      // Uses ExecutionTask.agentProfile field (added in Sprint 1)\n      config: { \n        env: { AGENT_PROFILE: JSON.stringify({ executor: 'claude-code', variant: 'plan' }) }\n      },\n    },\n  ],\n};\n```\n\n### Backward Compatibility\n\n**100% backward compatible** - existing code continues to work:\n\n```typescript\n// OLD CODE (still works)\nconst adapter = new ClaudeCodeAdapter();\nconst processConfig = adapter.buildProcessConfig({ workDir: '/tmp' });\nconst manager = createProcessManager(processConfig);\n\n// NEW CODE (coexists)\nconst executor = registry.getExecutor({ executor: 'claude-code' });\nconst spawned = await executor.executeTask(task);\n```\n\n---\n\n## Architecture Diagram\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                 IAgentExecutor Interface                │\n│  (Unified execution contract for all CLI agents)        │\n│                                                         │\n│  + executeTask(task): Promise<SpawnedChild>            │\n│  + resumeTask(task, sessionId): Promise<SpawnedChild>  │\n│  + normalizeOutput(stream): AsyncIterable<Entry>       │\n│  + getCapabilities(): AgentCapabilities                │\n│  + checkAvailability(): Promise<boolean>               │\n└──────────────┬──────────────────────────────────────────┘\n               │\n               │ implements\n               ▼\n┌──────────────────────────────────────────────────────────┐\n│           BaseAgentExecutor (abstract)                   │\n│  (Common functionality shared by all executors)          │\n│                                                          │\n│  # approvalService?: IApprovalService                    │\n│  # requestApproval(request): Promise<Decision>          │\n│  # spawnWithManager(config): Promise<ManagedProcess> ◄──┐│\n│  # wrapChildProcess(child): ManagedProcess           ◄──┤│\n└──────────────┬───────────────────────────────────────────┘│\n               │                                            │\n               │ extends                                    │\n               ▼                                            │\n┌────────────────────────────────────────────┐             │\n│   Concrete Executors (Sprint 2+)           │             │\n│                                            │             │\n│   • CursorExecutor                         │             │\n│   • CodexExecExecutor                      │             │\n│   • GeminiExecutor                         │             │\n│   • ClaudeCodeExecutor                     │             │\n│   • CodexAppServerExecutor                 │             │\n└────────────────────────────────────────────┘             │\n                                                           │\n                                                           │\n┌──────────────────────────────────────────────────────────┤\n│  EXISTING INFRASTRUCTURE (reused)                        │\n│                                                          │\n│  ┌────────────────────────────────────────────────────┐ │\n│  │ process/types.ts                                   │ │\n│  │  • ManagedProcess, ProcessConfig ─────────────────┐│ │\n│  │  • ExecutionMode, ProcessStatus                   ││ │\n│  └────────────────────────────────────────────────────┘│ │\n│                                                          │\n│  ┌────────────────────────────────────────────────────┐ │\n│  │ process/manager.ts                                 │ │\n│  │  • IProcessManager ───────────────────────────────┐│ │\n│  │  • acquireProcess(), releaseProcess()             ││ │\n│  └────────────────────────────────────────────────────┘│ │\n└──────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Requirements\n\n### R1: IAgentExecutor Interface\n\n**Priority**: P0 (Critical)\n\nThe core interface that all agent executors must implement.\n\n**Interface Contract**:\n\n```typescript\ninterface IAgentExecutor {\n  // Execution methods\n  executeTask(task: ExecutionTask): Promise<SpawnedChild>\n  resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>\n  \n  // Output processing\n  normalizeOutput(\n    outputStream: AsyncIterable<OutputChunk>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry>\n  \n  // Capabilities\n  getCapabilities(): AgentCapabilities\n  checkAvailability(): Promise<boolean>\n  \n  // Optional features\n  setApprovalService?(service: IApprovalService): void\n}\n```\n\n**Why this design?**\n\n- `executeTask()` - New session execution (equivalent to vibe-kanban's `spawn()`)\n- `resumeTask()` - Session continuation (equivalent to `spawn_follow_up()`)\n- `normalizeOutput()` - Convert agent-specific output to unified format (equivalent to `normalize_logs()`)\n- `getCapabilities()` - Declare what features this agent supports\n- `checkAvailability()` - Check if agent CLI is installed/configured\n\n**Design Decisions**:\n\n1. **Async iterables for output** - Supports streaming, memory efficient\n1. **Separate execute vs resume** - Clear API, different args needed\n1. **Capabilities-based** - Agents declare what they support (no feature detection)\n1. **Optional approval service** - Not all agents need interactive approvals\n\n**Non-Goals**:\n\n- ❌ Process lifecycle management (that's `IProcessManager`'s job)\n- ❌ Task queueing (that's `IExecutionEngine`'s job)\n- ❌ Retry logic (that's `IResilientExecutor`'s job)\n\n---\n\n### R2: Normalized Output Types\n\n**Priority**: P0 (Critical)\n\nUnified output format that all agents convert to. This enables consistent UI rendering regardless of which agent produced the output.\n\n**Type Structure**:\n\n```typescript\ninterface NormalizedEntry {\n  index: number                    // Sequential entry number\n  timestamp?: Date                 // When entry was created\n  type: NormalizedEntryType        // Discriminated union of entry types\n  content: string                  // Main content (markdown-formatted)\n  metadata?: Record<string, unknown>  // Optional agent-specific data\n}\n\ntype NormalizedEntryType =\n  | { kind: 'system_message' }\n  | { kind: 'user_message' }\n  | { kind: 'assistant_message' }\n  | { kind: 'thinking'; reasoning?: string }\n  | { kind: 'tool_use'; tool: ToolUseEntry }\n  | { kind: 'error'; error: ErrorEntry }\n\ninterface ToolUseEntry {\n  toolName: string               // e.g., \"Bash\", \"Edit\", \"mcp:filesystem:read\"\n  action: ActionType             // What the tool is doing\n  status: 'created' | 'running' | 'success' | 'failed'\n  result?: ToolResult            // Result after completion\n}\n\ntype ActionType =\n  | { kind: 'file_read'; path: string }\n  | { kind: 'file_write'; path: string }\n  | { kind: 'file_edit'; path: string; changes: FileChange[] }\n  | { kind: 'command_run'; command: string; result?: CommandResult }\n  | { kind: 'search'; query: string }\n  | { kind: 'tool'; toolName: string; args?: unknown; result?: unknown }\n```\n\n**Why discriminated unions?**\n\n- Type-safe handling in consuming code\n- IDE autocomplete support\n- Pattern matching with exhaustiveness checking\n\n**Mapping Examples**:\n\n| Agent Output | Normalized Type |\n| --- | --- |\n| Claude: `{\"type\":\"assistant\",\"message\":...}` | `{kind:'assistant_message'}` |\n| Cursor: `{\"type\":\"tool_call\",\"tool_call\":{\"shellToolCall\":...}}` | `{kind:'tool_use', tool:{...}}` |\n| Codex: `{\"method\":\"codex/event/task_complete\"}` | `{kind:'system_message'}` |\n| Gemini ACP: `SessionUpdate::AgentMessageChunk` | `{kind:'assistant_message'}` |\n\n**File Changes Representation**:\n\n```typescript\ninterface FileChange {\n  type: 'edit' | 'delete'\n  unifiedDiff?: string  // Unified diff format for displaying changes\n}\n```\n\n**Design Decisions**:\n\n1. **String content** - Forces rendering at UI layer (separation of concerns)\n1. **Discriminated unions** - Type safety over loose objects\n1. **Unified diff format** - Standard for code changes\n1. **Metadata escape hatch** - Agent-specific data can be preserved\n\n---\n\n### R3: Agent Capabilities System\n\n**Priority**: P0 (Critical)\n\nDeclare what features each agent supports. Used for feature detection and UI adaptation.\n\n**Interface**:\n\n```typescript\ninterface AgentCapabilities {\n  supportsSessionResume: boolean    // Can resume previous sessions?\n  requiresSetup: boolean            // Needs setup (login, install) before use?\n  supportsApprovals: boolean        // Has interactive approval system?\n  supportsMcp: boolean              // Supports MCP servers?\n  protocol: ProtocolType            // What protocol does this use?\n}\n\ntype ProtocolType = \n  | 'acp'           // Agent Client Protocol (Gemini, Qwen)\n  | 'jsonrpc'       // JSON-RPC 2.0 (Codex app-server)\n  | 'stream-json'   // Stream JSON + control (Claude Code)\n  | 'jsonl'         // Simple JSONL (Cursor)\n  | 'custom'        // Custom protocol\n```\n\n**Usage Example**:\n\n```typescript\nconst executor = registry.getExecutor({ executor: 'cursor' });\nconst caps = executor.getCapabilities();\n\nif (caps.supportsSessionResume) {\n  // Show \"Continue from previous\" button\n}\n\nif (caps.requiresSetup) {\n  // Check availability before showing in UI\n  const available = await executor.checkAvailability();\n  if (!available) {\n    // Show setup instructions\n  }\n}\n```\n\n**Capability Matrix** (for reference):\n\n| Agent | Resume | Setup? | Approvals | MCP | Protocol |\n| --- | --- | --- | --- | --- | --- |\n| Cursor | ✅ | ✅ login | ❌ (--force) | ✅ | jsonl |\n| Codex Exec | ❌ | ❌ | ❌ | ✅ | custom |\n| Codex App | ✅ | ❌ | ✅ | ✅ | jsonrpc |\n| Claude | ✅ | ❌ | ✅ | ✅ | stream-json |\n| Gemini | ✅ | ✅ login | ✅ | ✅ | acp |\n\n---\n\n### R4: Approval Service Interface\n\n**Priority**: P1 (High)\n\nHandle interactive tool approval requests from agents (e.g., \"Allow bash command?\", \"Approve file edit?\").\n\n**Interface**:\n\n```typescript\ninterface IApprovalService {\n  requestApproval(request: ApprovalRequest): Promise<ApprovalDecision>\n}\n\ninterface ApprovalRequest {\n  requestId: string      // Unique ID (for tracking)\n  toolName: string       // e.g., \"Bash\", \"Edit\", \"mcp:server:tool\"\n  toolInput: unknown     // Tool arguments (agent-specific format)\n  context?: string       // Why this tool is needed (for UI display)\n}\n\ntype ApprovalDecision =\n  | { status: 'approved' }\n  | { status: 'denied'; reason?: string }\n  | { status: 'timeout' }\n```\n\n**Design Decisions**:\n\n1. **Simple async interface** - Implementations can show UI, use auto-rules, etc.\n1. **Unknown tool input** - Each agent has different formats (preserve as-is)\n1. **Optional context** - Some agents provide reasoning, others don't\n1. **Timeout status** - Distinguishes \"user didn't respond\" from \"user denied\"\n\n**Usage Patterns**:\n\n**Pattern 1: Auto-approve** (for CI/CD):\n\n```typescript\nclass AutoApprovalService implements IApprovalService {\n  async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    return { status: 'approved' };\n  }\n}\n```\n\n**Pattern 2: Rule-based** (approve reads, deny writes):\n\n```typescript\nclass RuleBasedApprovalService implements IApprovalService {\n  async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    if (request.toolName === 'Read') return { status: 'approved' };\n    if (request.toolName === 'Bash') return { status: 'denied', reason: 'No shell access' };\n    return { status: 'denied', reason: 'Unknown tool' };\n  }\n}\n```\n\n**Pattern 3: Interactive** (show UI):\n\n```typescript\nclass InteractiveApprovalService implements IApprovalService {\n  async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    const userChoice = await showApprovalDialog(request);\n    return userChoice ? { status: 'approved' } : { status: 'denied' };\n  }\n}\n```\n\n**Integration with Executors**:\n\n```typescript\n// Executor uses approval service if provided\nclass ClaudeCodeExecutor extends BaseAgentExecutor {\n  async handleControlRequest(request: ControlRequest) {\n    if (request.type === 'can_use_tool') {\n      const decision = await this.requestApproval({\n        requestId: request.requestId,\n        toolName: request.toolName,\n        toolInput: request.input,\n      });\n      \n      return decision.status === 'approved' \n        ? { result: 'allow' }\n        : { result: 'deny', message: decision.reason };\n    }\n  }\n}\n```\n\n---\n\n### R5: BaseAgentExecutor Abstract Class\n\n**Priority**: P1 (High)\n\nProvide shared functionality that all concrete executors can inherit. **This class integrates heavily with existing infrastructure.**\n\n**Class Structure**:\n\n```typescript\nabstract class BaseAgentExecutor implements IAgentExecutor {\n  protected approvalService?: IApprovalService;\n  \n  // Abstract methods (must be implemented by subclasses)\n  abstract executeTask(task: ExecutionTask): Promise<SpawnedChild>\n  abstract resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>\n  abstract normalizeOutput(\n    outputStream: AsyncIterable<OutputChunk>,\n    workDir: string\n  ): AsyncIterable<NormalizedEntry>\n  abstract getCapabilities(): AgentCapabilities\n  \n  // Concrete methods (shared implementation)\n  setApprovalService(service: IApprovalService): void {\n    this.approvalService = service;\n  }\n  \n  async checkAvailability(): Promise<boolean> {\n    // Default: check if executable exists in PATH\n    // Subclasses can override for custom logic\n    return true;\n  }\n  \n  // Protected helpers\n  protected async requestApproval(request: ApprovalRequest): Promise<ApprovalDecision> {\n    if (!this.approvalService) {\n      // No service = auto-approve\n      return { status: 'approved' };\n    }\n    return this.approvalService.requestApproval(request);\n  }\n  \n  // INTEGRATION POINT: Reuse existing IProcessManager\n  protected async spawnWithManager(config: ProcessConfig): Promise<ManagedProcess> {\n    const manager = createProcessManager(config);  // From process/factory.ts\n    return manager.acquireProcess(config);\n  }\n  \n  // INTEGRATION POINT: Convert ChildProcess → ManagedProcess\n  protected wrapChildProcess(child: ChildProcess): ManagedProcess {\n    // Uses ManagedProcess type from process/types.ts\n    return {\n      id: generateId(),  // From process/utils.ts\n      pid: child.pid!,\n      status: 'running',\n      process: child,\n      streams: {\n        stdout: child.stdout as Readable,\n        stderr: child.stderr as Readable,\n        stdin: child.stdin as Writable,\n      },\n      metrics: {\n        totalDuration: 0,\n        tasksCompleted: 0,\n        successRate: 1,\n      },\n    };\n  }\n  \n  // INTEGRATION POINT: Create OutputChunk stream from ManagedProcess\n  protected async *createOutputChunks(\n    process: ManagedProcess\n  ): AsyncIterable<OutputChunk> {\n    // Convert ManagedProcess.streams to OutputChunk stream\n    const { stdout, stderr } = process.streams!;\n    \n    // Multiplex stdout and stderr into single stream\n    for await (const chunk of stdout) {\n      yield {\n        type: 'stdout' as const,\n        data: Buffer.from(chunk),\n        timestamp: new Date(),\n      };\n    }\n    \n    for await (const chunk of stderr) {\n      yield {\n        type: 'stderr' as const,\n        data: Buffer.from(chunk),\n        timestamp: new Date(),\n      };\n    }\n  }\n}\n```\n\n**Shared Functionality**:\n\n1. **Approval handling** - Default to auto-approve if no service\n1. **Process wrapping** - Convert Node.js ChildProcess to ManagedProcess (reuses existing type)\n1. **Stream utilities** - Common output stream processing\n1. **Availability check** - Default implementation (check PATH)\n\n**Integration Points**:\n\n- Uses `createProcessManager()` from `process/factory.ts`\n- Uses `ManagedProcess` type from `process/types.ts`\n- Uses `generateId()` from `process/utils.ts`\n- Returns `OutputChunk` stream that can be consumed by `normalizeOutput()`\n\n**Subclass Template**:\n\n```typescript\nclass CursorExecutor extends BaseAgentExecutor {\n  constructor(private config: CursorConfig) {\n    super();\n  }\n  \n  async executeTask(task: ExecutionTask): Promise<SpawnedChild> {\n    // 1. Build ProcessConfig (uses existing type from process/types.ts)\n    const processConfig: ProcessConfig = {\n      executablePath: 'cursor-agent',\n      args: ['-p', '--output-format=stream-json', '--force'],\n      workDir: task.workDir,\n      mode: 'structured',  // Use structured mode (pipes)\n    };\n    \n    // 2. Spawn using existing process manager\n    const process = await this.spawnWithManager(processConfig);\n    \n    // 3. Send prompt to stdin\n    process.streams!.stdin.write(task.prompt + '\\n');\n    process.streams!.stdin.end();\n    \n    // 4. Return wrapped process\n    return { process };\n  }\n  \n  async *normalizeOutput(stream, workDir) {\n    // Parse Cursor JSONL format → NormalizedEntry\n    for await (const chunk of stream) {\n      const line = chunk.data.toString();\n      const entry = this.parseCursorJson(line);\n      if (entry) yield entry;\n    }\n  }\n  \n  getCapabilities(): AgentCapabilities {\n    return {\n      supportsSessionResume: true,\n      requiresSetup: true,\n      supportsApprovals: false,\n      supportsMcp: true,\n      protocol: 'jsonl',\n    };\n  }\n}\n```\n\n---\n\n### R6: Agent Profile System\n\n**Priority**: P1 (High)\n\nConfiguration management system inspired by vibe-kanban's profile system. Allows multiple variants of the same agent (e.g., \"claude:default\", \"claude:plan\", \"gemini:flash\").\n\n**Type Structure**:\n\n```typescript\ninterface AgentProfileId {\n  executor: string     // Agent type: 'claude-code', 'cursor', 'gemini'\n  variant?: string     // Optional variant: 'default', 'plan', 'flash'\n}\n\ninterface AgentProfile<TConfig = unknown> {\n  config: TConfig              // Agent-specific configuration\n  displayName: string          // Human-readable name\n  description?: string         // Description for UI\n}\n\ninterface ProfileRegistry {\n  executors: Record<string, Record<string, AgentProfile>>\n  // e.g., { \"cursor\": { \"default\": {...}, \"force\": {...} } }\n}\n```\n\n**Registry Class**:\n\n```typescript\nclass AgentProfileRegistry {\n  private profiles: ProfileRegistry = { executors: {} };\n  private factories = new Map<string, ExecutorFactory>();\n  \n  registerExecutor(name: string, factory: ExecutorFactory): void\n  registerProfile(executor: string, variant: string, profile: AgentProfile): void\n  getExecutor(profileId: AgentProfileId): IAgentExecutor | null\n  loadProfiles(registry: ProfileRegistry): void\n  getAllProfiles(): ProfileRegistry\n}\n\ntype ExecutorFactory = (config: unknown) => IAgentExecutor;\n```\n\n**Example Profiles JSON**:\n\n```json\n{\n  \"executors\": {\n    \"cursor\": {\n      \"default\": {\n        \"config\": { \"force\": true, \"model\": \"auto\" },\n        \"displayName\": \"Cursor (Auto-approve)\",\n        \"description\": \"Cursor with auto-approval enabled\"\n      },\n      \"interactive\": {\n        \"config\": { \"force\": false, \"model\": \"sonnet-4.5\" },\n        \"displayName\": \"Cursor (Interactive)\",\n        \"description\": \"Cursor with manual approvals, Sonnet 4.5\"\n      }\n    },\n    \"claude-code\": {\n      \"default\": {\n        \"config\": { \"print\": true, \"outputFormat\": \"stream-json\" },\n        \"displayName\": \"Claude Code\",\n        \"description\": \"Standard Claude Code configuration\"\n      },\n      \"plan\": {\n        \"config\": { \"print\": true, \"outputFormat\": \"stream-json\", \"planMode\": true },\n        \"displayName\": \"Claude Code (Plan Mode)\",\n        \"description\": \"Claude with plan mode enabled\"\n      }\n    }\n  }\n}\n```\n\n**Usage Pattern**:\n\n```typescript\n// 1. Set up registry\nconst registry = new AgentProfileRegistry();\n\n// 2. Register executor factories\nregistry.registerExecutor('cursor', (config) => new CursorExecutor(config as CursorConfig));\nregistry.registerExecutor('claude-code', (config) => new ClaudeCodeExecutor(config as ClaudeConfig));\n\n// 3. Load profiles from JSON\nconst profiles = loadProfilesFromFile('profiles.json');\nregistry.loadProfiles(profiles);\n\n// 4. Get executor by profile\nconst executor = registry.getExecutor({ \n  executor: 'cursor', \n  variant: 'interactive' \n});\n\n// 5. Execute task\nconst result = await executor.executeTask(task);\n```\n\n**Design Decisions**:\n\n1. **Factory pattern** - Decouple profile loading from executor instantiation\n1. **Type-safe configs** - Each executor gets strongly-typed config\n1. **Variant system** - Multiple configurations per agent\n1. **JSON-based** - Easy to edit, version control, share\n\n---\n\n### R7: Output Stream Types\n\n**Priority**: P0 (Critical)\n\nDefine the input/output types for the normalization pipeline.\n\n**Types**:\n\n```typescript\ninterface OutputChunk {\n  type: 'stdout' | 'stderr'\n  data: Buffer\n  timestamp: Date\n}\n\ninterface SpawnedChild {\n  process: ManagedProcess  // INTEGRATION POINT: Uses existing type from process/types.ts\n  exitSignal?: Promise<void>  // Optional completion signal (for ACP, etc.)\n}\n```\n\n**Why these types?**\n\n**OutputChunk**:\n\n- `type` - Distinguish stdout vs stderr\n- `data` - Raw bytes (agents may output non-UTF8)\n- `timestamp` - For log correlation and debugging\n\n**SpawnedChild**:\n\n- `process` - The managed process (from IProcessManager) - **reuses existing type**\n- `exitSignal` - Optional promise that resolves when agent is done\n  - Useful for protocols like ACP that emit completion events\n  - Allows engine to detect completion without waiting for process exit\n\n**Usage**:\n\n```typescript\n// Executor produces OutputChunks\nasync *createOutputStream(process: ManagedProcess): AsyncIterable<OutputChunk> {\n  const stdout = process.streams!.stdout;  // Uses ManagedProcess from process/types.ts\n  for await (const chunk of stdout) {\n    yield {\n      type: 'stdout',\n      data: chunk,\n      timestamp: new Date(),\n    };\n  }\n}\n\n// Normalizer consumes OutputChunks → produces NormalizedEntries\nasync *normalizeOutput(\n  stream: AsyncIterable<OutputChunk>,\n  workDir: string\n): AsyncIterable<NormalizedEntry> {\n  for await (const chunk of stream) {\n    const line = chunk.data.toString();\n    const entry = parseAgentOutput(line);\n    if (entry) yield entry;\n  }\n}\n```\n\n---\n\n## File Structure\n\nSprint 1 will create the following files:\n\n```\nsrc/agents/\n├── types/\n│   ├── agent-executor.ts        # IAgentExecutor, SpawnedChild, AgentCapabilities\n│   ├── normalized-output.ts     # NormalizedEntry and related types\n│   ├── approval-service.ts      # IApprovalService, ApprovalRequest/Decision\n│   └── index.ts                 # Re-export all types\n│\n├── base/\n│   ├── base-executor.ts         # BaseAgentExecutor abstract class\n│   │                            # INTEGRATION: Uses process/types, process/factory\n│   └── index.ts                 # Re-export\n│\n├── profiles/\n│   ├── types.ts                 # AgentProfileId, AgentProfile, ProfileRegistry\n│   ├── registry.ts              # AgentProfileRegistry class\n│   └── index.ts                 # Re-export\n│\n└── index.ts                     # Main entry point\n```\n\n**Files to modify (minimal changes)**:\n\n```\nsrc/engine/\n└── types.ts                     # ADD: agentProfile?: AgentProfileId to ExecutionTask\n```\n\n**No changes needed** to:\n\n- ✅ `src/process/*` - All files unchanged\n- ✅ `src/resilience/*` - All files unchanged\n- ✅ `src/workflow/*` - All files unchanged\n- ✅ `src/agents/types/agent-adapter.ts` - Keep for backward compatibility\n- ✅ `src/agents/claude/*`, `src/agents/codex/*` - Keep existing work\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n**File**: `tests/unit/agents/types/agent-executor.test.ts`\n\n- Type exports are correct\n- Discriminated unions work as expected\n\n**File**: `tests/unit/agents/base/base-executor.test.ts`\n\n```typescript\ndescribe('BaseAgentExecutor', () => {\n  it('should auto-approve when no approval service set', async () => {\n    const executor = new TestExecutor();\n    const decision = await executor['requestApproval']({\n      requestId: 'test-1',\n      toolName: 'Bash',\n      toolInput: { command: 'ls' },\n    });\n    expect(decision.status).toBe('approved');\n  });\n  \n  it('should delegate to approval service when set', async () => {\n    const service = {\n      requestApproval: vi.fn().mockResolvedValue({ status: 'denied' }),\n    };\n    const executor = new TestExecutor();\n    executor.setApprovalService(service);\n    \n    const decision = await executor['requestApproval']({\n      requestId: 'test-1',\n      toolName: 'Bash',\n      toolInput: { command: 'rm -rf /' },\n    });\n    \n    expect(service.requestApproval).toHaveBeenCalled();\n    expect(decision.status).toBe('denied');\n  });\n  \n  // INTEGRATION TEST: Verify BaseAgentExecutor uses existing infrastructure\n  it('should wrap ChildProcess to ManagedProcess using existing types', () => {\n    const executor = new TestExecutor();\n    const child = spawn('echo', ['test']);\n    \n    const managed = executor['wrapChildProcess'](child);\n    \n    // Verify it matches ManagedProcess interface from process/types.ts\n    expect(managed).toHaveProperty('id');\n    expect(managed).toHaveProperty('pid', child.pid);\n    expect(managed).toHaveProperty('status', 'running');\n    expect(managed).toHaveProperty('process', child);\n    expect(managed.streams).toHaveProperty('stdout');\n    expect(managed.streams).toHaveProperty('stderr');\n    expect(managed.streams).toHaveProperty('stdin');\n  });\n});\n```\n\n**File**: `tests/unit/agents/profiles/registry.test.ts`\n\n```typescript\ndescribe('AgentProfileRegistry', () => {\n  it('should register and retrieve executors', () => {\n    const registry = new AgentProfileRegistry();\n    const factory = vi.fn((config) => new MockExecutor(config));\n    \n    registry.registerExecutor('test', factory);\n    registry.registerProfile('test', 'default', {\n      config: { foo: 'bar' },\n      displayName: 'Test',\n    });\n    \n    const executor = registry.getExecutor({ executor: 'test' });\n    expect(executor).toBeDefined();\n    expect(factory).toHaveBeenCalledWith({ foo: 'bar' });\n  });\n  \n  it('should fall back to default variant if variant not specified', () => {\n    const registry = new AgentProfileRegistry();\n    registry.registerExecutor('test', (c) => new MockExecutor(c));\n    registry.registerProfile('test', 'default', { config: {}, displayName: 'Default' });\n    \n    const executor = registry.getExecutor({ executor: 'test' });\n    expect(executor).toBeDefined();\n  });\n});\n```\n\n### Integration Tests\n\nCreate `tests/integration/agents/base-executor-integration.test.ts`:\n\n- Test that `BaseAgentExecutor` works with real `IProcessManager`\n- Verify output stream creation using `ManagedProcess` streams\n- Test approval service integration\n- **Verify integration with existing process layer**:\n  ```typescript\n  it('should use existing IProcessManager to spawn processes', async () => {\n    const processManager = new SimpleProcessManager();\n    const executor = new TestExecutor({ processManager });\n    \n    const spawned = await executor.executeTask({\n      id: 'test',\n      type: 'custom',\n      prompt: 'test prompt',\n      workDir: '/tmp',\n      config: {},\n    });\n    \n    // Verify spawned.process is a valid ManagedProcess\n    expect(spawned.process).toMatchObject({\n      id: expect.any(String),\n      pid: expect.any(Number),\n      status: 'running',\n    });\n  });\n  ```\n\n---\n\n## Documentation Requirements\n\n### JSDoc Standards\n\nAll public APIs must have JSDoc comments with:\n\n- Summary (one sentence)\n- Description (detailed explanation)\n- `@param` for each parameter\n- `@returns` for return values\n- `@example` showing usage\n- `@throws` for documented errors\n\n**Example**:\n\n```typescript\n/**\n * Execute a task with this agent.\n * \n * Spawns a new process, sends the prompt, and returns a managed process\n * handle. Output can be consumed via the normalizeOutput() method.\n * \n * This method uses the existing IProcessManager infrastructure to spawn\n * and manage the child process lifecycle.\n * \n * @param task - Task configuration including prompt and working directory\n * @returns Spawned process (ManagedProcess from process/types.ts) with optional exit signal\n * @throws {ExecutorError} If agent is not available or spawn fails\n * \n * @example\n * ```typescript\n * const executor = new CursorExecutor({ workDir: '/tmp', force: true });\n * const spawned = await executor.executeTask({\n *   id: 'task-1',\n *   type: 'coding',\n *   prompt: 'Add a login feature',\n *   workDir: '/tmp',\n * });\n * \n * // spawned.process is a ManagedProcess (existing type)\n * console.log('Process PID:', spawned.process.pid);\n * ```\n */\nabstract executeTask(task: ExecutionTask): Promise<SpawnedChild>\n```\n\n### README Updates\n\nAdd section to `README.md`:\n\n```markdown\n## Agent Executors\n\nThe execution engine provides a unified interface for different CLI agents.\n\n### Supported Agents\n\n- **Cursor** - Simple JSONL protocol with auto-approval\n- **Codex** - OpenAI Codex CLI (exec mode and app-server mode)\n- **Claude Code** - Anthropic Claude Code with stream-json output\n- **Gemini** - Google Gemini CLI with ACP protocol\n\n### Using Executors\n\n\\`\\`\\`typescript\nimport { AgentProfileRegistry } from 'agent-execution-engine/agents';\nimport { CursorExecutor } from 'agent-execution-engine/agents/cursor';\n\n// Set up registry\nconst registry = new AgentProfileRegistry();\nregistry.registerExecutor('cursor', (config) => new CursorExecutor(config));\n\n// Load profiles\nconst profiles = { ... };\nregistry.loadProfiles(profiles);\n\n// Get executor\nconst executor = registry.getExecutor({ executor: 'cursor', variant: 'default' });\n\n// Execute task (uses existing ExecutionTask type from engine/types.ts)\nconst spawned = await executor.executeTask(task);\n\\`\\`\\`\n\n### Integration with Existing Layers\n\nThe agent executor layer integrates seamlessly with existing infrastructure:\n\n- **Process Management**: Uses `IProcessManager` and `ManagedProcess` from `process/*`\n- **Task Execution**: Extends `ExecutionTask` type from `engine/*`\n- **Resilience**: Works with `ResilientExecutor` from `resilience/*`\n- **Workflows**: Compatible with `LinearOrchestrator` from `workflow/*`\n\n\\`\\`\\`typescript\n// Full stack integration\nconst processManager = createProcessManager({ ... });\nconst engine = new SimpleExecutionEngine(processManager);\nconst resilientExecutor = new ResilientExecutor(engine, { maxAttempts: 3 });\nconst orchestrator = new LinearOrchestrator(resilientExecutor);\n\n// Use agent profiles in workflows\nconst workflow = {\n  steps: [{\n    id: 'step1',\n    prompt: 'Build feature',\n    agentProfile: { executor: 'claude-code', variant: 'plan' }\n  }]\n};\n\\`\\`\\`\n```\n\n---\n\n## Non-Functional Requirements\n\n### NFR1: Performance\n\n- Output normalization must support streaming (no buffering entire output)\n- Profile lookups should be O(1) (use Map/object)\n- No unnecessary object allocations in hot paths\n- **Reuse existing process management** (don't spawn multiple managers)\n\n### NFR2: Memory\n\n- Async iterables for output (constant memory regardless of output size)\n- Profile registry should not duplicate config objects\n- **Leverage existing ManagedProcess pooling** (don't create duplicate process wrappers)\n\n### NFR3: Type Safety\n\n- All public APIs must be fully typed (no `any`)\n- Discriminated unions for variant types\n- Generic type parameters where appropriate\n- **Strict compatibility with existing types** (`ManagedProcess`, `ProcessConfig`, etc.)\n\n### NFR4: Backward Compatibility\n\n- Existing `IAgentAdapter` interface must remain unchanged\n- Existing Claude/Codex adapters should continue to work\n- No breaking changes to process/engine/resilience layers\n- **Zero changes to existing layer interfaces**\n\n---\n\n## Migration Path\n\n### Phase 1: Add New Interfaces (Sprint 1)\n\n- Add new files alongside existing code\n- Minimal modification to existing files (only `engine/types.ts` - add 1 field)\n- 100% backward compatible\n\n### Phase 2: Implement Adapters (Sprint 2-4)\n\n- Create new executor implementations\n- Keep old adapters working\n- Gradual migration\n\n### Phase 3: Integrate (Sprint 5)\n\n- Update `SimpleExecutionEngine` to optionally use `IAgentExecutor`\n- Deprecate old `IAgentAdapter` usage\n- Maintain backward compatibility via adapter pattern\n\n---\n\n## Open Questions\n\n1. **Q: Should we support both** `IAgentAdapter` **and** `IAgentExecutor` **long-term?**\n\n- A: Yes, for backward compatibility. `IAgentAdapter` is simpler for basic use cases.\n\n1. **Q: How do we handle agent-specific output formats in metadata?**\n\n- A: Preserve raw output in `metadata` field, consumers can parse if needed.\n\n1. **Q: Should approval service be injectable per-task or per-executor?**\n\n- A: Per-executor (set once), simplifies API and matches vibe-kanban pattern.\n\n1. **Q: Do we need a factory interface or just use functions?**\n\n- A: Functions are simpler, no need for interface (YAGNI).\n\n1. **Q: Should BaseAgentExecutor create its own process manager or reuse existing one?**\n\n- A: Reuse existing via factory pattern (`createProcessManager()`), avoids duplication.\n\n---\n\n## Dependencies\n\n### Internal\n\n- `process/types` - `ManagedProcess`, `ProcessConfig` ✅ (100% reused)\n- `process/manager` - `IProcessManager` ✅ (used directly)\n- `process/factory` - `createProcessManager()` ✅ (used for spawning)\n- `process/utils` - `generateId()` ✅ (used for process IDs)\n- `engine/types` - `ExecutionTask`, `TaskResult` ⚠️ (extend with 1 field)\n\n### External\n\n- None (Sprint 1 is purely type definitions and base classes)\n\n---\n\n## Deliverables\n\nSprint 1 complete when:\n\n- ✅ All interfaces defined and documented\n- ✅ `BaseAgentExecutor` implemented with tests\n- ✅ `AgentProfileRegistry` implemented with tests\n- ✅ 100% test coverage on new code\n- ✅ JSDoc on all public APIs\n- ✅ README updated with agent executor section\n- ✅ No TypeScript errors in strict mode\n- ✅ All existing tests still pass (no regressions)\n- ✅ **Integration tests verify compatibility with existing** `IProcessManager`\n- ✅ **Minimal changes to existing files** (only 1 field addition to `ExecutionTask`)\n\n---\n\n## Timeline\n\n**Week 1**:\n\n- Day 1-2: Define all interfaces and types\n- Day 3-4: Implement `BaseAgentExecutor` and tests (focus on integration with existing process layer)\n- Day 5: Implement `AgentProfileRegistry` and tests\n\n**Week 2**:\n\n- Day 1-2: Documentation and examples (emphasize integration points)\n- Day 3-4: Code review and refinements\n- Day 5: Final testing and merge to main\n\n---\n\n## References\n\n- \\[\\[vibe-kanban\\]\\] - Reference implementation (Rust)\n  - `executors/src/executors/mod.rs` - `StandardCodingAgentExecutor` trait\n  - `executors/src/profile.rs` - Profile system\n  - `executors/src/executors/cursor.rs` - Example concrete executor\n- **Existing codebase** - Integration points:\n  - `src/process/types.ts` - `ManagedProcess`, `ProcessConfig` types\n  - `src/process/manager.ts` - `IProcessManager` interface\n  - `src/process/factory.ts` - `createProcessManager()` factory\n  - `src/engine/types.ts` - `ExecutionTask` type (to be extended)","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-20 08:14:37","updated_at":"2025-11-20 08:52:46","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["architecture","foundation","interfaces","sprint-1"]}
{"id":"s-925w","uuid":"059c1eb6-1819-4008-9fa4-9a2bb4a07345","title":"Claude Code Executor - Stream-JSON + Control Protocol Implementation","file_path":"specs/claude_code_executor_stream_json_control_protocol_.md","content":"# Claude Code Executor - Stream-JSON + Control Protocol Implementation\n\n## Overview\n\nImplement a Claude Code executor that wraps the `claude` CLI using the unified `IAgentExecutor` interface. Claude Code uses a **stream-json output format** with a **lightweight bidirectional control protocol** for interactive approvals.\n\n## Goals\n\n1. ✅ Implement `ClaudeCodeExecutor` extending `BaseAgentExecutor`\n2. ✅ Support both initial execution and session resumption\n3. ✅ Parse stream-json output format into `NormalizedEntry`\n4. ✅ Handle bidirectional control protocol for tool approvals\n5. ✅ Support hook-based approval flow (PreToolUse hook + can_use_tool)\n6. ✅ Stream assistant messages with proper coalescing\n\n## Context\n\n### Reference Implementation\n\nBased on vibe-kanban's Claude Code executor:\n- **File**: `crates/executors/src/executors/claude.rs` (280 lines)\n- **Protocol Peer**: `crates/executors/src/executors/claude/protocol.rs` (200 lines)\n- **Client**: `crates/executors/src/executors/claude/client.rs` (206 lines)\n\n### Protocol Overview\n\nClaude Code uses two communication layers:\n\n**Layer 1: Stream-JSON** (stdout)\n- Newline-delimited JSON messages\n- Message types: `system`, `user`, `assistant`, `tool_use`, `result`\n- Each message has `type` field for discrimination\n\n**Layer 2: Control Protocol** (stdin ↔ stdout)\n- Bidirectional JSON messages for approvals\n- Message types: `control_request`, `control_response`\n- Handles `can_use_tool` and `hook_callback` requests\n\n```\n┌─────────────────────────────────────────────────────┐\n│  ClaudeCodeExecutor                                 │\n│                                                     │\n│  1. Spawns: claude -p --output-format=stream-json  │\n│     --input-format=stream-json                     │\n│     --permission-prompt-tool=stdio                 │\n│                                                     │\n│  2. ProtocolPeer manages stdin/stdout              │\n│     ├─ Reads stream-json from stdout              │\n│     ├─ Parses control_request messages            │\n│     ├─ Sends control_response to stdin            │\n│     └─ Forwards regular messages to normalizer    │\n│                                                     │\n│  3. ClaudeAgentClient handles logic                │\n│     ├─ on_can_use_tool() - approval decisions     │\n│     ├─ on_hook_callback() - captures tool_use_id  │\n│     └─ on_non_control() - forwards to output      │\n└─────────────────────────────────────────────────────┘\n                     │\n                     ▼\n      ┌──────────────────────────────────────┐\n      │  Claude Code CLI Process              │\n      │                                       │\n      │  • Writes stream-json to stdout      │\n      │  • Reads JSON from stdin             │\n      │  • Sends control_request when        │\n      │    approval needed                   │\n      │  • Waits for control_response        │\n      └──────────────────────────────────────┘\n```\n\n---\n\n## Requirements\n\n### R1: ClaudeCodeExecutor Class\n\n**Priority**: P0 (Critical)\n\nMain executor class implementing `IAgentExecutor`.\n\n**Interface**:\n```typescript\nexport interface ClaudeCodeConfig {\n  workDir: string\n  executablePath?: string      // Path to 'claude' binary (default: 'claude')\n  print?: boolean              // -p flag (required for stream-json)\n  outputFormat?: 'stream-json' | 'json'  // Default: 'stream-json'\n  inputFormat?: 'stream-json'  // Default: 'stream-json'\n  verbose?: boolean            // --verbose flag\n  dangerouslySkipPermissions?: boolean  // Skip all approvals (for testing)\n}\n\nexport class ClaudeCodeExecutor extends BaseAgentExecutor {\n  constructor(config: ClaudeCodeConfig)\n  \n  async executeTask(task: ExecutionTask): Promise<SpawnedChild>\n  async resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild>\n  async *normalizeOutput(stream: AsyncIterable<OutputChunk>, workDir: string): AsyncIterable<NormalizedEntry>\n  getCapabilities(): AgentCapabilities\n}\n```\n\n**Implementation Details**:\n\n**executeTask()**:\n```typescript\nasync executeTask(task: ExecutionTask): Promise<SpawnedChild> {\n  // 1. Build command args\n  const args = [\n    '-p',  // Print mode (required for stream-json)\n    '--output-format', this.config.outputFormat ?? 'stream-json',\n    '--input-format', this.config.inputFormat ?? 'stream-json',\n    '--permission-prompt-tool', 'stdio',  // Use stdin/stdout for approvals\n  ];\n  \n  if (this.config.verbose) {\n    args.push('--verbose');\n  }\n  \n  if (this.config.dangerouslySkipPermissions) {\n    args.push('--dangerously-skip-permissions');\n  }\n  \n  // 2. Spawn process\n  const child = spawn(this.config.executablePath ?? 'claude', args, {\n    cwd: task.workDir,\n    stdio: ['pipe', 'pipe', 'pipe'],\n  });\n  \n  // 3. Set up protocol peer\n  const stdin = child.stdin!;\n  const stdout = child.stdout!;\n  const stderr = child.stderr!;\n  \n  const client = new ClaudeAgentClient(this.approvalService);\n  const peer = new ProtocolPeer(stdin, stdout, client);\n  \n  // 4. Initialize protocol\n  await peer.initialize(this.buildHooks());\n  \n  // 5. Send user message\n  await peer.sendUserMessage(task.prompt);\n  \n  // 6. Return wrapped process\n  return {\n    process: this.wrapChildProcess(child),\n  };\n}\n```\n\n**resumeTask()**:\n```typescript\nasync resumeTask(task: ExecutionTask, sessionId: string): Promise<SpawnedChild> {\n  // Same as executeTask but add --resume-session flag\n  // Claude Code automatically loads session from ~/.claude/sessions/{sessionId}\n  const args = [\n    '-p',\n    '--output-format', 'stream-json',\n    '--resume-session', sessionId,\n    // ... rest of args\n  ];\n  \n  // ... spawn and return\n}\n```\n\n**getCapabilities()**:\n```typescript\ngetCapabilities(): AgentCapabilities {\n  return {\n    supportsSessionResume: true,\n    requiresSetup: false,  // No login required\n    supportsApprovals: true,\n    supportsMcp: true,\n    protocol: 'stream-json',\n  };\n}\n```\n\n---\n\n### R2: Stream-JSON Message Types\n\n**Priority**: P0 (Critical)\n\nType definitions for Claude Code's stream-json output format.\n\n**Message Envelope**:\n```typescript\nexport type ClaudeStreamMessage = \n  | SystemMessage\n  | UserMessage\n  | AssistantMessage\n  | ToolUseMessage\n  | ResultMessage\n  | ControlRequestMessage\n  | ControlResponseMessage;\n\n// Base fields present on all messages\ninterface BaseMessage {\n  type: string\n  sessionId?: string\n}\n```\n\n**System Messages**:\n```typescript\ninterface SystemMessage extends BaseMessage {\n  type: 'system'\n  subtype?: 'init' | 'session_start'\n  sessionId: string\n  model?: string\n  mcpServers?: Array<{ name: string; status: string }>\n}\n```\n\n**User Messages**:\n```typescript\ninterface UserMessage extends BaseMessage {\n  type: 'user'\n  message: {\n    role: 'user'\n    content: Array<ContentBlock>\n  }\n  sessionId?: string\n}\n```\n\n**Assistant Messages**:\n```typescript\ninterface AssistantMessage extends BaseMessage {\n  type: 'assistant'\n  message: {\n    role: 'assistant'\n    content: Array<ContentBlock>\n  }\n  sessionId?: string\n}\n\ntype ContentBlock = TextBlock | ToolUseBlock;\n\ninterface TextBlock {\n  type: 'text'\n  text: string\n}\n\ninterface ToolUseBlock {\n  type: 'tool_use'\n  id: string          // tool_use_id (for matching with hook callbacks)\n  name: string        // Tool name: 'Bash', 'Edit', 'Read', etc.\n  input: unknown      // Tool-specific input\n}\n```\n\n**Tool Use Messages**:\n```typescript\ninterface ToolUseMessage extends BaseMessage {\n  type: 'tool_use'\n  subtype?: 'started' | 'completed'\n  toolUseId?: string\n  toolName?: string\n  toolInput?: unknown\n  toolResult?: unknown\n  sessionId?: string\n}\n```\n\n**Result Messages**:\n```typescript\ninterface ResultMessage extends BaseMessage {\n  type: 'result'\n  isError: boolean\n  durationMs?: number\n  result?: unknown\n  sessionId?: string\n}\n```\n\n---\n\n### R3: Control Protocol Types\n\n**Priority**: P0 (Critical)\n\nType definitions for the bidirectional control protocol.\n\n**Control Request** (from CLI → SDK):\n```typescript\ninterface ControlRequestMessage extends BaseMessage {\n  type: 'control_request'\n  requestId: string\n  request: ControlRequest\n}\n\ntype ControlRequest = \n  | CanUseToolRequest\n  | HookCallbackRequest;\n\ninterface CanUseToolRequest {\n  type: 'can_use_tool'\n  toolName: string\n  input: unknown\n  permissionSuggestions?: PermissionUpdate[]\n}\n\ninterface HookCallbackRequest {\n  type: 'hook_callback'\n  callbackId: string\n  input: unknown\n  toolUseId?: string   // Present for PreToolUse hook\n}\n\ninterface PermissionUpdate {\n  updateType: 'set_mode' | 'add_permission' | 'remove_permission'\n  mode?: PermissionMode\n  destination: 'session' | 'global'\n}\n\ntype PermissionMode = 'ask' | 'bypass_permissions';\n```\n\n**Control Response** (from SDK → CLI):\n```typescript\ninterface ControlResponseMessage {\n  type: 'control_response'\n  response: ControlResponse\n}\n\ntype ControlResponse = \n  | SuccessResponse\n  | ErrorResponse;\n\ninterface SuccessResponse {\n  type: 'success'\n  requestId: string\n  response?: unknown  // Hook output or permission decision\n}\n\ninterface ErrorResponse {\n  type: 'error'\n  requestId: string\n  error?: string\n}\n```\n\n**Permission Decisions**:\n```typescript\ntype PermissionResult = AllowResult | DenyResult;\n\ninterface AllowResult {\n  result: 'allow'\n  updatedInput?: unknown\n  updatedPermissions?: PermissionUpdate[]\n}\n\ninterface DenyResult {\n  result: 'deny'\n  message?: string\n  interrupt?: boolean  // Should agent stop execution?\n}\n```\n\n---\n\n### R4: ProtocolPeer Class\n\n**Priority**: P0 (Critical)\n\nManages bidirectional communication over stdin/stdout.\n\n**Class Structure**:\n```typescript\nexport class ProtocolPeer {\n  private stdin: Writable\n  private stdoutReader: AsyncIterable<string>\n  private client: ClaudeAgentClient\n  \n  constructor(\n    stdin: Writable,\n    stdout: Readable,\n    client: ClaudeAgentClient\n  )\n  \n  // Lifecycle\n  async initialize(hooks?: HookConfig): Promise<void>\n  async setPermissionMode(mode: PermissionMode): Promise<void>\n  \n  // Sending messages\n  async sendUserMessage(content: string): Promise<void>\n  async sendControlResponse(requestId: string, response: ControlResponse): Promise<void>\n  \n  // Reading loop (internal)\n  private async readLoop(): Promise<void>\n  private async handleControlRequest(requestId: string, request: ControlRequest): Promise<void>\n}\n```\n\n**Implementation Details**:\n\n**Constructor + Read Loop**:\n```typescript\nconstructor(stdin: Writable, stdout: Readable, client: ClaudeAgentClient) {\n  this.stdin = stdin;\n  this.stdoutReader = this.createLineReader(stdout);\n  this.client = client;\n  \n  // Start background read loop\n  this.startReadLoop();\n}\n\nprivate async readLoop(): Promise<void> {\n  for await (const line of this.stdoutReader) {\n    if (!line.trim()) continue;\n    \n    try {\n      const message = JSON.parse(line) as ClaudeStreamMessage;\n      \n      if (message.type === 'control_request') {\n        await this.handleControlRequest(message.requestId, message.request);\n      } else if (message.type === 'result') {\n        // Task complete - forward to client and exit loop\n        await this.client.onNonControl(line);\n        break;\n      } else {\n        // Regular message - forward to client\n        await this.client.onNonControl(line);\n      }\n    } catch (e) {\n      // Non-JSON line - forward as-is\n      await this.client.onNonControl(line);\n    }\n  }\n}\n```\n\n**Control Request Handling**:\n```typescript\nprivate async handleControlRequest(requestId: string, request: ControlRequest): Promise<void> {\n  try {\n    let response: unknown;\n    \n    if (request.type === 'can_use_tool') {\n      response = await this.client.onCanUseTool(\n        request.toolName,\n        request.input,\n        request.permissionSuggestions\n      );\n    } else if (request.type === 'hook_callback') {\n      response = await this.client.onHookCallback(\n        request.callbackId,\n        request.input,\n        request.toolUseId\n      );\n    }\n    \n    await this.sendControlResponse(requestId, {\n      type: 'success',\n      requestId,\n      response,\n    });\n  } catch (error) {\n    await this.sendControlResponse(requestId, {\n      type: 'error',\n      requestId,\n      error: error.message,\n    });\n  }\n}\n```\n\n**Sending Messages**:\n```typescript\nasync sendUserMessage(content: string): Promise<void> {\n  const message = {\n    type: 'user',\n    message: {\n      role: 'user',\n      content,\n    },\n  };\n  await this.sendJson(message);\n}\n\nasync sendControlResponse(requestId: string, response: ControlResponse): Promise<void> {\n  const message: ControlResponseMessage = {\n    type: 'control_response',\n    response,\n  };\n  await this.sendJson(message);\n}\n\nprivate async sendJson(message: unknown): Promise<void> {\n  const json = JSON.stringify(message);\n  this.stdin.write(json + '\\n');\n}\n```\n\n**Initialize with Hooks**:\n```typescript\nasync initialize(hooks?: HookConfig): Promise<void> {\n  const message = {\n    type: 'sdk_control_request',\n    request: {\n      type: 'initialize',\n      hooks: hooks ?? {\n        preToolUse: {\n          enabled: true,\n        },\n      },\n    },\n  };\n  await this.sendJson(message);\n}\n```\n\n---\n\n### R5: ClaudeAgentClient Class\n\n**Priority**: P0 (Critical)\n\nBusiness logic for handling approval requests and hook callbacks.\n\n**Class Structure**:\n```typescript\nexport class ClaudeAgentClient {\n  private approvalService?: IApprovalService\n  private latestUnhandledToolUseId: string | null = null\n  \n  constructor(approvalService?: IApprovalService)\n  \n  // Approval flow\n  async onCanUseTool(\n    toolName: string,\n    input: unknown,\n    permissionSuggestions?: PermissionUpdate[]\n  ): Promise<PermissionResult>\n  \n  // Hook callbacks\n  async onHookCallback(\n    callbackId: string,\n    input: unknown,\n    toolUseId?: string\n  ): Promise<HookOutput>\n  \n  // Output forwarding\n  async onNonControl(line: string): Promise<void>\n}\n```\n\n**Implementation Details**:\n\n**Hook Callback Flow**:\n```typescript\nasync onHookCallback(\n  callbackId: string,\n  input: unknown,\n  toolUseId?: string\n): Promise<HookOutput> {\n  // Store tool_use_id for later approval matching\n  if (toolUseId) {\n    this.latestUnhandledToolUseId = toolUseId;\n  }\n  \n  // Return 'ask' to trigger can_use_tool request\n  // (Hook callbacks have 60s timeout, can't wait for user)\n  return {\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'ask',\n      permissionDecisionReason: 'Forwarding to can_use_tool service',\n    },\n  };\n}\n```\n\n**Approval Flow**:\n```typescript\nasync onCanUseTool(\n  toolName: string,\n  input: unknown,\n  permissionSuggestions?: PermissionUpdate[]\n): Promise<PermissionResult> {\n  // Auto-approve if no service\n  if (!this.approvalService) {\n    return {\n      result: 'allow',\n      updatedInput: input,\n    };\n  }\n  \n  // Get tool_use_id from previous hook callback\n  const toolUseId = this.latestUnhandledToolUseId;\n  this.latestUnhandledToolUseId = null;  // Clear for next tool\n  \n  // Request approval\n  const decision = await this.approvalService.requestApproval({\n    requestId: toolUseId ?? crypto.randomUUID(),\n    toolName,\n    toolInput: input,\n  });\n  \n  // Convert to PermissionResult\n  if (decision.status === 'approved') {\n    // Special case: ExitPlanMode switches to bypass mode\n    if (toolName === 'ExitPlanMode') {\n      return {\n        result: 'allow',\n        updatedInput: input,\n        updatedPermissions: [{\n          updateType: 'set_mode',\n          mode: 'bypass_permissions',\n          destination: 'session',\n        }],\n      };\n    }\n    \n    return {\n      result: 'allow',\n      updatedInput: input,\n    };\n  }\n  \n  return {\n    result: 'deny',\n    message: decision.reason ?? 'Denied by user',\n    interrupt: false,\n  };\n}\n```\n\n---\n\n### R6: Output Normalization\n\n**Priority**: P0 (Critical)\n\nParse Claude stream-json into `NormalizedEntry` format.\n\n**Normalizer Implementation**:\n```typescript\nasync *normalizeOutput(\n  stream: AsyncIterable<OutputChunk>,\n  workDir: string\n): AsyncIterable<NormalizedEntry> {\n  let index = 0;\n  \n  // Streaming state\n  let sessionIdReported = false;\n  let currentAssistantBuffer = '';\n  let currentAssistantIndex: number | null = null;\n  \n  const toolUseMap = new Map<string, number>();  // tool_use_id -> entry index\n  \n  for await (const chunk of stream) {\n    if (chunk.type !== 'stdout') continue;\n    \n    const lines = chunk.data.toString().split('\\n');\n    \n    for (const line of lines) {\n      if (!line.trim()) continue;\n      \n      try {\n        const message = JSON.parse(line) as ClaudeStreamMessage;\n        \n        // Extract session ID (once)\n        if (!sessionIdReported && message.sessionId) {\n          // TODO: Store session ID somewhere\n          sessionIdReported = true;\n        }\n        \n        // Handle message types\n        if (message.type === 'system') {\n          yield this.normalizeSystemMessage(message, index++);\n        } else if (message.type === 'assistant') {\n          // Coalesce streaming assistant messages\n          const textContent = message.message.content\n            .filter((c): c is TextBlock => c.type === 'text')\n            .map(c => c.text)\n            .join('');\n          \n          if (textContent) {\n            currentAssistantBuffer += textContent;\n            \n            const entry: NormalizedEntry = {\n              index: currentAssistantIndex ?? index,\n              type: { kind: 'assistant_message' },\n              content: currentAssistantBuffer,\n              timestamp: chunk.timestamp,\n            };\n            \n            if (currentAssistantIndex === null) {\n              currentAssistantIndex = index++;\n              yield entry;\n            } else {\n              // Update existing entry\n              yield { ...entry, index: currentAssistantIndex };\n            }\n          }\n          \n          // Handle tool uses in content\n          const toolUses = message.message.content\n            .filter((c): c is ToolUseBlock => c.type === 'tool_use');\n          \n          for (const toolUse of toolUses) {\n            const entry = this.normalizeToolUse(toolUse, index, workDir);\n            toolUseMap.set(toolUse.id, index);\n            yield entry;\n            index++;\n          }\n          \n          // Reset assistant buffer on non-streaming\n          if (!textContent) {\n            currentAssistantBuffer = '';\n            currentAssistantIndex = null;\n          }\n        } else if (message.type === 'tool_use' && message.subtype === 'completed') {\n          // Update tool use entry with result\n          const entryIndex = toolUseMap.get(message.toolUseId ?? '');\n          if (entryIndex !== undefined) {\n            yield this.normalizeToolResult(message, entryIndex, workDir);\n          }\n        } else if (message.type === 'result') {\n          // Task completion\n          if (message.isError) {\n            yield {\n              index: index++,\n              type: {\n                kind: 'error',\n                error: {\n                  errorType: 'execution_failed',\n                  message: JSON.stringify(message.result),\n                },\n              },\n              content: 'Task failed',\n              timestamp: chunk.timestamp,\n            };\n          }\n        }\n      } catch (e) {\n        // Non-JSON line - emit as system message\n        yield {\n          index: index++,\n          type: { kind: 'system_message' },\n          content: line,\n          timestamp: chunk.timestamp,\n        };\n      }\n    }\n  }\n}\n```\n\n**Tool Use Normalization**:\n```typescript\nprivate normalizeToolUse(\n  toolUse: ToolUseBlock,\n  index: number,\n  workDir: string\n): NormalizedEntry {\n  const action = this.parseToolAction(toolUse.name, toolUse.input, workDir);\n  \n  return {\n    index,\n    type: {\n      kind: 'tool_use',\n      tool: {\n        toolName: toolUse.name,\n        action,\n        status: 'created',\n      },\n    },\n    content: this.formatToolContent(toolUse.name, toolUse.input),\n    timestamp: new Date(),\n  };\n}\n\nprivate parseToolAction(\n  toolName: string,\n  input: unknown,\n  workDir: string\n): ActionType {\n  // Parse different tool types\n  if (toolName === 'Bash') {\n    const cmd = (input as any)?.command ?? '';\n    return {\n      kind: 'command_run',\n      command: cmd,\n    };\n  } else if (toolName === 'Edit') {\n    const path = this.makeRelative((input as any)?.path ?? '', workDir);\n    return {\n      kind: 'file_edit',\n      path,\n      changes: [],  // Will be filled in on completion\n    };\n  } else if (toolName === 'Read') {\n    const path = this.makeRelative((input as any)?.path ?? '', workDir);\n    return {\n      kind: 'file_read',\n      path,\n    };\n  } else if (toolName === 'Write') {\n    const path = this.makeRelative((input as any)?.path ?? '', workDir);\n    return {\n      kind: 'file_write',\n      path,\n    };\n  }\n  \n  // Generic tool\n  return {\n    kind: 'tool',\n    toolName,\n    args: input,\n  };\n}\n```\n\n---\n\n## File Structure\n\n```\nsrc/agents/claude/\n├── types/\n│   ├── messages.ts           # ClaudeStreamMessage types\n│   ├── control.ts            # Control protocol types\n│   └── index.ts              # Re-exports\n│\n├── protocol/\n│   ├── protocol-peer.ts      # ProtocolPeer class\n│   ├── client.ts             # ClaudeAgentClient class\n│   └── index.ts              # Re-exports\n│\n├── executor.ts               # ClaudeCodeExecutor class\n├── normalizer.ts             # Output normalization logic\n├── config-builder.ts         # Legacy adapter (keep for back-compat)\n└── index.ts                  # Main exports\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n**File**: `tests/unit/agents/claude/protocol-peer.test.ts`\n```typescript\ndescribe('ProtocolPeer', () => {\n  it('should parse control requests from stdout', async () => {\n    const mockStdout = createMockReadable([\n      '{\"type\":\"control_request\",\"requestId\":\"req-1\",\"request\":{\"type\":\"can_use_tool\",\"toolName\":\"Bash\",\"input\":{\"command\":\"ls\"}}}\\n'\n    ]);\n    \n    const client = {\n      onCanUseTool: vi.fn().mockResolvedValue({ result: 'allow' }),\n      onNonControl: vi.fn(),\n    };\n    \n    const peer = new ProtocolPeer(mockStdin, mockStdout, client as any);\n    \n    await waitFor(() => expect(client.onCanUseTool).toHaveBeenCalled());\n    expect(client.onCanUseTool).toHaveBeenCalledWith('Bash', { command: 'ls' }, undefined);\n  });\n  \n  it('should send control responses to stdin', async () => {\n    const mockStdin = createMockWritable();\n    const peer = new ProtocolPeer(mockStdin, mockStdout, mockClient);\n    \n    await peer.sendControlResponse('req-1', {\n      type: 'success',\n      requestId: 'req-1',\n      response: { result: 'allow' },\n    });\n    \n    expect(mockStdin.writtenData).toContain('{\"type\":\"control_response\"');\n  });\n});\n```\n\n**File**: `tests/unit/agents/claude/client.test.ts`\n```typescript\ndescribe('ClaudeAgentClient', () => {\n  it('should store tool_use_id from hook callback', async () => {\n    const client = new ClaudeAgentClient();\n    \n    await client.onHookCallback('cb-1', {}, 'tool-123');\n    \n    // Next can_use_tool should use this ID\n    const approvalService = {\n      requestApproval: vi.fn().mockResolvedValue({ status: 'approved' }),\n    };\n    client['approvalService'] = approvalService;\n    \n    await client.onCanUseTool('Bash', { command: 'ls' });\n    \n    expect(approvalService.requestApproval).toHaveBeenCalledWith({\n      requestId: 'tool-123',\n      toolName: 'Bash',\n      toolInput: { command: 'ls' },\n    });\n  });\n  \n  it('should switch to bypass mode on ExitPlanMode approval', async () => {\n    const approvalService = {\n      requestApproval: vi.fn().mockResolvedValue({ status: 'approved' }),\n    };\n    const client = new ClaudeAgentClient(approvalService);\n    \n    const result = await client.onCanUseTool('ExitPlanMode', {});\n    \n    expect(result).toMatchObject({\n      result: 'allow',\n      updatedPermissions: [{\n        updateType: 'set_mode',\n        mode: 'bypass_permissions',\n        destination: 'session',\n      }],\n    });\n  });\n});\n```\n\n**File**: `tests/unit/agents/claude/normalizer.test.ts`\n```typescript\ndescribe('ClaudeCodeExecutor.normalizeOutput', () => {\n  it('should parse system init message', async () => {\n    const executor = new ClaudeCodeExecutor({ workDir: '/tmp' });\n    const stream = mockOutputChunks([\n      '{\"type\":\"system\",\"subtype\":\"init\",\"sessionId\":\"sess-123\",\"model\":\"claude-sonnet-4\"}\\n'\n    ]);\n    \n    const normalized = [];\n    for await (const entry of executor.normalizeOutput(stream, '/tmp')) {\n      normalized.push(entry);\n    }\n    \n    expect(normalized).toHaveLength(1);\n    expect(normalized[0].type.kind).toBe('system_message');\n    expect(normalized[0].content).toContain('claude-sonnet-4');\n  });\n  \n  it('should coalesce streaming assistant messages', async () => {\n    const executor = new ClaudeCodeExecutor({ workDir: '/tmp' });\n    const stream = mockOutputChunks([\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Hello\"}]}}\\n',\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\" world\"}]}}\\n',\n    ]);\n    \n    const normalized = [];\n    for await (const entry of executor.normalizeOutput(stream, '/tmp')) {\n      normalized.push(entry);\n    }\n    \n    // Should produce 2 entries (initial + update) with same index\n    expect(normalized).toHaveLength(2);\n    expect(normalized[0].content).toBe('Hello');\n    expect(normalized[1].content).toBe('Hello world');\n    expect(normalized[0].index).toBe(normalized[1].index);\n  });\n  \n  it('should parse tool use with Bash command', async () => {\n    const executor = new ClaudeCodeExecutor({ workDir: '/tmp' });\n    const stream = mockOutputChunks([\n      '{\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"id\":\"tool-1\",\"name\":\"Bash\",\"input\":{\"command\":\"ls -la\"}}]}}\\n'\n    ]);\n    \n    const normalized = [];\n    for await (const entry of executor.normalizeOutput(stream, '/tmp')) {\n      normalized.push(entry);\n    }\n    \n    expect(normalized).toHaveLength(1);\n    expect(normalized[0].type).toMatchObject({\n      kind: 'tool_use',\n      tool: {\n        toolName: 'Bash',\n        action: { kind: 'command_run', command: 'ls -la' },\n        status: 'created',\n      },\n    });\n  });\n});\n```\n\n### Integration Tests\n\n**File**: `tests/integration/agents/claude/executor-integration.test.ts`\n```typescript\ndescribe('ClaudeCodeExecutor (integration)', () => {\n  it('should execute task and parse output', async () => {\n    const executor = new ClaudeCodeExecutor({\n      workDir: '/tmp/test',\n      dangerouslySkipPermissions: true,  // Skip approvals for test\n    });\n    \n    const task: ExecutionTask = {\n      id: 'test-1',\n      type: 'coding',\n      prompt: 'List files in current directory',\n      workDir: '/tmp/test',\n    };\n    \n    const spawned = await executor.executeTask(task);\n    \n    // Collect output\n    const entries: NormalizedEntry[] = [];\n    const outputStream = createOutputChunks(spawned.process);\n    \n    for await (const entry of executor.normalizeOutput(outputStream, '/tmp/test')) {\n      entries.push(entry);\n    }\n    \n    // Should have system init, assistant message, tool use, result\n    expect(entries.length).toBeGreaterThan(0);\n    expect(entries.some(e => e.type.kind === 'system_message')).toBe(true);\n    expect(entries.some(e => e.type.kind === 'assistant_message')).toBe(true);\n  });\n});\n```\n\n---\n\n## Dependencies\n\n### Internal\n- [[s-6s6c]] - Sprint 1 foundation (IAgentExecutor, BaseAgentExecutor)\n- `process/types` - ManagedProcess\n- `engine/types` - ExecutionTask\n\n### External\n- None (uses only Node.js built-ins)\n\n---\n\n## Non-Functional Requirements\n\n### NFR1: Performance\n- Stream processing (no buffering entire output)\n- Async iterator for memory efficiency\n- Coalesce streaming messages to reduce UI updates\n\n### NFR2: Robustness\n- Handle non-JSON lines gracefully\n- Continue on parse errors\n- Proper error propagation\n\n### NFR3: Type Safety\n- All message types fully typed\n- Discriminated unions for pattern matching\n- No `any` types in public API\n\n---\n\n## Implementation Phases\n\n### Phase 1: Core Types (Day 1-2)\n- [ ] Define all message types\n- [ ] Define control protocol types\n- [ ] Write type tests\n\n### Phase 2: Protocol Layer (Day 3-4)\n- [ ] Implement ProtocolPeer\n- [ ] Implement ClaudeAgentClient\n- [ ] Unit tests for protocol\n\n### Phase 3: Executor (Day 5-6)\n- [ ] Implement ClaudeCodeExecutor\n- [ ] Implement executeTask/resumeTask\n- [ ] Integration with BaseAgentExecutor\n\n### Phase 4: Normalization (Day 7-8)\n- [ ] Implement normalizeOutput\n- [ ] Tool use parsing\n- [ ] Message coalescing\n\n### Phase 5: Testing & Polish (Day 9-10)\n- [ ] Complete unit test coverage\n- [ ] Integration tests\n- [ ] Documentation\n- [ ] Edge case handling\n\n---\n\n## Open Questions\n\n1. **Q: Should we support both stream-json and regular json output?**\n   - A: Start with stream-json only. Regular json is deprecated in Claude Code.\n\n2. **Q: How to handle session storage?**\n   - A: Claude Code stores sessions in `~/.claude/sessions/`. We just pass session ID, CLI handles the rest.\n\n3. **Q: What about MCP server configuration?**\n   - A: Claude Code reads from `~/.claude/claude_desktop_config.json`. Executor doesn't manage this.\n\n4. **Q: Should we implement plan mode as a separate executor or config option?**\n   - A: Config option. Plan mode is just a flag: `--enable-plan-mode`\n\n---\n\n## Success Criteria\n\nSprint complete when:\n- ✅ ClaudeCodeExecutor implements full IAgentExecutor interface\n- ✅ Can execute tasks and parse output\n- ✅ Approval flow works (hook → can_use_tool)\n- ✅ Session resumption works\n- ✅ 100% test coverage on protocol layer\n- ✅ Integration test passes with real Claude CLI\n- ✅ Documentation with examples\n\n---\n\n## References\n\n- vibe-kanban Claude implementation: `crates/executors/src/executors/claude.rs`\n- Claude Code docs: https://docs.claude.com/en/api/agent-sdk\n- Control protocol spec: https://docs.claude.com/en/api/agent-sdk/permissions\n","priority":0,"archived":0,"archived_at":null,"created_at":"2025-11-20 08:40:33","updated_at":"2025-11-20 08:40:33","parent_id":null,"parent_uuid":null,"relationships":[{"from":"s-925w","from_type":"spec","to":"s-6s6c","to_type":"spec","type":"depends-on"}],"tags":["claude-code","control-protocol","implementation","sprint-2","stream-json"]}
